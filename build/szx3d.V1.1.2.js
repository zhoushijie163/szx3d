/**
 * 文件名: szx3d.js
 * 爱护网世中心3Ｄ引擎
 *
 * @version V1.1.2   2017-3-15
 * @author Zhou Shijie
 */
(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define([ "exports" ], factory) : factory(global.SZX3D = global.SZX3D || {});
})(this, function(exports) {
    "use strict";
    var REVISION = "1.1.2";
    var MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1e3;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3e3;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    if (Number.EPSILON === undefined) {
        Number.EPSILON = Math.pow(2, -52);
    }
    if (Math.sign === undefined) {
        Math.sign = function(x) {
            return x < 0 ? -1 : x > 0 ? 1 : +x;
        };
    }
    if (Function.prototype.name === undefined) {
        Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            }
        });
    }
    if (Object.assign === undefined) {
        (function() {
            Object.assign = function(target) {
                "use strict";
                if (target === undefined || target === null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            };
        })();
    }
    function arrayMin(array) {
        var length = array.length, min = Infinity;
        while (length--) {
            if (array[length] < min) {
                min = array[length];
            }
        }
        return min;
    }
    function arrayMax(array) {
        var length = array.length, max = -Infinity;
        while (length--) {
            if (array[length] > max) {
                max = array[length];
            }
        }
        return max;
    }
    var _Math = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
            var uuid = new Array(36);
            var rnd = 0, r;
            return function generateUUID() {
                for (var i = 0; i < 36; i++) {
                    if (i === 8 || i === 13 || i === 18 || i === 23) {
                        uuid[i] = "-";
                    } else if (i === 14) {
                        uuid[i] = "4";
                    } else {
                        if (rnd <= 2) rnd = 33554432 + Math.random() * 16777216 | 0;
                        r = rnd & 15;
                        rnd = rnd >> 4;
                        uuid[i] = chars[i === 19 ? r & 3 | 8 : r];
                    }
                }
                return uuid.join("");
            };
        }(),
        clamp: function(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        euclideanModulo: function(n, m) {
            return (n % m + m) % m;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        lerp: function(x, y, t) {
            return (1 - t) * x + t * y;
        },
        smoothstep: function(x, min, max) {
            if (x <= min) return 0;
            if (x >= max) return 1;
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            if (x <= min) return 0;
            if (x >= max) return 1;
            x = (x - min) / (max - min);
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        randInt: function(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        randFloat: function(low, high) {
            return low + Math.random() * (high - low);
        },
        randFloatSpread: function(range) {
            return range * (.5 - Math.random());
        },
        degToRad: function(degrees) {
            return degrees * _Math.DEG2RAD;
        },
        radToDeg: function(radians) {
            return radians * _Math.RAD2DEG;
        },
        isPowerOfTwo: function(value) {
            return (value & value - 1) === 0 && value !== 0;
        },
        nearestPowerOfTwo: function(value) {
            return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
        },
        nextPowerOfTwo: function(value) {
            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value++;
            return value;
        }
    };
    function Color(r, g, b) {
        if (g === undefined && b === undefined) {
            return this.set(r);
        }
        return this.setRGB(r, g, b);
    }
    Color.prototype = {
        constructor: Color,
        isColor: true,
        r: 1,
        g: 1,
        b: 1,
        set: function(value) {
            if (value && value.isColor) {
                this.copy(value);
            } else if (typeof value === "number") {
                this.setHex(value);
            } else if (typeof value === "string") {
                this.setStyle(value);
            }
            return this;
        },
        setScalar: function(scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
            return this;
        },
        setHex: function(hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        },
        setRGB: function(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        },
        setHSL: function() {
            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                return p;
            }
            return function setHSL(h, s, l) {
                h = _Math.euclideanModulo(h, 1);
                s = _Math.clamp(s, 0, 1);
                l = _Math.clamp(l, 0, 1);
                if (s === 0) {
                    this.r = this.g = this.b = l;
                } else {
                    var p = l <= .5 ? l * (1 + s) : l + s - l * s;
                    var q = 2 * l - p;
                    this.r = hue2rgb(q, p, h + 1 / 3);
                    this.g = hue2rgb(q, p, h);
                    this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
            };
        }(),
        setStyle: function(style) {
            function handleAlpha(string) {
                if (string === undefined) return;
                if (parseFloat(string) < 1) {
                    console.warn("SZX3D.Color: Alpha component of " + style + " will be ignored.");
                }
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                  case "rgb":
                  case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[5]);
                        return this;
                    }
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[5]);
                        return this;
                    }
                    break;

                  case "hsl":
                  case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        var h = parseFloat(color[1]) / 360;
                        var s = parseInt(color[2], 10) / 100;
                        var l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[5]);
                        return this.setHSL(h, s, l);
                    }
                    break;
                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                    return this;
                } else if (size === 6) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                    return this;
                }
            }
            if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                if (hex !== undefined) {
                    this.setHex(hex);
                } else {
                    console.warn("SZX3D.Color: Unknown color " + style);
                }
            }
            return this;
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        },
        copyGammaToLinear: function(color, gammaFactor) {
            if (gammaFactor === undefined) gammaFactor = 2;
            this.r = Math.pow(color.r, gammaFactor);
            this.g = Math.pow(color.g, gammaFactor);
            this.b = Math.pow(color.b, gammaFactor);
            return this;
        },
        copyLinearToGamma: function(color, gammaFactor) {
            if (gammaFactor === undefined) gammaFactor = 2;
            var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
            this.r = Math.pow(color.r, safeInverse);
            this.g = Math.pow(color.g, safeInverse);
            this.b = Math.pow(color.b, safeInverse);
            return this;
        },
        convertGammaToLinear: function() {
            var r = this.r, g = this.g, b = this.b;
            this.r = r * r;
            this.g = g * g;
            this.b = b * b;
            return this;
        },
        convertLinearToGamma: function() {
            this.r = Math.sqrt(this.r);
            this.g = Math.sqrt(this.g);
            this.b = Math.sqrt(this.b);
            return this;
        },
        getHex: function() {
            return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function(optionalTarget) {
            var hsl = optionalTarget || {
                h: 0,
                s: 0,
                l: 0
            };
            var r = this.r, g = this.g, b = this.b;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var hue, saturation;
            var lightness = (min + max) / 2;
            if (min === max) {
                hue = 0;
                saturation = 0;
            } else {
                var delta = max - min;
                saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                  case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;

                  case g:
                    hue = (b - r) / delta + 2;
                    break;

                  case b:
                    hue = (r - g) / delta + 4;
                    break;
                }
                hue /= 6;
            }
            hsl.h = hue;
            hsl.s = saturation;
            hsl.l = lightness;
            return hsl;
        },
        getStyle: function() {
            return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
        },
        offsetHSL: function(h, s, l) {
            var hsl = this.getHSL();
            hsl.h += h;
            hsl.s += s;
            hsl.l += l;
            this.setHSL(hsl.h, hsl.s, hsl.l);
            return this;
        },
        add: function(color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        },
        addColors: function(color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        },
        addScalar: function(s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        },
        sub: function(color) {
            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);
            return this;
        },
        multiply: function(color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        },
        multiplyScalar: function(s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        },
        lerp: function(color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        },
        equals: function(c) {
            return c.r === this.r && c.g === this.g && c.b === this.b;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        },
        toJSON: function() {
            return this.getHex();
        }
    };
    var ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function Vector2(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    Vector2.prototype = {
        constructor: Vector2,
        isVector2: true,
        get width() {
            return this.x;
        },
        set width(value) {
            this.x = value;
        },
        get height() {
            return this.y;
        },
        set height(value) {
            this.y = value;
        },
        set: function(x, y) {
            this.x = x;
            this.y = y;
            return this;
        },
        setScalar: function(scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        },
        setX: function(x) {
            this.x = x;
            return this;
        },
        setY: function(y) {
            this.y = y;
            return this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y);
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        },
        add: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            return this;
        },
        addScalar: function(s) {
            this.x += s;
            this.y += s;
            return this;
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        },
        addScaledVector: function(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        },
        sub: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            return this;
        },
        subScalar: function(s) {
            this.x -= s;
            this.y -= s;
            return this;
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        },
        multiply: function(v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        },
        multiplyScalar: function(scalar) {
            if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
            } else {
                this.x = 0;
                this.y = 0;
            }
            return this;
        },
        divide: function(v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        },
        max: function(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        },
        clamp: function(min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            return this;
        },
        clampScalar: function() {
            var min, max;
            return function clampScalar(minVal, maxVal) {
                if (min === undefined) {
                    min = new Vector2();
                    max = new Vector2();
                }
                min.set(minVal, minVal);
                max.set(maxVal, maxVal);
                return this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        roundToZero: function() {
            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            return this;
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function() {
            return this.divideScalar(this.length());
        },
        angle: function() {
            var angle = Math.atan2(this.y, this.x);
            if (angle < 0) angle += 2 * Math.PI;
            return angle;
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        },
        distanceToManhattan: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },
        setLength: function(length) {
            return this.multiplyScalar(length / this.length());
        },
        lerp: function(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn("SZX3D.Vector2: offset has been removed from .fromBufferAttribute().");
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            return this;
        },
        rotateAround: function(center, angle) {
            var c = Math.cos(angle), s = Math.sin(angle);
            var x = this.x - center.x;
            var y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        }
    };
    function Vector4(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w !== undefined ? w : 1;
    }
    Vector4.prototype = {
        constructor: Vector4,
        isVector4: true,
        set: function(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        },
        setScalar: function(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        },
        setX: function(x) {
            this.x = x;
            return this;
        },
        setY: function(y) {
            this.y = y;
            return this;
        },
        setZ: function(z) {
            this.z = z;
            return this;
        },
        setW: function(w) {
            this.w = w;
            return this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              case 3:
                this.w = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              case 3:
                return this.w;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w !== undefined ? v.w : 1;
            return this;
        },
        add: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        },
        addScalar: function(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        },
        addScaledVector: function(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        },
        sub: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        },
        subScalar: function(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        },
        multiplyScalar: function(scalar) {
            if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
            } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
            }
            return this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        setAxisAngleFromQuaternion: function(q) {
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            if (s < 1e-4) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        },
        setAxisAngleFromRotationMatrix: function(m) {
            var angle, x, y, z, epsilon = .01, epsilon2 = .1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                    this.set(1, 0, 0, 0);
                    return this;
                }
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if (xx > yy && xx > zz) {
                    if (xx < epsilon) {
                        x = 0;
                        y = .707106781;
                        z = .707106781;
                    } else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                } else if (yy > zz) {
                    if (yy < epsilon) {
                        x = .707106781;
                        y = 0;
                        z = .707106781;
                    } else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                } else {
                    if (zz < epsilon) {
                        x = .707106781;
                        y = .707106781;
                        z = 0;
                    } else {
                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this;
            }
            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
            if (Math.abs(s) < .001) s = 1;
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        },
        min: function(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
            return this;
        },
        max: function(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
            return this;
        },
        clamp: function(min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            this.w = Math.max(min.w, Math.min(max.w, this.w));
            return this;
        },
        clampScalar: function() {
            var min, max;
            return function clampScalar(minVal, maxVal) {
                if (min === undefined) {
                    min = new Vector4();
                    max = new Vector4();
                }
                min.set(minVal, minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            };
        }(),
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
        },
        roundToZero: function() {
            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
            return this;
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function() {
            return this.divideScalar(this.length());
        },
        setLength: function(length) {
            return this.multiplyScalar(length / this.length());
        },
        lerp: function(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn("SZX3D.Vector4: offset has been removed from .fromBufferAttribute().");
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);
            return this;
        }
    };
    function Quaternion(x, y, z, w) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = w !== undefined ? w : 1;
    }
    Quaternion.prototype = {
        constructor: Quaternion,
        get x() {
            return this._x;
        },
        set x(value) {
            this._x = value;
            this.onChangeCallback();
        },
        get y() {
            return this._y;
        },
        set y(value) {
            this._y = value;
            this.onChangeCallback();
        },
        get z() {
            return this._z;
        },
        set z(value) {
            this._z = value;
            this.onChangeCallback();
        },
        get w() {
            return this._w;
        },
        set w(value) {
            this._w = value;
            this.onChangeCallback();
        },
        set: function(x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this.onChangeCallback();
            return this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function(quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this.onChangeCallback();
            return this;
        },
        setFromEuler: function(euler, update) {
            if ((euler && euler.isEuler) === false) {
                throw new Error("SZX3D.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            }
            var c1 = Math.cos(euler._x / 2);
            var c2 = Math.cos(euler._y / 2);
            var c3 = Math.cos(euler._z / 2);
            var s1 = Math.sin(euler._x / 2);
            var s2 = Math.sin(euler._y / 2);
            var s3 = Math.sin(euler._z / 2);
            var order = euler.order;
            if (order === "XYZ") {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === "YXZ") {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === "ZXY") {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === "ZYX") {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === "YZX") {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === "XZY") {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            if (update !== false) this.onChangeCallback();
            return this;
        },
        setFromAxisAngle: function(axis, angle) {
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this.onChangeCallback();
            return this;
        },
        setFromRotationMatrix: function(m) {
            var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
            if (trace > 0) {
                s = .5 / Math.sqrt(trace + 1);
                this._w = .25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            } else if (m11 > m22 && m11 > m33) {
                s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = .25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            } else if (m22 > m33) {
                s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = .25 * s;
                this._z = (m23 + m32) / s;
            } else {
                s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = .25 * s;
            }
            this.onChangeCallback();
            return this;
        },
        setFromUnitVectors: function() {
            var v1, r;
            var EPS = 1e-6;
            return function setFromUnitVectors(vFrom, vTo) {
                if (v1 === undefined) v1 = new Vector3();
                r = vFrom.dot(vTo) + 1;
                if (r < EPS) {
                    r = 0;
                    if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                        v1.set(-vFrom.y, vFrom.x, 0);
                    } else {
                        v1.set(0, -vFrom.z, vFrom.y);
                    }
                } else {
                    v1.crossVectors(vFrom, vTo);
                }
                this._x = v1.x;
                this._y = v1.y;
                this._z = v1.z;
                this._w = r;
                return this.normalize();
            };
        }(),
        inverse: function() {
            return this.conjugate().normalize();
        },
        conjugate: function() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this;
        },
        dot: function(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function() {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this.onChangeCallback();
            return this;
        },
        multiply: function(q, p) {
            if (p !== undefined) {
                console.warn("SZX3D.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
                return this.multiplyQuaternions(q, p);
            }
            return this.multiplyQuaternions(this, q);
        },
        premultiply: function(q) {
            return this.multiplyQuaternions(q, this);
        },
        multiplyQuaternions: function(a, b) {
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this.onChangeCallback();
            return this;
        },
        slerp: function(qb, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w;
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            } else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < .001) {
                this._w = .5 * (w + this._w);
                this._x = .5 * (x + this._x);
                this._y = .5 * (y + this._y);
                this._z = .5 * (z + this._z);
                return this;
            }
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = w * ratioA + this._w * ratioB;
            this._x = x * ratioA + this._x * ratioB;
            this._y = y * ratioA + this._y * ratioB;
            this._z = z * ratioA + this._z * ratioB;
            this.onChangeCallback();
            return this;
        },
        equals: function(quaternion) {
            return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this.onChangeCallback();
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        },
        onChange: function(callback) {
            this.onChangeCallback = callback;
            return this;
        },
        onChangeCallback: function() {}
    };
    Object.assign(Quaternion, {
        slerp: function(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        },
        slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                if (s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        }
    });
    function Vector3(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }
    Vector3.prototype = {
        constructor: Vector3,
        isVector3: true,
        set: function(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        },
        setScalar: function(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        },
        setX: function(x) {
            this.x = x;
            return this;
        },
        setY: function(y) {
            this.y = y;
            return this;
        },
        setZ: function(z) {
            this.z = z;
            return this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        },
        add: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        },
        addScalar: function(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        },
        addScaledVector: function(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        },
        sub: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        },
        subScalar: function(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        },
        multiply: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
                return this.multiplyVectors(v, w);
            }
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        },
        multiplyScalar: function(scalar) {
            if (isFinite(scalar)) {
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
            } else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            return this;
        },
        multiplyVectors: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        },
        applyEuler: function() {
            var quaternion;
            return function applyEuler(euler) {
                if ((euler && euler.isEuler) === false) {
                    console.error("SZX3D.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
                }
                if (quaternion === undefined) quaternion = new Quaternion();
                return this.applyQuaternion(quaternion.setFromEuler(euler));
            };
        }(),
        applyAxisAngle: function() {
            var quaternion;
            return function applyAxisAngle(axis, angle) {
                if (quaternion === undefined) quaternion = new Quaternion();
                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            };
        }(),
        applyMatrix3: function(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
            var w = e[3] * x + e[7] * y + e[11] * z + e[15];
            return this.divideScalar(w);
        },
        applyQuaternion: function(q) {
            var x = this.x, y = this.y, z = this.z;
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        },
        project: function() {
            var matrix;
            return function project(camera) {
                if (matrix === undefined) matrix = new Matrix4();
                matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                return this.applyMatrix4(matrix);
            };
        }(),
        unproject: function() {
            var matrix;
            return function unproject(camera) {
                if (matrix === undefined) matrix = new Matrix4();
                matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                return this.applyMatrix4(matrix);
            };
        }(),
        transformDirection: function(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        },
        divide: function(v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        },
        max: function(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        },
        clamp: function(min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            return this;
        },
        clampScalar: function() {
            var min, max;
            return function clampScalar(minVal, maxVal) {
                if (min === undefined) {
                    min = new Vector3();
                    max = new Vector3();
                }
                min.set(minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        },
        roundToZero: function() {
            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function() {
            return this.divideScalar(this.length());
        },
        setLength: function(length) {
            return this.multiplyScalar(length / this.length());
        },
        lerp: function(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        cross: function(v, w) {
            if (w !== undefined) {
                console.warn("SZX3D.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
                return this.crossVectors(v, w);
            }
            var x = this.x, y = this.y, z = this.z;
            this.x = y * v.z - z * v.y;
            this.y = z * v.x - x * v.z;
            this.z = x * v.y - y * v.x;
            return this;
        },
        crossVectors: function(a, b) {
            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        },
        projectOnVector: function(vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        },
        projectOnPlane: function() {
            var v1;
            return function projectOnPlane(planeNormal) {
                if (v1 === undefined) v1 = new Vector3();
                v1.copy(this).projectOnVector(planeNormal);
                return this.sub(v1);
            };
        }(),
        reflect: function() {
            var v1;
            return function reflect(normal) {
                if (v1 === undefined) v1 = new Vector3();
                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            };
        }(),
        angleTo: function(v) {
            var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
            return Math.acos(_Math.clamp(theta, -1, 1));
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        },
        distanceToManhattan: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },
        setFromSpherical: function(s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            this.x = sinPhiRadius * Math.sin(s.theta);
            this.y = Math.cos(s.phi) * s.radius;
            this.z = sinPhiRadius * Math.cos(s.theta);
            return this;
        },
        setFromCylindrical: function(c) {
            this.x = c.radius * Math.sin(c.theta);
            this.y = c.y;
            this.z = c.radius * Math.cos(c.theta);
            return this;
        },
        setFromMatrixPosition: function(m) {
            return this.setFromMatrixColumn(m, 3);
        },
        setFromMatrixScale: function(m) {
            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        },
        setFromMatrixColumn: function(m, index) {
            if (typeof m === "number") {
                console.warn("SZX3D.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                var temp = m;
                m = index;
                index = temp;
            }
            return this.fromArray(m.elements, index * 4);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn("SZX3D.Vector3: offset has been removed from .fromBufferAttribute().");
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            return this;
        }
    };
    function Matrix4() {
        this.elements = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);
        if (arguments.length > 0) {
            console.error("SZX3D.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
    }
    Matrix4.prototype = {
        constructor: Matrix4,
        isMatrix4: true,
        set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        },
        identity: function() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        clone: function() {
            return new Matrix4().fromArray(this.elements);
        },
        copy: function(m) {
            this.elements.set(m.elements);
            return this;
        },
        copyPosition: function(m) {
            var te = this.elements;
            var me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        },
        extractBasis: function(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        },
        makeBasis: function(xAxis, yAxis, zAxis) {
            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
            return this;
        },
        extractRotation: function() {
            var v1;
            return function extractRotation(m) {
                if (v1 === undefined) v1 = new Vector3();
                var te = this.elements;
                var me = m.elements;
                var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;
                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;
                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;
                return this;
            };
        }(),
        makeRotationFromEuler: function(euler) {
            if ((euler && euler.isEuler) === false) {
                console.error("SZX3D.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            }
            var te = this.elements;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = Math.cos(x), b = Math.sin(x);
            var c = Math.cos(y), d = Math.sin(y);
            var e = Math.cos(z), f = Math.sin(z);
            if (euler.order === "XYZ") {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            } else if (euler.order === "YXZ") {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            } else if (euler.order === "ZXY") {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            } else if (euler.order === "ZYX") {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            } else if (euler.order === "YZX") {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            } else if (euler.order === "XZY") {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        },
        makeRotationFromQuaternion: function(q) {
            var te = this.elements;
            var x = q.x, y = q.y, z = q.z, w = q.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            te[0] = 1 - (yy + zz);
            te[4] = xy - wz;
            te[8] = xz + wy;
            te[1] = xy + wz;
            te[5] = 1 - (xx + zz);
            te[9] = yz - wx;
            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - (xx + yy);
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        },
        lookAt: function() {
            var x, y, z;
            return function lookAt(eye, target, up) {
                if (x === undefined) {
                    x = new Vector3();
                    y = new Vector3();
                    z = new Vector3();
                }
                var te = this.elements;
                z.subVectors(eye, target).normalize();
                if (z.lengthSq() === 0) {
                    z.z = 1;
                }
                x.crossVectors(up, z).normalize();
                if (x.lengthSq() === 0) {
                    z.z += 1e-4;
                    x.crossVectors(up, z).normalize();
                }
                y.crossVectors(z, x);
                te[0] = x.x;
                te[4] = y.x;
                te[8] = z.x;
                te[1] = x.y;
                te[5] = y.y;
                te[9] = z.y;
                te[2] = x.z;
                te[6] = y.z;
                te[10] = z.z;
                return this;
            };
        }(),
        multiply: function(m, n) {
            if (n !== undefined) {
                console.warn("SZX3D.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
                return this.multiplyMatrices(m, n);
            }
            return this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        },
        multiplyToArray: function(a, b, r) {
            var te = this.elements;
            this.multiplyMatrices(a, b);
            r[0] = te[0];
            r[1] = te[1];
            r[2] = te[2];
            r[3] = te[3];
            r[4] = te[4];
            r[5] = te[5];
            r[6] = te[6];
            r[7] = te[7];
            r[8] = te[8];
            r[9] = te[9];
            r[10] = te[10];
            r[11] = te[11];
            r[12] = te[12];
            r[13] = te[13];
            r[14] = te[14];
            r[15] = te[15];
            return this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        },
        applyToBufferAttribute: function() {
            var v1;
            return function applyToBufferAttribute(attribute) {
                if (v1 === undefined) v1 = new Vector3();
                for (var i = 0, l = attribute.count; i < l; i++) {
                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);
                    v1.applyMatrix4(this);
                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }
                return attribute;
            };
        }(),
        determinant: function() {
            var te = this.elements;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        },
        transpose: function() {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        },
        setPosition: function(v) {
            var te = this.elements;
            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;
            return this;
        },
        getInverse: function(m, throwOnDegenerate) {
            var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) {
                var msg = "SZX3D.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                } else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        },
        scale: function(v) {
            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        },
        getMaxScaleOnAxis: function() {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },
        makeTranslation: function(x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        },
        makeRotationX: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationY: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationZ: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationAxis: function(axis, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        },
        makeScale: function(x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        },
        makeShear: function(x, y, z) {
            this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
            return this;
        },
        compose: function(position, quaternion, scale) {
            this.makeRotationFromQuaternion(quaternion);
            this.scale(scale);
            this.setPosition(position);
            return this;
        },
        decompose: function() {
            var vector, matrix;
            return function decompose(position, quaternion, scale) {
                if (vector === undefined) {
                    vector = new Vector3();
                    matrix = new Matrix4();
                }
                var te = this.elements;
                var sx = vector.set(te[0], te[1], te[2]).length();
                var sy = vector.set(te[4], te[5], te[6]).length();
                var sz = vector.set(te[8], te[9], te[10]).length();
                var det = this.determinant();
                if (det < 0) {
                    sx = -sx;
                }
                position.x = te[12];
                position.y = te[13];
                position.z = te[14];
                matrix.elements.set(this.elements);
                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;
                matrix.elements[0] *= invSX;
                matrix.elements[1] *= invSX;
                matrix.elements[2] *= invSX;
                matrix.elements[4] *= invSY;
                matrix.elements[5] *= invSY;
                matrix.elements[6] *= invSY;
                matrix.elements[8] *= invSZ;
                matrix.elements[9] *= invSZ;
                matrix.elements[10] *= invSZ;
                quaternion.setFromRotationMatrix(matrix);
                scale.x = sx;
                scale.y = sy;
                scale.z = sz;
                return this;
            };
        }(),
        makePerspective: function(left, right, top, bottom, near, far) {
            if (far === undefined) {
                console.warn("SZX3D.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            }
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        },
        makeOrthographic: function(left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = 1 / (right - left);
            var h = 1 / (top - bottom);
            var p = 1 / (far - near);
            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;
            te[0] = 2 * w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 * h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 * p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        },
        equals: function(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i]) return false;
            }
            return true;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            for (var i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        }
    };
    function Matrix3() {
        this.elements = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
        if (arguments.length > 0) {
            console.error("SZX3D.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
    }
    Matrix3.prototype = {
        constructor: Matrix3,
        isMatrix3: true,
        set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[1] = n21;
            te[2] = n31;
            te[3] = n12;
            te[4] = n22;
            te[5] = n32;
            te[6] = n13;
            te[7] = n23;
            te[8] = n33;
            return this;
        },
        identity: function() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        },
        clone: function() {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function(m) {
            var me = m.elements;
            this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
            return this;
        },
        setFromMatrix4: function(m) {
            var me = m.elements;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            return this;
        },
        applyToBufferAttribute: function() {
            var v1;
            return function applyToBufferAttribute(attribute) {
                if (v1 === undefined) v1 = new Vector3();
                for (var i = 0, l = attribute.count; i < l; i++) {
                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);
                    v1.applyMatrix3(this);
                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }
                return attribute;
            };
        }(),
        multiplyScalar: function(s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        },
        determinant: function() {
            var te = this.elements;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },
        getInverse: function(matrix, throwOnDegenerate) {
            if (matrix && matrix.isMatrix4) {
                console.error("SZX3D.Matrix3.getInverse no longer takes a Matrix4 argument.");
            }
            var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                var msg = "SZX3D.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                } else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        },
        transpose: function() {
            var tmp, m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        },
        getNormalMatrix: function(matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },
        transposeIntoArray: function(r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            for (var i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        }
    };
    function Euler(x, y, z, order) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || Euler.DefaultOrder;
    }
    Euler.RotationOrders = [ "XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX" ];
    Euler.DefaultOrder = "XYZ";
    Euler.prototype = {
        constructor: Euler,
        isEuler: true,
        get x() {
            return this._x;
        },
        set x(value) {
            this._x = value;
            this.onChangeCallback();
        },
        get y() {
            return this._y;
        },
        set y(value) {
            this._y = value;
            this.onChangeCallback();
        },
        get z() {
            return this._z;
        },
        set z(value) {
            this._z = value;
            this.onChangeCallback();
        },
        get order() {
            return this._order;
        },
        set order(value) {
            this._order = value;
            this.onChangeCallback();
        },
        set: function(x, y, z, order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
            this.onChangeCallback();
            return this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function(euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this.onChangeCallback();
            return this;
        },
        setFromRotationMatrix: function(m, order, update) {
            var clamp = _Math.clamp;
            var te = m.elements;
            var m11 = te[0], m12 = te[4], m13 = te[8];
            var m21 = te[1], m22 = te[5], m23 = te[9];
            var m31 = te[2], m32 = te[6], m33 = te[10];
            order = order || this._order;
            if (order === "XYZ") {
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < .99999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
            } else if (order === "YXZ") {
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < .99999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
            } else if (order === "ZXY") {
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < .99999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
            } else if (order === "ZYX") {
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < .99999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
            } else if (order === "YZX") {
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < .99999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
            } else if (order === "XZY") {
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < .99999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
            } else {
                console.warn("SZX3D.Euler: .setFromRotationMatrix() given unsupported order: " + order);
            }
            this._order = order;
            if (update !== false) this.onChangeCallback();
            return this;
        },
        setFromQuaternion: function() {
            var matrix;
            return function setFromQuaternion(q, order, update) {
                if (matrix === undefined) matrix = new Matrix4();
                matrix.makeRotationFromQuaternion(q);
                return this.setFromRotationMatrix(matrix, order, update);
            };
        }(),
        setFromVector3: function(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        },
        reorder: function() {
            var q = new Quaternion();
            return function reorder(newOrder) {
                q.setFromEuler(this);
                return this.setFromQuaternion(q, newOrder);
            };
        }(),
        equals: function(euler) {
            return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        },
        fromArray: function(array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined) this._order = array[3];
            this.onChangeCallback();
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        },
        toVector3: function(optionalResult) {
            if (optionalResult) {
                return optionalResult.set(this._x, this._y, this._z);
            } else {
                return new Vector3(this._x, this._y, this._z);
            }
        },
        onChange: function(callback) {
            this.onChangeCallback = callback;
            return this;
        },
        onChangeCallback: function() {}
    };
    function Line3(start, end) {
        this.start = start !== undefined ? start : new Vector3();
        this.end = end !== undefined ? end : new Vector3();
    }
    Line3.prototype = {
        constructor: Line3,
        set: function(start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.addVectors(this.start, this.end).multiplyScalar(.5);
        },
        delta: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.subVectors(this.end, this.start);
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end);
        },
        distance: function() {
            return this.start.distanceTo(this.end);
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: function() {
            var startP = new Vector3();
            var startEnd = new Vector3();
            return function closestPointToPointParameter(point, clampToLine) {
                startP.subVectors(point, this.start);
                startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd);
                var startEnd_startP = startEnd.dot(startP);
                var t = startEnd_startP / startEnd2;
                if (clampToLine) {
                    t = _Math.clamp(t, 0, 1);
                }
                return t;
            };
        }(),
        closestPointToPoint: function(point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        applyMatrix4: function(matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        },
        equals: function(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    };
    function Box2(min, max) {
        this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
        this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
    }
    Box2.prototype = {
        constructor: Box2,
        set: function(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector2();
            return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        },
        makeEmpty: function() {
            this.min.x = this.min.y = +Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        },
        expandByVector: function(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        },
        expandByScalar: function(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        },
        containsPoint: function(point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },
        getParameter: function(point, optionalTarget) {
            var result = optionalTarget || new Vector2();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function(box) {
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        },
        clampPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector2();
            return result.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector2();
            return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),
        intersect: function(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            return this;
        },
        union: function(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        },
        translate: function(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    };
    function Box3(min, max) {
        this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
        this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    Box3.prototype = {
        constructor: Box3,
        isBox3: true,
        set: function(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        },
        setFromArray: function(array) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        },
        setFromBufferAttribute: function(attribute) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = attribute.count; i < l; i++) {
                var x = attribute.getX(i);
                var y = attribute.getY(i);
                var z = attribute.getZ(i);
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector3();
            return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            };
        }(),
        setFromObject: function(object) {
            this.makeEmpty();
            return this.expandByObject(object);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        },
        makeEmpty: function() {
            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        },
        expandByVector: function(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        },
        expandByScalar: function(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        },
        expandByObject: function() {
            var v1 = new Vector3();
            return function expandByObject(object) {
                var scope = this;
                object.updateMatrixWorld(true);
                object.traverse(function(node) {
                    var i, l;
                    var geometry = node.geometry;
                    if (geometry !== undefined) {
                        if (geometry.isGeometry) {
                            var vertices = geometry.vertices;
                            for (i = 0, l = vertices.length; i < l; i++) {
                                v1.copy(vertices[i]);
                                v1.applyMatrix4(node.matrixWorld);
                                scope.expandByPoint(v1);
                            }
                        } else if (geometry.isBufferGeometry) {
                            var attribute = geometry.attributes.position;
                            if (attribute !== undefined) {
                                for (i = 0, l = attribute.count; i < l; i++) {
                                    v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                                    scope.expandByPoint(v1);
                                }
                            }
                        }
                    }
                });
                return this;
            };
        }(),
        containsPoint: function(point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },
        getParameter: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function(box) {
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        },
        intersectsSphere: function() {
            var closestPoint;
            return function intersectsSphere(sphere) {
                if (closestPoint === undefined) closestPoint = new Vector3();
                this.clampPoint(sphere.center, closestPoint);
                return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            };
        }(),
        intersectsPlane: function(plane) {
            var min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return min <= plane.constant && max >= plane.constant;
        },
        clampPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector3();
            return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),
        getBoundingSphere: function() {
            var v1 = new Vector3();
            return function getBoundingSphere(optionalTarget) {
                var result = optionalTarget || new Sphere();
                this.getCenter(result.center);
                result.radius = this.getSize(v1).length() * .5;
                return result;
            };
        }(),
        intersect: function(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            if (this.isEmpty()) this.makeEmpty();
            return this;
        },
        union: function(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        },
        applyMatrix4: function() {
            var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ];
            return function applyMatrix4(matrix) {
                if (this.isEmpty()) return this;
                points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
                points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
                points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
                points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
                this.setFromPoints(points);
                return this;
            };
        }(),
        translate: function(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    };
    function Sphere(center, radius) {
        this.center = center !== undefined ? center : new Vector3();
        this.radius = radius !== undefined ? radius : 0;
    }
    Sphere.prototype = {
        constructor: Sphere,
        set: function(center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        },
        setFromPoints: function() {
            var box;
            return function setFromPoints(points, optionalCenter) {
                if (box === undefined) box = new Box3();
                var center = this.center;
                if (optionalCenter !== undefined) {
                    center.copy(optionalCenter);
                } else {
                    box.setFromPoints(points).getCenter(center);
                }
                var maxRadiusSq = 0;
                for (var i = 0, il = points.length; i < il; i++) {
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }
                this.radius = Math.sqrt(maxRadiusSq);
                return this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        },
        empty: function() {
            return this.radius <= 0;
        },
        containsPoint: function(point) {
            return point.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function(point) {
            return point.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        },
        intersectsBox: function(box) {
            return box.intersectsSphere(this);
        },
        intersectsPlane: function(plane) {
            return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
        },
        clampPoint: function(point, optionalTarget) {
            var deltaLengthSq = this.center.distanceToSquared(point);
            var result = optionalTarget || new Vector3();
            result.copy(point);
            if (deltaLengthSq > this.radius * this.radius) {
                result.sub(this.center).normalize();
                result.multiplyScalar(this.radius).add(this.center);
            }
            return result;
        },
        getBoundingBox: function(optionalTarget) {
            var box = optionalTarget || new Box3();
            box.set(this.center, this.center);
            box.expandByScalar(this.radius);
            return box;
        },
        applyMatrix4: function(matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        },
        translate: function(offset) {
            this.center.add(offset);
            return this;
        },
        equals: function(sphere) {
            return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
    };
    function Ray(origin, direction) {
        this.origin = origin !== undefined ? origin : new Vector3();
        this.direction = direction !== undefined ? direction : new Vector3();
    }
    Ray.prototype = {
        constructor: Ray,
        set: function(origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.direction).multiplyScalar(t).add(this.origin);
        },
        lookAt: function(v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        },
        recast: function() {
            var v1 = new Vector3();
            return function recast(t) {
                this.origin.copy(this.at(t, v1));
                return this;
            };
        }(),
        closestPointToPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            if (directionDistance < 0) {
                return result.copy(this.origin);
            }
            return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },
        distanceToPoint: function(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        },
        distanceSqToPoint: function() {
            var v1 = new Vector3();
            return function distanceSqToPoint(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                if (directionDistance < 0) {
                    return this.origin.distanceToSquared(point);
                }
                v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                return v1.distanceToSquared(point);
            };
        }(),
        distanceSqToSegment: function() {
            var segCenter = new Vector3();
            var segDir = new Vector3();
            var diff = new Vector3();
            return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(.5);
                segDir.copy(v1).sub(v0).normalize();
                diff.copy(this.origin).sub(segCenter);
                var segExtent = v0.distanceTo(v1) * .5;
                var a01 = -this.direction.dot(segDir);
                var b0 = diff.dot(this.direction);
                var b1 = -diff.dot(segDir);
                var c = diff.lengthSq();
                var det = Math.abs(1 - a01 * a01);
                var s0, s1, sqrDist, extDet;
                if (det > 0) {
                    s0 = a01 * b1 - b0;
                    s1 = a01 * b0 - b1;
                    extDet = segExtent * det;
                    if (s0 >= 0) {
                        if (s1 >= -extDet) {
                            if (s1 <= extDet) {
                                var invDet = 1 / det;
                                s0 *= invDet;
                                s1 *= invDet;
                                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                            } else {
                                s1 = segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        } else {
                            s1 = -segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        if (s1 <= -extDet) {
                            s0 = Math.max(0, -(-a01 * segExtent + b0));
                            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        } else if (s1 <= extDet) {
                            s0 = 0;
                            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = s1 * (s1 + 2 * b1) + c;
                        } else {
                            s0 = Math.max(0, -(a01 * segExtent + b0));
                            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                } else {
                    s1 = a01 > 0 ? -segExtent : segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                if (optionalPointOnRay) {
                    optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                }
                if (optionalPointOnSegment) {
                    optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
                }
                return sqrDist;
            };
        }(),
        intersectSphere: function() {
            var v1 = new Vector3();
            return function intersectSphere(sphere, optionalTarget) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction);
                var d2 = v1.dot(v1) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2) return null;
                var thc = Math.sqrt(radius2 - d2);
                var t0 = tca - thc;
                var t1 = tca + thc;
                if (t0 < 0 && t1 < 0) return null;
                if (t0 < 0) return this.at(t1, optionalTarget);
                return this.at(t0, optionalTarget);
            };
        }(),
        intersectsSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },
        distanceToPlane: function(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                if (plane.distanceToPoint(this.origin) === 0) {
                    return 0;
                }
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        },
        intersectPlane: function(plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            if (t === null) {
                return null;
            }
            return this.at(t, optionalTarget);
        },
        intersectsPlane: function(plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) {
                return true;
            }
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) {
                return true;
            }
            return false;
        },
        intersectBox: function(box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if (tmin > tymax || tymin > tmax) return null;
            if (tymin > tmin || tmin !== tmin) tmin = tymin;
            if (tymax < tmax || tmax !== tmax) tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if (tmin > tzmax || tzmin > tmax) return null;
            if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
            if (tmax < 0) return null;
            return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
        },
        intersectsBox: function() {
            var v = new Vector3();
            return function intersectsBox(box) {
                return this.intersectBox(box, v) !== null;
            };
        }(),
        intersectTriangle: function() {
            var diff = new Vector3();
            var edge1 = new Vector3();
            var edge2 = new Vector3();
            var normal = new Vector3();
            return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
                edge1.subVectors(b, a);
                edge2.subVectors(c, a);
                normal.crossVectors(edge1, edge2);
                var DdN = this.direction.dot(normal);
                var sign;
                if (DdN > 0) {
                    if (backfaceCulling) return null;
                    sign = 1;
                } else if (DdN < 0) {
                    sign = -1;
                    DdN = -DdN;
                } else {
                    return null;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (DdQxE2 < 0) {
                    return null;
                }
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (DdE1xQ < 0) {
                    return null;
                }
                if (DdQxE2 + DdE1xQ > DdN) {
                    return null;
                }
                var QdN = -sign * diff.dot(normal);
                if (QdN < 0) {
                    return null;
                }
                return this.at(QdN / DdN, optionalTarget);
            };
        }(),
        applyMatrix4: function(matrix4) {
            this.direction.add(this.origin).applyMatrix4(matrix4);
            this.origin.applyMatrix4(matrix4);
            this.direction.sub(this.origin);
            this.direction.normalize();
            return this;
        },
        equals: function(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    };
    function Plane(normal, constant) {
        this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
        this.constant = constant !== undefined ? constant : 0;
    }
    Plane.prototype = {
        constructor: Plane,
        set: function(normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        },
        setComponents: function(x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        },
        setFromNormalAndCoplanarPoint: function(normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal);
            return this;
        },
        setFromCoplanarPoints: function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function setFromCoplanarPoints(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                this.setFromNormalAndCoplanarPoint(normal, a);
                return this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        },
        normalize: function() {
            var inverseNormalLength = 1 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        },
        negate: function() {
            this.constant *= -1;
            this.normal.negate();
            return this;
        },
        distanceToPoint: function(point) {
            return this.normal.dot(point) + this.constant;
        },
        distanceToSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        },
        projectPoint: function(point, optionalTarget) {
            return this.orthoPoint(point, optionalTarget).sub(point).negate();
        },
        orthoPoint: function(point, optionalTarget) {
            var perpendicularMagnitude = this.distanceToPoint(point);
            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
        },
        intersectLine: function() {
            var v1 = new Vector3();
            return function intersectLine(line, optionalTarget) {
                var result = optionalTarget || new Vector3();
                var direction = line.delta(v1);
                var denominator = this.normal.dot(direction);
                if (denominator === 0) {
                    if (this.distanceToPoint(line.start) === 0) {
                        return result.copy(line.start);
                    }
                    return undefined;
                }
                var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                if (t < 0 || t > 1) {
                    return undefined;
                }
                return result.copy(direction).multiplyScalar(t).add(line.start);
            };
        }(),
        intersectsLine: function(line) {
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        },
        intersectsBox: function(box) {
            return box.intersectsPlane(this);
        },
        intersectsSphere: function(sphere) {
            return sphere.intersectsPlane(this);
        },
        coplanarPoint: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function() {
            var v1 = new Vector3();
            var m1 = new Matrix3();
            return function applyMatrix4(matrix, optionalNormalMatrix) {
                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                this.constant = -referencePoint.dot(normal);
                return this;
            };
        }(),
        translate: function(offset) {
            this.constant = this.constant - offset.dot(this.normal);
            return this;
        },
        equals: function(plane) {
            return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
    };
    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [ p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane() ];
    }
    Frustum.prototype = {
        constructor: Frustum,
        set: function(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(frustum) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
            }
            return this;
        },
        setFromMatrix: function(m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        },
        intersectsObject: function() {
            var sphere = new Sphere();
            return function intersectsObject(object) {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                return this.intersectsSphere(sphere);
            };
        }(),
        intersectsSprite: function() {
            var sphere = new Sphere();
            return function intersectsSprite(sprite) {
                sphere.center.set(0, 0, 0);
                sphere.radius = .7071067811865476;
                sphere.applyMatrix4(sprite.matrixWorld);
                return this.intersectsSphere(sphere);
            };
        }(),
        intersectsSphere: function(sphere) {
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        },
        intersectsBox: function() {
            var p1 = new Vector3(), p2 = new Vector3();
            return function intersectsBox(box) {
                var planes = this.planes;
                for (var i = 0; i < 6; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1);
                    var d2 = plane.distanceToPoint(p2);
                    if (d1 < 0 && d2 < 0) {
                        return false;
                    }
                }
                return true;
            };
        }(),
        containsPoint: function(point) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                    return false;
                }
            }
            return true;
        }
    };
    function Spherical(radius, phi, theta) {
        this.radius = radius !== undefined ? radius : 1;
        this.phi = phi !== undefined ? phi : 0;
        this.theta = theta !== undefined ? theta : 0;
        return this;
    }
    Spherical.prototype = {
        constructor: Spherical,
        set: function(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        },
        makeSafe: function() {
            var EPS = 1e-6;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        },
        setFromVector3: function(vec3) {
            this.radius = vec3.length();
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            } else {
                this.theta = Math.atan2(vec3.x, vec3.z);
                this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1));
            }
            return this;
        }
    };
    function Cylindrical(radius, theta, y) {
        this.radius = radius !== undefined ? radius : 1;
        this.theta = theta !== undefined ? theta : 0;
        this.y = y !== undefined ? y : 0;
        return this;
    }
    Cylindrical.prototype = {
        constructor: Cylindrical,
        set: function(radius, theta, y) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
            return this;
        },
        setFromVector3: function(vec3) {
            this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
            this.theta = Math.atan2(vec3.x, vec3.z);
            this.y = vec3.y;
            return this;
        }
    };
    function Triangle(a, b, c) {
        this.a = a !== undefined ? a : new Vector3();
        this.b = b !== undefined ? b : new Vector3();
        this.c = c !== undefined ? c : new Vector3();
    }
    Triangle.normal = function() {
        var v0 = new Vector3();
        return function normal(a, b, c, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(c, b);
            v0.subVectors(a, b);
            result.cross(v0);
            var resultLengthSq = result.lengthSq();
            if (resultLengthSq > 0) {
                return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
            }
            return result.set(0, 0, 0);
        };
    }();
    Triangle.barycoordFromPoint = function() {
        var v0 = new Vector3();
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function barycoordFromPoint(point, a, b, c, optionalTarget) {
            v0.subVectors(c, a);
            v1.subVectors(b, a);
            v2.subVectors(point, a);
            var dot00 = v0.dot(v0);
            var dot01 = v0.dot(v1);
            var dot02 = v0.dot(v2);
            var dot11 = v1.dot(v1);
            var dot12 = v1.dot(v2);
            var denom = dot00 * dot11 - dot01 * dot01;
            var result = optionalTarget || new Vector3();
            if (denom === 0) {
                return result.set(-2, -1, -1);
            }
            var invDenom = 1 / denom;
            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
            return result.set(1 - u - v, v, u);
        };
    }();
    Triangle.containsPoint = function() {
        var v1 = new Vector3();
        return function containsPoint(point, a, b, c) {
            var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
            return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
        };
    }();
    Triangle.prototype = {
        constructor: Triangle,
        set: function(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        },
        setFromPointsAndIndices: function(points, i0, i1, i2) {
            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        },
        area: function() {
            var v0 = new Vector3();
            var v1 = new Vector3();
            return function area() {
                v0.subVectors(this.c, this.b);
                v1.subVectors(this.a, this.b);
                return v0.cross(v1).length() * .5;
            };
        }(),
        midpoint: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        normal: function(optionalTarget) {
            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        },
        plane: function(optionalTarget) {
            var result = optionalTarget || new Plane();
            return result.setFromCoplanarPoints(this.a, this.b, this.c);
        },
        barycoordFromPoint: function(point, optionalTarget) {
            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        },
        containsPoint: function(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },
        closestPointToPoint: function() {
            var plane, edgeList, projectedPoint, closestPoint;
            return function closestPointToPoint(point, optionalTarget) {
                if (plane === undefined) {
                    plane = new Plane();
                    edgeList = [ new Line3(), new Line3(), new Line3() ];
                    projectedPoint = new Vector3();
                    closestPoint = new Vector3();
                }
                var result = optionalTarget || new Vector3();
                var minDistance = Infinity;
                plane.setFromCoplanarPoints(this.a, this.b, this.c);
                plane.projectPoint(point, projectedPoint);
                if (this.containsPoint(projectedPoint) === true) {
                    result.copy(projectedPoint);
                } else {
                    edgeList[0].set(this.a, this.b);
                    edgeList[1].set(this.b, this.c);
                    edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        if (distance < minDistance) {
                            minDistance = distance;
                            result.copy(closestPoint);
                        }
                    }
                }
                return result;
            };
        }(),
        equals: function(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    };
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }
    Interpolant.prototype = {
        constructor: Interpolant,
        evaluate: function(t) {
            var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2; ;) {
                                if (t1 === undefined) {
                                    if (t < t0) break forward_scan;
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt) break;
                                t0 = t1;
                                t1 = pp[++i1];
                                if (t < t1) {
                                    break seek;
                                }
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                        if (!(t >= t0)) {
                            var t1global = pp[1];
                            if (t < t1global) {
                                i1 = 2;
                                t0 = t1global;
                            }
                            for (var giveUpAt = i1 - 2; ;) {
                                if (t0 === undefined) {
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (i1 === giveUpAt) break;
                                t1 = t0;
                                t0 = pp[--i1 - 1];
                                if (t >= t0) {
                                    break seek;
                                }
                            }
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }
                        break validate_interval;
                    }
                    while (i1 < right) {
                        var mid = i1 + right >>> 1;
                        if (t < pp[mid]) {
                            right = mid;
                        } else {
                            i1 = mid + 1;
                        }
                    }
                    t1 = pp[i1];
                    t0 = pp[i1 - 1];
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (t1 === undefined) {
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);
                    }
                }
                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function(index) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
            }
            return result;
        },
        interpolate_: function(i1, t0, t, t1) {
            throw new Error("call to abstract method");
        },
        intervalChanged_: function(i1, t0, t1) {}
    };
    Object.assign(Interpolant.prototype, {
        beforeStart_: Interpolant.prototype.copySampleValue_,
        afterEnd_: Interpolant.prototype.copySampleValue_
    });
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }
    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function(i1, t0, t1) {
            var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                  case ZeroSlopeEnding:
                    iPrev = i1;
                    tPrev = 2 * t0 - t1;
                    break;

                  case WrapAroundEnding:
                    iPrev = pp.length - 2;
                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;

                  default:
                    iPrev = i1;
                    tPrev = t1;
                }
            }
            if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                  case ZeroSlopeEnding:
                    iNext = i1;
                    tNext = 2 * t1 - t0;
                    break;

                  case WrapAroundEnding:
                    iNext = 1;
                    tNext = t1 + pp[1] - pp[0];
                    break;

                  default:
                    iNext = i1 - 1;
                    tNext = t0;
                }
            }
            var halfDt = (t1 - t0) * .5, stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        },
        interpolate_: function(i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p;
            var sN = wN * ppp - wN * pp;
            for (var i = 0; i !== stride; ++i) {
                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
            }
            return result;
        }
    });
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            return this.copySampleValue_(i1 - 1);
        }
    });
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
            }
            return result;
        }
    });
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
            for (var end = offset + stride; offset !== end; offset += 4) {
                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }
            return result;
        }
    });
    function Clock(autoStart) {
        this.autoStart = autoStart !== undefined ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    Clock.prototype = {
        constructor: Clock,
        start: function() {
            this.startTime = (performance || Date).now();
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        },
        stop: function() {
            this.getElapsedTime();
            this.running = false;
        },
        getElapsedTime: function() {
            this.getDelta();
            return this.elapsedTime;
        },
        getDelta: function() {
            var diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
            }
            if (this.running) {
                var newTime = (performance || Date).now();
                diff = (newTime - this.oldTime) / 1e3;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        }
    };
    function EventDispatcher() {}
    EventDispatcher.prototype = {
        addEventListener: function(type, listener) {
            if (this._listeners === undefined) this._listeners = {};
            var listeners = this._listeners;
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        },
        hasEventListener: function(type, listener) {
            if (this._listeners === undefined) return false;
            var listeners = this._listeners;
            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        },
        removeEventListener: function(type, listener) {
            if (this._listeners === undefined) return;
            var listeners = this._listeners;
            var listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                var index = listenerArray.indexOf(listener);
                if (index !== -1) {
                    listenerArray.splice(index, 1);
                }
            }
        },
        dispatchEvent: function(event) {
            if (this._listeners === undefined) return;
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                var array = [], i = 0;
                var length = listenerArray.length;
                for (i = 0; i < length; i++) {
                    array[i] = listenerArray[i];
                }
                for (i = 0; i < length; i++) {
                    array[i].call(this, event);
                }
            }
        }
    };
    function Layers() {
        this.mask = 1;
    }
    Layers.prototype = {
        constructor: Layers,
        set: function(channel) {
            this.mask = 1 << channel;
        },
        enable: function(channel) {
            this.mask |= 1 << channel;
        },
        toggle: function(channel) {
            this.mask ^= 1 << channel;
        },
        disable: function(channel) {
            this.mask &= ~(1 << channel);
        },
        test: function(layers) {
            return (this.mask & layers.mask) !== 0;
        }
    };
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    console.warn("SZX3D.Raycaster: params.PointCloud has been renamed to params.Points.");
                    return this.Points;
                }
            }
        });
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false) return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
            }
        }
    }
    Raycaster.prototype = {
        constructor: Raycaster,
        linePrecision: 1,
        set: function(origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
            if (camera && camera.isPerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize();
            } else if (camera && camera.isOrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            } else {
                console.error("SZX3D.Raycaster: Unsupported camera type.");
            }
        },
        intersectObject: function(object, recursive) {
            var intersects = [];
            intersectObject(object, this, intersects, recursive);
            intersects.sort(ascSort);
            return intersects;
        },
        intersectObjects: function(objects, recursive) {
            var intersects = [];
            if (Array.isArray(objects) === false) {
                console.warn("SZX3D.Raycaster.intersectObjects: objects is not an Array.");
                return intersects;
            }
            for (var i = 0, l = objects.length; i < l; i++) {
                intersectObject(objects[i], this, intersects, recursive);
            }
            intersects.sort(ascSort);
            return intersects;
        }
    };
    var object3DId = 0;
    function Object3D() {
        Object.defineProperty(this, "id", {
            value: object3DId++
        });
        this.uuid = _Math.generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation.onChange(onRotationChange);
        quaternion.onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                enumerable: true,
                value: position
            },
            rotation: {
                enumerable: true,
                value: rotation
            },
            quaternion: {
                enumerable: true,
                value: quaternion
            },
            scale: {
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.userData = {};
        this.onBeforeRender = function() {};
        this.onAfterRender = function() {};
    }
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype = {
        constructor: Object3D,
        isObject3D: true,
        applyMatrix: function(matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        setRotationFromAxisAngle: function(axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function(euler) {
            this.quaternion.setFromEuler(euler, true);
        },
        setRotationFromMatrix: function(m) {
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function(q) {
            this.quaternion.copy(q);
        },
        rotateOnAxis: function() {
            var q1 = new Quaternion();
            return function rotateOnAxis(axis, angle) {
                q1.setFromAxisAngle(axis, angle);
                this.quaternion.multiply(q1);
                return this;
            };
        }(),
        rotateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function rotateX(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function rotateY(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function rotateZ(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        translateOnAxis: function() {
            var v1 = new Vector3();
            return function translateOnAxis(axis, distance) {
                v1.copy(axis).applyQuaternion(this.quaternion);
                this.position.add(v1.multiplyScalar(distance));
                return this;
            };
        }(),
        translateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function translateX(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function translateY(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function translateZ(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        localToWorld: function(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function() {
            var m1 = new Matrix4();
            return function worldToLocal(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
        }(),
        lookAt: function() {
            var m1 = new Matrix4();
            return function lookAt(vector) {
                m1.lookAt(vector, this.position, this.up);
                this.quaternion.setFromRotationMatrix(m1);
            };
        }(),
        add: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (object === this) {
                console.error("SZX3D.Object3D.add: object can't be added as a child of itself.", object);
                return this;
            }
            if (object && object.isObject3D) {
                if (object.parent !== null) {
                    object.parent.remove(object);
                }
                object.parent = this;
                object.dispatchEvent({
                    type: "added"
                });
                this.children.push(object);
            } else {
                console.error("SZX3D.Object3D.add: object not an instance of SZX3D.Object3D.", object);
            }
            return this;
        },
        remove: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.remove(arguments[i]);
                }
            }
            var index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                object.dispatchEvent({
                    type: "removed"
                });
                this.children.splice(index, 1);
            }
        },
        getObjectById: function(id) {
            return this.getObjectByProperty("id", id);
        },
        getObjectByName: function(name) {
            return this.getObjectByProperty("name", name);
        },
        getObjectByProperty: function(name, value) {
            if (this[name] === value) return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                    return object;
                }
            }
            return undefined;
        },
        getWorldPosition: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            this.updateMatrixWorld(true);
            return result.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function() {
            var position = new Vector3();
            var scale = new Vector3();
            return function getWorldQuaternion(optionalTarget) {
                var result = optionalTarget || new Quaternion();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, result, scale);
                return result;
            };
        }(),
        getWorldRotation: function() {
            var quaternion = new Quaternion();
            return function getWorldRotation(optionalTarget) {
                var result = optionalTarget || new Euler();
                this.getWorldQuaternion(quaternion);
                return result.setFromQuaternion(quaternion, this.rotation.order, false);
            };
        }(),
        getWorldScale: function() {
            var position = new Vector3();
            var quaternion = new Quaternion();
            return function getWorldScale(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, quaternion, result);
                return result;
            };
        }(),
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function getWorldDirection(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.getWorldQuaternion(quaternion);
                return result.set(0, 0, 1).applyQuaternion(quaternion);
            };
        }(),
        raycast: function() {},
        traverse: function(callback) {
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
            }
        },
        traverseVisible: function(callback) {
            if (this.visible === false) return;
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
            }
        },
        traverseAncestors: function(callback) {
            var parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        },
        updateMatrixWorld: function(force) {
            if (this.matrixAutoUpdate === true) this.updateMatrix();
            if (this.matrixWorldNeedsUpdate === true || force === true) {
                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                } else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
            }
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateMatrixWorld(force);
            }
        },
        toJSON: function(meta) {
            var isRootObject = meta === undefined || meta === "";
            var output = {};
            if (isRootObject) {
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                };
                output.metadata = {
                    version: 4.4,
                    type: "Object",
                    generator: "Object3D.toJSON"
                };
            }
            var object = {};
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== "") object.name = this.name;
            if (typeof this.userData === "object") {
                object.userData = {};
                for (var key in this.userData) {
                    if (this.userData[key] instanceof Object3D) {
                        object.userData[key] = this.userData[key].uuid;
                    } else {
                        object.userData[key] = this.userData[key];
                    }
                }
            } else {
                object.userData = this.userData;
            }
            if (this.castShadow === true) object.castShadow = true;
            if (this.receiveShadow === true) object.receiveShadow = true;
            if (this.visible === false) object.visible = false;
            object.matrix = this.matrix.toArray();
            if (this.geometry !== undefined) {
                if (meta.geometries[this.geometry.uuid] === undefined) {
                    meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
                }
                object.geometry = this.geometry.uuid;
            }
            if (this.material !== undefined) {
                if (meta.materials[this.material.uuid] === undefined) {
                    meta.materials[this.material.uuid] = this.material.toJSON(meta);
                }
                object.material = this.material.uuid;
            }
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) {
                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (geometries.length > 0) output.geometries = geometries;
                if (materials.length > 0) output.materials = materials;
                if (textures.length > 0) output.textures = textures;
                if (images.length > 0) output.images = images;
            }
            output.object = object;
            return output;
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        },
        clone: function(recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function(source, recursive) {
            if (recursive === undefined) recursive = true;
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                    var child = source.children[i];
                    this.add(child.clone());
                }
            }
            return this;
        }
    };
    Object.assign(Object3D.prototype, EventDispatcher.prototype);
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = normal && normal.isVector3 ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = color && color.isColor ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
    Face3.prototype = {
        constructor: Face3,
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
            this.normal.copy(source.normal);
            this.color.copy(source.color);
            this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                this.vertexNormals[i] = source.vertexNormals[i].clone();
            }
            for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                this.vertexColors[i] = source.vertexColors[i].clone();
            }
            return this;
        }
    };
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) {
            throw new TypeError("SZX3D.BufferAttribute: array should be a Typed Array.");
        }
        this.uuid = _Math.generateUUID();
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.dynamic = false;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.onUploadCallback = function() {};
        this.version = 0;
    }
    BufferAttribute.prototype = {
        constructor: BufferAttribute,
        isBufferAttribute: true,
        set needsUpdate(value) {
            if (value === true) this.version++;
        },
        setArray: function(array) {
            if (Array.isArray(array)) {
                throw new TypeError("SZX3D.BufferAttribute: array should be a Typed Array.");
            }
            this.count = array !== undefined ? array.length / this.itemSize : 0;
            this.array = array;
        },
        setDynamic: function(value) {
            this.dynamic = value;
            return this;
        },
        copy: function(source) {
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
            this.dynamic = source.dynamic;
            return this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        },
        copyArray: function(array) {
            this.array.set(array);
            return this;
        },
        copyColorsArray: function(colors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                if (color === undefined) {
                    console.warn("SZX3D.BufferAttribute.copyColorsArray(): color is undefined", i);
                    color = new Color();
                }
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }
            return this;
        },
        copyIndicesArray: function(indices) {
            var array = this.array, offset = 0;
            for (var i = 0, l = indices.length; i < l; i++) {
                var index = indices[i];
                array[offset++] = index.a;
                array[offset++] = index.b;
                array[offset++] = index.c;
            }
            return this;
        },
        copyVector2sArray: function(vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn("SZX3D.BufferAttribute.copyVector2sArray(): vector is undefined", i);
                    vector = new Vector2();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function(vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn("SZX3D.BufferAttribute.copyVector3sArray(): vector is undefined", i);
                    vector = new Vector3();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function(vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn("SZX3D.BufferAttribute.copyVector4sArray(): vector is undefined", i);
                    vector = new Vector4();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }
            return this;
        },
        set: function(value, offset) {
            if (offset === undefined) offset = 0;
            this.array.set(value, offset);
            return this;
        },
        getX: function(index) {
            return this.array[index * this.itemSize];
        },
        setX: function(index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        },
        getY: function(index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function(index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        },
        getZ: function(index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function(index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        },
        getW: function(index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function(index, w) {
            this.array[index * this.itemSize + 3] = w;
            return this;
        },
        setXY: function(index, x, y) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        },
        setXYZ: function(index, x, y, z) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        },
        setXYZW: function(index, x, y, z, w) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        },
        onUpload: function(callback) {
            this.onUploadCallback = callback;
            return this;
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
    };
    function Int8BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Int8Array(array), itemSize);
    }
    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
    function Uint8BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize);
    }
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
    function Uint8ClampedBufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize);
    }
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
    function Int16BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Int16Array(array), itemSize);
    }
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
    function Uint16BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize);
    }
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
    function Int32BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Int32Array(array), itemSize);
    }
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
    function Uint32BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize);
    }
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
    function Float32BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Float32Array(array), itemSize);
    }
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
    function Float64BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Float64Array(array), itemSize);
    }
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        BufferAttribute.call(this, array, itemSize);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;
    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
    InstancedBufferAttribute.prototype.copy = function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    };
    function InterleavedBuffer(array, stride) {
        this.uuid = _Math.generateUUID();
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.dynamic = false;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.onUploadCallback = function() {};
        this.version = 0;
    }
    InterleavedBuffer.prototype = {
        constructor: InterleavedBuffer,
        isInterleavedBuffer: true,
        set needsUpdate(value) {
            if (value === true) this.version++;
        },
        setArray: function(array) {
            if (Array.isArray(array)) {
                throw new TypeError("SZX3D.BufferAttribute: array should be a Typed Array.");
            }
            this.count = array !== undefined ? array.length / this.stride : 0;
            this.array = array;
        },
        setDynamic: function(value) {
            this.dynamic = value;
            return this;
        },
        copy: function(source) {
            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.dynamic = source.dynamic;
            return this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.stride;
            index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        },
        set: function(value, offset) {
            if (offset === undefined) offset = 0;
            this.array.set(value, offset);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        onUpload: function(callback) {
            this.onUploadCallback = callback;
            return this;
        }
    };
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedInterleavedBuffer.prototype = Object.create(InterleavedBuffer.prototype);
    InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;
    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
    InstancedInterleavedBuffer.prototype.copy = function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    };
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.uuid = _Math.generateUUID();
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    InterleavedBufferAttribute.prototype = {
        constructor: InterleavedBufferAttribute,
        isInterleavedBufferAttribute: true,
        get count() {
            return this.data.count;
        },
        get array() {
            return this.data.array;
        },
        setX: function(index, x) {
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        },
        setY: function(index, y) {
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        },
        setZ: function(index, z) {
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        },
        setW: function(index, w) {
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        },
        getX: function(index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function(index, x, y) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        },
        setXYZ: function(index, x, y, z) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        },
        setXYZW: function(index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        }
    };
    var count = 0;
    function GeometryIdCount() {
        return count++;
    }
    function Geometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        });
        this.uuid = _Math.generateUUID();
        this.name = "";
        this.type = "Geometry";
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [ [] ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    Geometry.prototype = {
        constructor: Geometry,
        isGeometry: true,
        applyMatrix: function(matrix) {
            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
            for (var i = 0, il = this.vertices.length; i < il; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
            return this;
        },
        rotateX: function() {
            var m1;
            return function rotateX(angle) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateY: function() {
            var m1;
            return function rotateY(angle) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateZ: function() {
            var m1;
            return function rotateZ(angle) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        translate: function() {
            var m1;
            return function translate(x, y, z) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        scale: function() {
            var m1;
            return function scale(x, y, z) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        lookAt: function() {
            var obj;
            return function lookAt(vector) {
                if (obj === undefined) obj = new Object3D();
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
            };
        }(),
        fromBufferGeometry: function(geometry) {
            var scope = this;
            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
            if (uvs2 !== undefined) this.faceVertexUvs[1] = [];
            var tempNormals = [];
            var tempUVs = [];
            var tempUVs2 = [];
            for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
                scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
                if (normals !== undefined) {
                    tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }
                if (colors !== undefined) {
                    scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
                }
                if (uvs !== undefined) {
                    tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
                }
                if (uvs2 !== undefined) {
                    tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
                }
            }
            function addFace(a, b, c, materialIndex) {
                var vertexNormals = normals !== undefined ? [ tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone() ] : [];
                var vertexColors = colors !== undefined ? [ scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone() ] : [];
                var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uvs !== undefined) {
                    scope.faceVertexUvs[0].push([ tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone() ]);
                }
                if (uvs2 !== undefined) {
                    scope.faceVertexUvs[1].push([ tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone() ]);
                }
            }
            if (indices !== undefined) {
                var groups = geometry.groups;
                if (groups.length > 0) {
                    for (var i = 0; i < groups.length; i++) {
                        var group = groups[i];
                        var start = group.start;
                        var count = group.count;
                        for (var j = start, jl = start + count; j < jl; j += 3) {
                            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        }
                    }
                } else {
                    for (var i = 0; i < indices.length; i += 3) {
                        addFace(indices[i], indices[i + 1], indices[i + 2]);
                    }
                }
            } else {
                for (var i = 0; i < positions.length / 3; i += 3) {
                    addFace(i, i + 1, i + 2);
                }
            }
            this.computeFaceNormals();
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            return this;
        },
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            this.translate(offset.x, offset.y, offset.z);
            return offset;
        },
        normalize: function() {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;
            var s = radius === 0 ? 1 : 1 / radius;
            var matrix = new Matrix4();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
            this.applyMatrix(matrix);
            return this;
        },
        computeFaceNormals: function() {
            var cb = new Vector3(), ab = new Vector3();
            for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
            }
        },
        computeVertexNormals: function(areaWeighted) {
            if (areaWeighted === undefined) areaWeighted = true;
            var v, vl, f, fl, face, vertices;
            vertices = new Array(this.vertices.length);
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v] = new Vector3();
            }
            if (areaWeighted) {
                var vA, vB, vC;
                var cb = new Vector3(), ab = new Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vA = this.vertices[face.a];
                    vB = this.vertices[face.b];
                    vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            } else {
                this.computeFaceNormals();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v].normalize();
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                } else {
                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        },
        computeFlatVertexNormals: function() {
            var f, fl, face;
            this.computeFaceNormals();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(face.normal);
                    vertexNormals[1].copy(face.normal);
                    vertexNormals[2].copy(face.normal);
                } else {
                    vertexNormals[0] = face.normal.clone();
                    vertexNormals[1] = face.normal.clone();
                    vertexNormals[2] = face.normal.clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        },
        computeMorphNormals: function() {
            var i, il, f, fl, face;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                if (!face.__originalFaceNormal) {
                    face.__originalFaceNormal = face.normal.clone();
                } else {
                    face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
                for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                    if (!face.__originalVertexNormals[i]) {
                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    } else {
                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }
            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;
            for (i = 0, il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];
                    var dstNormalsFace = this.morphNormals[i].faceNormals;
                    var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    var faceNormal, vertexNormals;
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        faceNormal = new Vector3();
                        vertexNormals = {
                            a: new Vector3(),
                            b: new Vector3(),
                            c: new Vector3()
                        };
                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices;
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    faceNormal = morphNormals.faceNormals[f];
                    vertexNormals = morphNormals.vertexNormals[f];
                    faceNormal.copy(face.normal);
                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        },
        computeLineDistances: function() {
            var d = 0;
            var vertices = this.vertices;
            for (var i = 0, il = vertices.length; i < il; i++) {
                if (i > 0) {
                    d += vertices[i].distanceTo(vertices[i - 1]);
                }
                this.lineDistances[i] = d;
            }
        },
        computeBoundingBox: function() {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function(geometry, matrix, materialIndexOffset) {
            if ((geometry && geometry.isGeometry) === false) {
                console.error("SZX3D.Geometry.merge(): geometry not an instance of SZX3D.Geometry.", geometry);
                return;
            }
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
            if (materialIndexOffset === undefined) materialIndexOffset = 0;
            if (matrix !== undefined) {
                normalMatrix = new Matrix3().getNormalMatrix(matrix);
            }
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i];
                var vertexCopy = vertex.clone();
                if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
            }
            for (var i = 0, il = colors2.length; i < il; i++) {
                colors1.push(colors2[i].clone());
            }
            for (i = 0, il = faces2.length; i < il; i++) {
                var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== undefined) {
                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                    normal = faceVertexNormals[j].clone();
                    if (normalMatrix !== undefined) {
                        normal.applyMatrix3(normalMatrix).normalize();
                    }
                    faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
            }
            for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (uv === undefined) {
                    continue;
                }
                for (var j = 0, jl = uv.length; j < jl; j++) {
                    uvCopy.push(uv[j].clone());
                }
                uvs1.push(uvCopy);
            }
        },
        mergeMesh: function(mesh) {
            if ((mesh && mesh.isMesh) === false) {
                console.error("SZX3D.Geometry.mergeMesh(): mesh not an instance of SZX3D.Mesh.", mesh);
                return;
            }
            mesh.matrixAutoUpdate && mesh.updateMatrix();
            this.merge(mesh.geometry, mesh.matrix);
        },
        mergeVertices: function() {
            var verticesMap = {};
            var unique = [], changes = [];
            var v, key;
            var precisionPoints = 4;
            var precision = Math.pow(10, precisionPoints);
            var i, il, face;
            var indices, j, jl;
            for (i = 0, il = this.vertices.length; i < il; i++) {
                v = this.vertices[i];
                key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
                if (verticesMap[key] === undefined) {
                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                } else {
                    changes[i] = changes[verticesMap[key]];
                }
            }
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [ face.a, face.b, face.c ];
                for (var n = 0; n < 3; n++) {
                    if (indices[n] === indices[(n + 1) % 3]) {
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }
            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        },
        sortFacesByMaterialIndex: function() {
            var faces = this.faces;
            var length = faces.length;
            for (var i = 0; i < length; i++) {
                faces[i]._id = i;
            }
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            faces.sort(materialIndexSort);
            var uvs1 = this.faceVertexUvs[0];
            var uvs2 = this.faceVertexUvs[1];
            var newUvs1, newUvs2;
            if (uvs1 && uvs1.length === length) newUvs1 = [];
            if (uvs2 && uvs2.length === length) newUvs2 = [];
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                if (newUvs1) newUvs1.push(uvs1[id]);
                if (newUvs2) newUvs2.push(uvs2[id]);
            }
            if (newUvs1) this.faceVertexUvs[0] = newUvs1;
            if (newUvs2) this.faceVertexUvs[1] = newUvs2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.4,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== "") data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }
                return data;
            }
            var vertices = [];
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};
            for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i];
                var hasMaterial = true;
                var hasFaceUv = false;
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
                var faceType = 0;
                faceType = setBit(faceType, 0, 0);
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal) {
                    faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor) {
                    faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            function setBit(value, position, enabled) {
                return enabled ? value | 1 << position : value & ~(1 << position);
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== undefined) {
                    return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== undefined) {
                    return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== undefined) {
                    return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
            }
            data.data = {};
            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0) data.data.colors = colors;
            if (uvs.length > 0) data.data.uvs = [ uvs ];
            data.data.faces = faces;
            return data;
        },
        clone: function() {
            return new Geometry().copy(this);
        },
        copy: function(source) {
            var i, il, j, jl, k, kl;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [ [] ];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            var vertices = source.vertices;
            for (i = 0, il = vertices.length; i < il; i++) {
                this.vertices.push(vertices[i].clone());
            }
            var colors = source.colors;
            for (i = 0, il = colors.length; i < il; i++) {
                this.colors.push(colors[i].clone());
            }
            var faces = source.faces;
            for (i = 0, il = faces.length; i < il; i++) {
                this.faces.push(faces[i].clone());
            }
            for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === undefined) {
                    this.faceVertexUvs[i] = [];
                }
                for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j], uvsCopy = [];
                    for (k = 0, kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            var morphTargets = source.morphTargets;
            for (i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = {};
                morphTarget.name = morphTargets[i].name;
                if (morphTargets[i].vertices !== undefined) {
                    morphTarget.vertices = [];
                    for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
                        morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                    }
                }
                if (morphTargets[i].normals !== undefined) {
                    morphTarget.normals = [];
                    for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
                        morphTarget.normals.push(morphTargets[i].normals[j].clone());
                    }
                }
                this.morphTargets.push(morphTarget);
            }
            var morphNormals = source.morphNormals;
            for (i = 0, il = morphNormals.length; i < il; i++) {
                var morphNormal = {};
                if (morphNormals[i].vertexNormals !== undefined) {
                    morphNormal.vertexNormals = [];
                    for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                        var srcVertexNormal = morphNormals[i].vertexNormals[j];
                        var destVertexNormal = {};
                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();
                        morphNormal.vertexNormals.push(destVertexNormal);
                    }
                }
                if (morphNormals[i].faceNormals !== undefined) {
                    morphNormal.faceNormals = [];
                    for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                        morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                    }
                }
                this.morphNormals.push(morphNormal);
            }
            var skinWeights = source.skinWeights;
            for (i = 0, il = skinWeights.length; i < il; i++) {
                this.skinWeights.push(skinWeights[i].clone());
            }
            var skinIndices = source.skinIndices;
            for (i = 0, il = skinIndices.length; i < il; i++) {
                this.skinIndices.push(skinIndices[i].clone());
            }
            var lineDistances = source.lineDistances;
            for (i = 0, il = lineDistances.length; i < il; i++) {
                this.lineDistances.push(lineDistances[i]);
            }
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    Object.assign(Geometry.prototype, EventDispatcher.prototype);
    function DirectGeometry() {
        this.indices = [];
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    Object.assign(DirectGeometry.prototype, {
        computeGroups: function(geometry) {
            var group;
            var groups = [];
            var materialIndex = undefined;
            var faces = geometry.faces;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.materialIndex !== materialIndex) {
                    materialIndex = face.materialIndex;
                    if (group !== undefined) {
                        group.count = i * 3 - group.start;
                        groups.push(group);
                    }
                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
                }
            }
            if (group !== undefined) {
                group.count = i * 3 - group.start;
                groups.push(group);
            }
            this.groups = groups;
        },
        fromGeometry: function(geometry) {
            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;
            var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;
            var morphTargetsPosition;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) {
                    morphTargetsPosition[i] = [];
                }
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;
            var morphTargetsNormal;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) {
                    morphTargetsNormal[i] = [];
                }
                this.morphTargets.normal = morphTargetsNormal;
            }
            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;
            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                } else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (vertexColors.length === 3) {
                    this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                } else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === true) {
                    var vertexUvs = faceVertexUvs[0][i];
                    if (vertexUvs !== undefined) {
                        this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {
                        console.warn("SZX3D.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
                        this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }
                if (hasFaceVertexUv2 === true) {
                    var vertexUvs = faceVertexUvs[1][i];
                    if (vertexUvs !== undefined) {
                        this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {
                        console.warn("SZX3D.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
                        this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                if (hasSkinIndices) {
                    this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }
                if (hasSkinWeights) {
                    this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
            }
            this.computeGroups(geometry);
            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;
            return this;
        }
    });
    function BufferGeometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        });
        this.uuid = _Math.generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
    }
    BufferGeometry.prototype = {
        constructor: BufferGeometry,
        isBufferGeometry: true,
        getIndex: function() {
            return this.index;
        },
        setIndex: function(index) {
            if (Array.isArray(index)) {
                this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
            } else {
                this.index = index;
            }
        },
        addAttribute: function(name, attribute) {
            if ((attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false) {
                console.warn("SZX3D.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
                this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
                return;
            }
            if (name === "index") {
                console.warn("SZX3D.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
                this.setIndex(attribute);
                return;
            }
            this.attributes[name] = attribute;
            return this;
        },
        getAttribute: function(name) {
            return this.attributes[name];
        },
        removeAttribute: function(name) {
            delete this.attributes[name];
            return this;
        },
        addGroup: function(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex !== undefined ? materialIndex : 0
            });
        },
        clearGroups: function() {
            this.groups = [];
        },
        setDrawRange: function(start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        },
        applyMatrix: function(matrix) {
            var position = this.attributes.position;
            if (position !== undefined) {
                matrix.applyToBufferAttribute(position);
                position.needsUpdate = true;
            }
            var normal = this.attributes.normal;
            if (normal !== undefined) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToBufferAttribute(normal);
                normal.needsUpdate = true;
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            return this;
        },
        rotateX: function() {
            var m1;
            return function rotateX(angle) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateY: function() {
            var m1;
            return function rotateY(angle) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateZ: function() {
            var m1;
            return function rotateZ(angle) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        translate: function() {
            var m1;
            return function translate(x, y, z) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        scale: function() {
            var m1;
            return function scale(x, y, z) {
                if (m1 === undefined) m1 = new Matrix4();
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        lookAt: function() {
            var obj;
            return function lookAt(vector) {
                if (obj === undefined) obj = new Object3D();
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
            };
        }(),
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            this.translate(offset.x, offset.y, offset.z);
            return offset;
        },
        setFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
                this.addAttribute("position", positions.copyVector3sArray(geometry.vertices));
                this.addAttribute("color", colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                    this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }
            } else if (object.isMesh) {
                if (geometry && geometry.isGeometry) {
                    this.fromGeometry(geometry);
                }
            }
            return this;
        },
        updateFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isMesh) {
                var direct = geometry.__directGeometry;
                if (geometry.elementsNeedUpdate === true) {
                    direct = undefined;
                    geometry.elementsNeedUpdate = false;
                }
                if (direct === undefined) {
                    return this.fromGeometry(geometry);
                }
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
                geometry = direct;
            }
            var attribute;
            if (geometry.verticesNeedUpdate === true) {
                attribute = this.attributes.position;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.vertices);
                    attribute.needsUpdate = true;
                }
                geometry.verticesNeedUpdate = false;
            }
            if (geometry.normalsNeedUpdate === true) {
                attribute = this.attributes.normal;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.normals);
                    attribute.needsUpdate = true;
                }
                geometry.normalsNeedUpdate = false;
            }
            if (geometry.colorsNeedUpdate === true) {
                attribute = this.attributes.color;
                if (attribute !== undefined) {
                    attribute.copyColorsArray(geometry.colors);
                    attribute.needsUpdate = true;
                }
                geometry.colorsNeedUpdate = false;
            }
            if (geometry.uvsNeedUpdate) {
                attribute = this.attributes.uv;
                if (attribute !== undefined) {
                    attribute.copyVector2sArray(geometry.uvs);
                    attribute.needsUpdate = true;
                }
                geometry.uvsNeedUpdate = false;
            }
            if (geometry.lineDistancesNeedUpdate) {
                attribute = this.attributes.lineDistance;
                if (attribute !== undefined) {
                    attribute.copyArray(geometry.lineDistances);
                    attribute.needsUpdate = true;
                }
                geometry.lineDistancesNeedUpdate = false;
            }
            if (geometry.groupsNeedUpdate) {
                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;
                geometry.groupsNeedUpdate = false;
            }
            return this;
        },
        fromGeometry: function(geometry) {
            geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
            return this.fromDirectGeometry(geometry.__directGeometry);
        },
        fromDirectGeometry: function(geometry) {
            var positions = new Float32Array(geometry.vertices.length * 3);
            this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
            if (geometry.normals.length > 0) {
                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            if (geometry.indices.length > 0) {
                var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array;
                var indices = new TypeArray(geometry.indices.length * 3);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                var array = [];
                var morphTargets = geometry.morphTargets[name];
                for (var i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i];
                    var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            return this;
        },
        computeBoundingBox: function() {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            var position = this.attributes.position;
            if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position);
            } else {
                this.boundingBox.makeEmpty();
            }
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('SZX3D.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        },
        computeBoundingSphere: function() {
            var box = new Box3();
            var vector = new Vector3();
            return function computeBoundingSphere() {
                if (this.boundingSphere === null) {
                    this.boundingSphere = new Sphere();
                }
                var position = this.attributes.position;
                if (position) {
                    var center = this.boundingSphere.center;
                    box.setFromBufferAttribute(position);
                    box.getCenter(center);
                    var maxRadiusSq = 0;
                    for (var i = 0, il = position.count; i < il; i++) {
                        vector.x = position.getX(i);
                        vector.y = position.getY(i);
                        vector.z = position.getZ(i);
                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    }
                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                    if (isNaN(this.boundingSphere.radius)) {
                        console.error('SZX3D.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                    }
                }
            };
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var index = this.index;
            var attributes = this.attributes;
            var groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (attributes.normal === undefined) {
                    this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
                } else {
                    var array = attributes.normal.array;
                    for (var i = 0, il = array.length; i < il; i++) {
                        array[i] = 0;
                    }
                }
                var normals = attributes.normal.array;
                var vA, vB, vC;
                var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
                var cb = new Vector3(), ab = new Vector3();
                if (index) {
                    var indices = index.array;
                    if (groups.length === 0) {
                        this.addGroup(0, indices.length);
                    }
                    for (var j = 0, jl = groups.length; j < jl; ++j) {
                        var group = groups[j];
                        var start = group.start;
                        var count = group.count;
                        for (var i = start, il = start + count; i < il; i += 3) {
                            vA = indices[i + 0] * 3;
                            vB = indices[i + 1] * 3;
                            vC = indices[i + 2] * 3;
                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;
                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;
                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    }
                } else {
                    for (var i = 0, il = positions.length; i < il; i += 9) {
                        pA.fromArray(positions, i);
                        pB.fromArray(positions, i + 3);
                        pC.fromArray(positions, i + 6);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[i] = cb.x;
                        normals[i + 1] = cb.y;
                        normals[i + 2] = cb.z;
                        normals[i + 3] = cb.x;
                        normals[i + 4] = cb.y;
                        normals[i + 5] = cb.z;
                        normals[i + 6] = cb.x;
                        normals[i + 7] = cb.y;
                        normals[i + 8] = cb.z;
                    }
                }
                this.normalizeNormals();
                attributes.normal.needsUpdate = true;
            }
        },
        merge: function(geometry, offset) {
            if ((geometry && geometry.isBufferGeometry) === false) {
                console.error("SZX3D.BufferGeometry.merge(): geometry not an instance of SZX3D.BufferGeometry.", geometry);
                return;
            }
            if (offset === undefined) offset = 0;
            var attributes = this.attributes;
            for (var key in attributes) {
                if (geometry.attributes[key] === undefined) continue;
                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;
                var attributeSize = attribute2.itemSize;
                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                    attributeArray1[j] = attributeArray2[i];
                }
            }
            return this;
        },
        normalizeNormals: function() {
            var normals = this.attributes.normal.array;
            var x, y, z, n;
            for (var i = 0, il = normals.length; i < il; i += 3) {
                x = normals[i];
                y = normals[i + 1];
                z = normals[i + 2];
                n = 1 / Math.sqrt(x * x + y * y + z * z);
                normals[i] *= n;
                normals[i + 1] *= n;
                normals[i + 2] *= n;
            }
        },
        toNonIndexed: function() {
            if (this.index === null) {
                console.warn("SZX3D.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
                return this;
            }
            var geometry2 = new BufferGeometry();
            var indices = this.index.array;
            var attributes = this.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0, index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) {
                        array2[index2++] = array[index++];
                    }
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }
            return geometry2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.4,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== "") data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }
                return data;
            }
            data.data = {
                attributes: {}
            };
            var index = this.index;
            if (index !== null) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
            }
            var boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) {
                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                };
            }
            return data;
        },
        clone: function() {
            return new BufferGeometry().copy(this);
        },
        copy: function(source) {
            var name, i, l;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            var index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            var attributes = source.attributes;
            for (name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var morphAttributes = source.morphAttributes;
            for (name in morphAttributes) {
                var array = [];
                var morphAttribute = morphAttributes[name];
                for (i = 0, l = morphAttribute.length; i < l; i++) {
                    array.push(morphAttribute[i].clone());
                }
                this.morphAttributes[name] = array;
            }
            var groups = source.groups;
            for (i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    BufferGeometry.MaxIndex = 65535;
    Object.assign(BufferGeometry.prototype, EventDispatcher.prototype);
    function InstancedBufferGeometry() {
        BufferGeometry.call(this);
        this.type = "InstancedBufferGeometry";
        this.maxInstancedCount = undefined;
    }
    InstancedBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;
    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
    InstancedBufferGeometry.prototype.addGroup = function(start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    };
    InstancedBufferGeometry.prototype.copy = function(source) {
        var index = source.index;
        if (index !== null) {
            this.setIndex(index.clone());
        }
        var attributes = source.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            this.addAttribute(name, attribute.clone());
        }
        var groups = source.groups;
        for (var i = 0, l = groups.length; i < l; i++) {
            var group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        return this;
    };
    function Uniform(value) {
        if (typeof value === "string") {
            console.warn("SZX3D.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
        }
        this.value = value;
    }
    Uniform.prototype.clone = function() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    };
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        var interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for (var i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
    }
    AnimationAction.prototype = {
        constructor: AnimationAction,
        play: function() {
            this._mixer._activateAction(this);
            return this;
        },
        stop: function() {
            this._mixer._deactivateAction(this);
            return this.reset();
        },
        reset: function() {
            this.paused = false;
            this.enabled = true;
            this.time = 0;
            this._loopCount = -1;
            this._startTime = null;
            return this.stopFading().stopWarping();
        },
        isRunning: function() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this);
        },
        startAt: function(time) {
            this._startTime = time;
            return this;
        },
        setLoop: function(mode, repetitions) {
            this.loop = mode;
            this.repetitions = repetitions;
            return this;
        },
        setEffectiveWeight: function(weight) {
            this.weight = weight;
            this._effectiveWeight = this.enabled ? weight : 0;
            return this.stopFading();
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight;
        },
        fadeIn: function(duration) {
            return this._scheduleFading(duration, 0, 1);
        },
        fadeOut: function(duration) {
            return this._scheduleFading(duration, 1, 0);
        },
        crossFadeFrom: function(fadeOutAction, duration, warp) {
            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);
            if (warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration);
                this.warp(endStartRatio, 1, duration);
            }
            return this;
        },
        crossFadeTo: function(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        },
        stopFading: function() {
            var weightInterpolant = this._weightInterpolant;
            if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }
            return this;
        },
        setEffectiveTimeScale: function(timeScale) {
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
            return this.stopWarping();
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
        },
        setDuration: function(duration) {
            this.timeScale = this._clip.duration / duration;
            return this.stopWarping();
        },
        syncWith: function(action) {
            this.time = action.time;
            this.timeScale = action.timeScale;
            return this.stopWarping();
        },
        halt: function(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        },
        warp: function(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            times[0] = now;
            times[1] = now + duration;
            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;
            return this;
        },
        stopWarping: function() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }
            return this;
        },
        getMixer: function() {
            return this._mixer;
        },
        getClip: function() {
            return this._clip;
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root;
        },
        _update: function(time, deltaTime, timeDirection, accuIndex) {
            var startTime = this._startTime;
            if (startTime !== null) {
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                    return;
                }
                this._startTime = null;
                deltaTime = timeDirection * timeRunning;
            }
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime);
            var weight = this._updateWeight(time);
            if (weight > 0) {
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                for (var j = 0, m = interpolants.length; j !== m; ++j) {
                    interpolants[j].evaluate(clipTime);
                    propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
        },
        _updateWeight: function(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopFading();
                        if (interpolantValue === 0) {
                            this.enabled = false;
                        }
                    }
                }
            }
            this._effectiveWeight = weight;
            return weight;
        },
        _updateTimeScale: function(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopWarping();
                        if (timeScale === 0) {
                            this.paused = true;
                        } else {
                            this.timeScale = timeScale;
                        }
                    }
                }
            }
            this._effectiveTimeScale = timeScale;
            return timeScale;
        },
        _updateTime: function(deltaTime) {
            var time = this.time + deltaTime;
            if (deltaTime === 0) return time;
            var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
            if (loop === LoopOnce) {
                if (loopCount === -1) {
                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }
                handle_stop: {
                    if (time >= duration) {
                        time = duration;
                    } else if (time < 0) {
                        time = 0;
                    } else break handle_stop;
                    if (this.clampWhenFinished) this.paused = true; else this.enabled = false;
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                var pingPong = loop === LoopPingPong;
                if (loopCount === -1) {
                    if (deltaTime >= 0) {
                        loopCount = 0;
                        this._setEndings(true, this.repetitions === 0, pingPong);
                    } else {
                        this._setEndings(this.repetitions === 0, true, pingPong);
                    }
                }
                if (time >= duration || time < 0) {
                    var loopDelta = Math.floor(time / duration);
                    time -= duration * loopDelta;
                    loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending < 0) {
                        if (this.clampWhenFinished) this.paused = true; else this.enabled = false;
                        time = deltaTime > 0 ? duration : 0;
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    } else {
                        if (pending === 0) {
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else {
                            this._setEndings(false, false, pingPong);
                        }
                        this._loopCount = loopCount;
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && (loopCount & 1) === 1) {
                    this.time = time;
                    return duration - time;
                }
            }
            this.time = time;
            return time;
        },
        _setEndings: function(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
            } else {
                if (atStart) {
                    settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingStart = WrapAroundEnding;
                }
                if (atEnd) {
                    settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingEnd = WrapAroundEnding;
                }
            }
        },
        _scheduleFading: function(duration, weightNow, weightThen) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            times[0] = now;
            values[0] = weightNow;
            times[1] = now + duration;
            values[1] = weightThen;
            return this;
        }
    };
    var AnimationUtils = {
        arraySlice: function(array, from, to) {
            if (AnimationUtils.isTypedArray(array)) {
                return new array.constructor(array.subarray(from, to));
            }
            return array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
            if (!array || !forceClone && array.constructor === type) return array;
            if (typeof type.BYTES_PER_ELEMENT === "number") {
                return new type(array);
            }
            return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            var n = times.length;
            var result = new Array(n);
            for (var i = 0; i !== n; ++i) result[i] = i;
            result.sort(compareTime);
            return result;
        },
        sortedArray: function(values, stride, order) {
            var nValues = values.length;
            var result = new values.constructor(nValues);
            for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                var srcOffset = order[i] * stride;
                for (var j = 0; j !== stride; ++j) {
                    result[dstOffset++] = values[srcOffset + j];
                }
            }
            return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
            var i = 1, key = jsonKeys[0];
            while (key !== undefined && key[valuePropertyName] === undefined) {
                key = jsonKeys[i++];
            }
            if (key === undefined) return;
            var value = key[valuePropertyName];
            if (value === undefined) return;
            if (Array.isArray(value)) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push.apply(values, value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else if (value.toArray !== undefined) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        value.toArray(values, values.length);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push(value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
        }
    };
    function KeyframeTrackConstructor(name, times, values, interpolation) {
        if (name === undefined) throw new Error("track name is undefined");
        if (times === undefined || times.length === 0) {
            throw new Error("no keyframes in track named " + name);
        }
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
        this.validate();
        this.optimize();
    }
    exports.KeyframeTrackPrototype = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function(interpolation) {
            var factoryMethod;
            switch (interpolation) {
              case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;

              case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;

              case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
            }
            if (factoryMethod === undefined) {
                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === undefined) {
                    if (interpolation !== this.DefaultInterpolation) {
                        this.setInterpolation(this.DefaultInterpolation);
                    } else {
                        throw new Error(message);
                    }
                }
                console.warn(message);
                return;
            }
            this.createInterpolant = factoryMethod;
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;

              case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;

              case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length;
        },
        shift: function(timeOffset) {
            if (timeOffset !== 0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] += timeOffset;
                }
            }
            return this;
        },
        scale: function(timeScale) {
            if (timeScale !== 1) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] *= timeScale;
                }
            }
            return this;
        },
        trim: function(startTime, endTime) {
            var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
            while (from !== nKeys && times[from] < startTime) ++from;
            while (to !== -1 && times[to] > endTime) --to;
            ++to;
            if (from !== 0 || to !== nKeys) {
                if (from >= to) to = Math.max(to, 1), from = to - 1;
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to);
                this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        validate: function() {
            var valid = true;
            var valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {
                console.error("invalid value size in track", this);
                valid = false;
            }
            var times = this.times, values = this.values, nKeys = times.length;
            if (nKeys === 0) {
                console.error("track is empty", this);
                valid = false;
            }
            var prevTime = null;
            for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === "number" && isNaN(currTime)) {
                    console.error("time is not a valid number", this, i, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error("out of order keys", this, i, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (AnimationUtils.isTypedArray(values)) {
                    for (var i = 0, n = values.length; i !== n; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            console.error("value is not a valid number", this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }
            return valid;
        },
        optimize: function() {
            var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
            for (var i = 1; i < lastIndex; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];
                if (time !== timeNext && (i !== 1 || time !== time[0])) {
                    if (!smoothInterpolation) {
                        var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                        for (var j = 0; j !== stride; ++j) {
                            var value = values[offset + j];
                            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                keep = true;
                                break;
                            }
                        }
                    } else keep = true;
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        var readOffset = i * stride, writeOffset = writeIndex * stride;
                        for (var j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                    }
                    ++writeIndex;
                }
            }
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                ++writeIndex;
            }
            if (writeIndex !== times.length) {
                this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            }
            return this;
        }
    };
    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrackConstructor.call(this, name, times, values);
    }
    BooleanKeyframeTrack.prototype = Object.assign(Object.create(exports.KeyframeTrackPrototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });
    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    ColorKeyframeTrack.prototype = Object.assign(Object.create(exports.KeyframeTrackPrototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: "color"
    });
    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    NumberKeyframeTrack.prototype = Object.assign(Object.create(exports.KeyframeTrackPrototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: "number"
    });
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(exports.KeyframeTrackPrototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: "quaternion",
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodLinear: function(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: undefined
    });
    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    StringKeyframeTrack.prototype = Object.assign(Object.create(exports.KeyframeTrackPrototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });
    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    VectorKeyframeTrack.prototype = Object.assign(Object.create(exports.KeyframeTrackPrototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: "vector"
    });
    function KeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.apply(this, arguments);
    }
    KeyframeTrack.prototype = exports.KeyframeTrackPrototype;
    exports.KeyframeTrackPrototype.constructor = KeyframeTrack;
    Object.assign(KeyframeTrack, {
        parse: function(json) {
            if (json.type === undefined) {
                throw new Error("track type undefined, can not parse");
            }
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (json.times === undefined) {
                var times = [], values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, "value");
                json.times = times;
                json.values = values;
            }
            if (trackType.parse !== undefined) {
                return trackType.parse(json);
            } else {
                return new trackType(json.name, json.times, json.values, json.interpolation);
            }
        },
        toJSON: function(track) {
            var trackType = track.constructor;
            var json;
            if (trackType.toJSON !== undefined) {
                json = trackType.toJSON(track);
            } else {
                json = {
                    name: track.name,
                    times: AnimationUtils.convertArray(track.times, Array),
                    values: AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                    json.interpolation = interpolation;
                }
            }
            json.type = track.ValueTypeName;
            return json;
        },
        _getTrackTypeForValueTypeName: function(typeName) {
            switch (typeName.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return NumberKeyframeTrack;

              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return VectorKeyframeTrack;

              case "color":
                return ColorKeyframeTrack;

              case "quaternion":
                return QuaternionKeyframeTrack;

              case "bool":
              case "boolean":
                return BooleanKeyframeTrack;

              case "string":
                return StringKeyframeTrack;
            }
            throw new Error("Unsupported typeName: " + typeName);
        }
    });
    function AnimationClip(name, duration, tracks) {
        this.name = name;
        this.tracks = tracks;
        this.duration = duration !== undefined ? duration : -1;
        this.uuid = _Math.generateUUID();
        if (this.duration < 0) {
            this.resetDuration();
        }
        this.optimize();
    }
    AnimationClip.prototype = {
        constructor: AnimationClip,
        resetDuration: function() {
            var tracks = this.tracks, duration = 0;
            for (var i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        },
        trim: function() {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
            }
            return this;
        },
        optimize: function() {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
            }
            return this;
        }
    };
    Object.assign(AnimationClip, {
        parse: function(json) {
            var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
            for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            }
            return new AnimationClip(json.name, json.duration, tracks);
        },
        toJSON: function(clip) {
            var tracks = [], clipTracks = clip.tracks;
            var json = {
                name: clip.name,
                duration: clip.duration,
                tracks: tracks
            };
            for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            }
            return json;
        },
        CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
            for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order);
                values = AnimationUtils.sortedArray(values, 1, order);
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                    return clipArray[i];
                }
            }
            return null;
        },
        CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
            var animationToMorphTargets = {};
            var pattern = /^([\w-]*?)([\d]+)$/;
            for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1];
                    var animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) {
                        animationToMorphTargets[name] = animationMorphTargets = [];
                    }
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name in animationToMorphTargets) {
                clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            }
            return clips;
        },
        parseAnimation: function(animation, bones) {
            if (!animation) {
                console.error("  no animation in JSONLoader data");
                return null;
            }
            var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                if (animationKeys.length !== 0) {
                    var times = [];
                    var values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                    if (times.length !== 0) {
                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };
            var tracks = [];
            var clipName = animation.name || "default";
            var duration = animation.length || -1;
            var fps = animation.fps || 30;
            var hierarchyTracks = animation.hierarchy || [];
            for (var h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (!animationKeys || animationKeys.length === 0) continue;
                if (animationKeys[0].morphTargets) {
                    var morphTargetNames = {};
                    for (var k = 0; k < animationKeys.length; k++) {
                        if (animationKeys[k].morphTargets) {
                            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }
                    for (var morphTargetName in morphTargetNames) {
                        var times = [];
                        var values = [];
                        for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1);
                } else {
                    var boneName = ".bones[" + bones[h].name + "]";
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
                }
            }
            if (tracks.length === 0) {
                return null;
            }
            var clip = new AnimationClip(clipName, duration, tracks);
            return clip;
        }
    });
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
    }
    PropertyBinding.prototype = {
        constructor: PropertyBinding,
        getValue: function getValue_unbound(targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset);
        },
        setValue: function getValue_unbound(sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        },
        bind: function() {
            var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                this.node = targetObject;
            }
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (!targetObject) {
                console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                return;
            }
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                  case "materials":
                    if (!targetObject.material) {
                        console.error("  can not bind to material as node does not have a material", this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;

                  case "bones":
                    if (!targetObject.skeleton) {
                        console.error("  can not bind to bones as node does not have a skeleton", this);
                        return;
                    }
                    targetObject = targetObject.skeleton.bones;
                    for (var i = 0; i < targetObject.length; i++) {
                        if (targetObject[i].name === objectIndex) {
                            objectIndex = i;
                            break;
                        }
                    }
                    break;

                  default:
                    if (targetObject[objectName] === undefined) {
                        console.error("  can not bind to objectName of node, undefined", this);
                        return;
                    }
                    targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error("  trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
                return;
            }
            var versioning = this.Versioning.None;
            if (targetObject.needsUpdate !== undefined) {
                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
            } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
            }
            var bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                if (propertyName === "morphTargetInfluences") {
                    if (!targetObject.geometry) {
                        console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                        return;
                    }
                    if (!targetObject.geometry.morphTargets) {
                        console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                        return;
                    }
                    for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                        if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                            propertyIndex = i;
                            break;
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            } else if (nodeProperty.length !== undefined) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            } else {
                this.propertyName = propertyName;
            }
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function() {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
    };
    Object.assign(PropertyBinding.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue,
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [ function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        }, function getValue_array(buffer, offset) {
            var source = this.resolvedProperty;
            for (var i = 0, n = source.length; i !== n; ++i) {
                buffer[offset++] = source[i];
            }
        }, function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }, function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        } ],
        SetterByBindingTypeAndVersioning: [ [ function setValue_direct(buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
        }, function setValue_direct_setNeedsUpdate(buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
            this.targetObject.needsUpdate = true;
        }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        } ], [ function setValue_array(buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
        }, function setValue_array_setNeedsUpdate(buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
            this.targetObject.needsUpdate = true;
        }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
            this.targetObject.matrixWorldNeedsUpdate = true;
        } ], [ function setValue_arrayElement(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.needsUpdate = true;
        }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        } ], [ function setValue_fromArray(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.needsUpdate = true;
        }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.matrixWorldNeedsUpdate = true;
        } ] ]
    });
    PropertyBinding.Composite = function(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    };
    PropertyBinding.Composite.prototype = {
        constructor: PropertyBinding.Composite,
        getValue: function(array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            if (binding !== undefined) binding.getValue(array, offset);
        },
        setValue: function(array, offset) {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        },
        bind: function() {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        },
        unbind: function() {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        }
    };
    PropertyBinding.create = function(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
        } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
        }
    };
    PropertyBinding.parseTrackName = function(trackName) {
        var re = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;
        var matches = re.exec(trackName);
        if (!matches) {
            throw new Error("cannot parse trackName at all: " + trackName);
        }
        var results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("can not parse propertyName from trackName: " + trackName);
        }
        return results;
    };
    PropertyBinding.findNode = function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
        }
        if (root.skeleton) {
            var searchSkeleton = function(skeleton) {
                for (var i = 0; i < skeleton.bones.length; i++) {
                    var bone = skeleton.bones[i];
                    if (bone.name === nodeName) {
                        return bone;
                    }
                }
                return null;
            };
            var bone = searchSkeleton(root.skeleton);
            if (bone) {
                return bone;
            }
        }
        if (root.children) {
            var searchNodeSubtree = function(children) {
                for (var i = 0; i < children.length; i++) {
                    var childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
                        return childNode;
                    }
                    var result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            var subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
                return subTreeNode;
            }
        }
        return null;
    };
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var bufferType = Float64Array, mixFunction;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            break;

          case "string":
          case "bool":
            bufferType = Array;
            mixFunction = this._select;
            break;

          default:
            mixFunction = this._lerp;
        }
        this.buffer = new bufferType(valueSize * 4);
        this._mixBufferRegion = mixFunction;
        this.cumulativeWeight = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    PropertyMixer.prototype = {
        constructor: PropertyMixer,
        accumulate: function(accuIndex, weight) {
            var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
            } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        apply: function(accuIndex) {
            var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
            this.cumulativeWeight = 0;
            if (weight < 1) {
                var originalValueOffset = stride * 3;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                    binding.setValue(buffer, offset);
                    break;
                }
            }
        },
        saveOriginalState: function() {
            var binding = this.binding;
            var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + i % stride];
            }
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function() {
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _select: function(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= .5) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        },
        _slerp: function(buffer, dstOffset, srcOffset, t, stride) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
            var s = 1 - t;
            for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    };
    function AnimationMixer(root) {
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
    }
    AnimationMixer.prototype = {
        constructor: AnimationMixer,
        clipAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
            if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined) {
                    return existingAction;
                }
                prototypeAction = actionsForClip.knownActions[0];
                if (clipObject === null) clipObject = prototypeAction._clip;
            }
            if (clipObject === null) return null;
            var newAction = new AnimationAction(this, clipObject, optionalRoot);
            this._bindAction(newAction, prototypeAction);
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        },
        existingAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
            }
            return null;
        },
        stopAllAction: function() {
            var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
            this._nActiveActions = 0;
            this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) {
                actions[i].reset();
            }
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].useCount = 0;
            }
            return this;
        },
        update: function(deltaTime) {
            deltaTime *= this.timeScale;
            var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
            for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                if (action.enabled) {
                    action._update(time, deltaTime, timeDirection, accuIndex);
                }
            }
            var bindings = this._bindings, nBindings = this._nActiveBindings;
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
            }
            return this;
        },
        getRoot: function() {
            return this._root;
        },
        uncacheClip: function(clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        uncacheRoot: function(root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) {
                for (var trackName in bindingByName) {
                    var binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        },
        uncacheAction: function(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
    };
    Object.assign(AnimationMixer.prototype, {
        _bindAction: function(action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (binding !== undefined) {
                    bindings[i] = binding;
                } else {
                    binding = bindings[i];
                    if (binding !== undefined) {
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function(action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (binding.useCount++ === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function(action) {
            if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (--binding.useCount === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        },
        _initMemoryManager: function() {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function(action) {
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        },
        _addInactiveAction: function(action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [ action ],
                    actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            } else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function(action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
            }
            this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function(action) {
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                    this._removeInactiveBinding(binding);
                }
            }
        },
        _lendAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        },
        _addInactiveBinding: function(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
            if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        },
        _removeInactiveBinding: function(binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName) break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        },
        _lendBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        },
        _lendControlInterpolant: function() {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        },
        _takeBackControlInterpolant: function(interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1)
    });
    Object.assign(AnimationMixer.prototype, EventDispatcher.prototype);
    function AnimationObjectGroup(var_args) {
        this.uuid = _Math.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    AnimationObjectGroup.prototype = {
        constructor: AnimationObjectGroup,
        isAnimationObjectGroup: true,
        add: function(var_args) {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid], knownObject = undefined;
                if (index === undefined) {
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                } else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) {
                            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                        }
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else if (objects[index] !== knownObject) {
                    console.error("Different objects with the same UUID " + "detected. Clean the caches or recreate your " + "infrastructure when reloading scenes...");
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function(var_args) {
            var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        uncache: function(var_args) {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    } else {
                        var lastIndex = --nObjects, lastObject = objects[lastIndex];
                        indicesByUUID[lastObject.uuid] = index;
                        objects[index] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j];
                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        subscribe_: function(path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
            if (index !== undefined) return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function(path) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (index !== undefined) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }
    };
    function Audio(listener) {
        Object3D.call(this);
        this.type = "Audio";
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.loop = false;
        this.startTime = 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = "empty";
        this.filters = [];
    }
    Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Audio,
        getOutput: function() {
            return this.gain;
        },
        setNodeSource: function(audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = "audioNode";
            this.source = audioNode;
            this.connect();
            return this;
        },
        setBuffer: function(audioBuffer) {
            this.buffer = audioBuffer;
            this.sourceType = "buffer";
            if (this.autoplay) this.play();
            return this;
        },
        play: function() {
            if (this.isPlaying === true) {
                console.warn("SZX3D.Audio: Audio is already playing.");
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn("SZX3D.Audio: this Audio has no playback control.");
                return;
            }
            var source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.onended = this.onEnded.bind(this);
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
            source.start(0, this.startTime);
            this.isPlaying = true;
            this.source = source;
            return this.connect();
        },
        pause: function() {
            if (this.hasPlaybackControl === false) {
                console.warn("SZX3D.Audio: this Audio has no playback control.");
                return;
            }
            this.source.stop();
            this.startTime = this.context.currentTime;
            this.isPlaying = false;
            return this;
        },
        stop: function() {
            if (this.hasPlaybackControl === false) {
                console.warn("SZX3D.Audio: this Audio has no playback control.");
                return;
            }
            this.source.stop();
            this.startTime = 0;
            this.isPlaying = false;
            return this;
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else {
                this.source.connect(this.getOutput());
            }
            return this;
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else {
                this.source.disconnect(this.getOutput());
            }
            return this;
        },
        getFilters: function() {
            return this.filters;
        },
        setFilters: function(value) {
            if (!value) value = [];
            if (this.isPlaying === true) {
                this.disconnect();
                this.filters = value;
                this.connect();
            } else {
                this.filters = value;
            }
            return this;
        },
        getFilter: function() {
            return this.getFilters()[0];
        },
        setFilter: function(filter) {
            return this.setFilters(filter ? [ filter ] : []);
        },
        setPlaybackRate: function(value) {
            if (this.hasPlaybackControl === false) {
                console.warn("SZX3D.Audio: this Audio has no playback control.");
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) {
                this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
            }
            return this;
        },
        getPlaybackRate: function() {
            return this.playbackRate;
        },
        onEnded: function() {
            this.isPlaying = false;
        },
        getLoop: function() {
            if (this.hasPlaybackControl === false) {
                console.warn("SZX3D.Audio: this Audio has no playback control.");
                return false;
            }
            return this.loop;
        },
        setLoop: function(value) {
            if (this.hasPlaybackControl === false) {
                console.warn("SZX3D.Audio: this Audio has no playback control.");
                return;
            }
            this.loop = value;
            if (this.isPlaying === true) {
                this.source.loop = this.loop;
            }
            return this;
        },
        getVolume: function() {
            return this.gain.gain.value;
        },
        setVolume: function(value) {
            this.gain.gain.value = value;
            return this;
        }
    });
    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    Object.assign(AudioAnalyser.prototype, {
        getFrequencyData: function() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        },
        getAverageFrequency: function() {
            var value = 0, data = this.getFrequencyData();
            for (var i = 0; i < data.length; i++) {
                value += data[i];
            }
            return value / data.length;
        }
    });
    var context;
    var AudioContext = {
        getContext: function() {
            if (context === undefined) {
                context = new (window.AudioContext || window.webkitAudioContext)();
            }
            return context;
        },
        setContext: function(value) {
            context = value;
        }
    };
    function PositionalAudio(listener) {
        Audio.call(this, listener);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain);
    }
    PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
        constructor: PositionalAudio,
        getOutput: function() {
            return this.panner;
        },
        getRefDistance: function() {
            return this.panner.refDistance;
        },
        setRefDistance: function(value) {
            this.panner.refDistance = value;
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function(value) {
            this.panner.rolloffFactor = value;
        },
        getDistanceModel: function() {
            return this.panner.distanceModel;
        },
        setDistanceModel: function(value) {
            this.panner.distanceModel = value;
        },
        getMaxDistance: function() {
            return this.panner.maxDistance;
        },
        setMaxDistance: function(value) {
            this.panner.maxDistance = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3();
            return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                position.setFromMatrixPosition(this.matrixWorld);
                this.panner.setPosition(position.x, position.y, position.z);
            };
        }()
    });
    function AudioListener() {
        Object3D.call(this);
        this.type = "AudioListener";
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
    }
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: AudioListener,
        getInput: function() {
            return this.gain;
        },
        removeFilter: function() {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
        },
        getFilter: function() {
            return this.filter;
        },
        setFilter: function(value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            } else {
                this.gain.disconnect(this.context.destination);
            }
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
        },
        getMasterVolume: function() {
            return this.gain.gain.value;
        },
        setMasterVolume: function(value) {
            this.gain.gain.value = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3();
            var quaternion = new Quaternion();
            var scale = new Vector3();
            var orientation = new Vector3();
            return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener;
                var up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale);
                orientation.set(0, 0, -1).applyQuaternion(quaternion);
                if (listener.positionX) {
                    listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                    listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                    listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                    listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                    listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                    listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                    listener.upX.setValueAtTime(up.x, this.context.currentTime);
                    listener.upY.setValueAtTime(up.y, this.context.currentTime);
                    listener.upZ.setValueAtTime(up.z, this.context.currentTime);
                } else {
                    listener.setPosition(position.x, position.y, position.z);
                    listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
                }
            };
        }()
    });
    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        Geometry.call(this);
        this.type = "BoxGeometry";
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
    }
    BoxGeometry.prototype = Object.create(Geometry.prototype);
    BoxGeometry.prototype.constructor = BoxGeometry;
    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        BufferGeometry.call(this);
        this.type = "BoxBufferGeometry";
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var numberOfVertices = 0;
        var groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var depthHalf = depth / 2;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var vertexCounter = 0;
            var groupCount = 0;
            var ix, iy;
            var vector = new Vector3();
            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    vertices.push(vector.x, vector.y, vector.z);
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    normals.push(vector.x, vector.y, vector.z);
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    vertexCounter += 1;
                }
            }
            for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                    var a = numberOfVertices + ix + gridX1 * iy;
                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
        }
    }
    BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = "CircleGeometry";
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    }
    CircleGeometry.prototype = Object.create(Geometry.prototype);
    CircleGeometry.prototype.constructor = CircleGeometry;
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = "CircleBufferGeometry";
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 50;
        segments = segments !== undefined ? Math.max(3, segments) : 8;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(.5, .5);
        for (s = 0, i = 3; s <= segments; s++, i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        for (i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = "CylinderGeometry";
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = "CylinderBufferGeometry";
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 20;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
        height = height !== undefined ? height : 100;
        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var index = 0;
        var indexOffset = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
            var x, y;
            var normal = new Vector3();
            var vertex = new Vector3();
            var groupCount = 0;
            var slope = (radiusBottom - radiusTop) / height;
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    uvs.push(u, 1 - v);
                    indexRow.push(index++);
                }
                indexArray.push(indexRow);
            }
            for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                    var a = indexArray[y][x];
                    var b = indexArray[y + 1][x];
                    var c = indexArray[y + 1][x + 1];
                    var d = indexArray[y][x + 1];
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
        }
        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd;
            var uv = new Vector2();
            var vertex = new Vector3();
            var groupCount = 0;
            var radius = top === true ? radiusTop : radiusBottom;
            var sign = top === true ? 1 : -1;
            centerIndexStart = index;
            for (x = 1; x <= radialSegments; x++) {
                vertices.push(0, halfHeight * sign, 0);
                normals.push(0, sign, 0);
                uvs.push(.5, .5);
                index++;
            }
            centerIndexEnd = index;
            for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, sign, 0);
                uv.x = cosTheta * .5 + .5;
                uv.y = sinTheta * .5 * sign + .5;
                uvs.push(uv.x, uv.y);
                index++;
            }
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                    indices.push(i, i + 1, c);
                } else {
                    indices.push(i + 1, i, c);
                }
                groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
        }
    }
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = "ConeGeometry";
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
    ConeGeometry.prototype.constructor = ConeGeometry;
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = "ConeBufferGeometry";
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
    function EdgesGeometry(geometry, thresholdAngle) {
        BufferGeometry.call(this);
        this.type = "EdgesGeometry";
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
        var vertices = [];
        var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
        var edge = [ 0, 0 ], edges = {};
        var key, keys = [ "a", "b", "c" ];
        var geometry2;
        if (geometry.isBufferGeometry) {
            geometry2 = new Geometry();
            geometry2.fromBufferGeometry(geometry);
        } else {
            geometry2 = geometry.clone();
        }
        geometry2.mergeVertices();
        geometry2.computeFaceNormals();
        var sourceVertices = geometry2.vertices;
        var faces = geometry2.faces;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge[0] = face[keys[j]];
                edge[1] = face[keys[(j + 1) % 3]];
                edge.sort(sortFunction);
                key = edge.toString();
                if (edges[key] === undefined) {
                    edges[key] = {
                        index1: edge[0],
                        index2: edge[1],
                        face1: i,
                        face2: undefined
                    };
                } else {
                    edges[key].face2 = i;
                }
            }
        }
        for (key in edges) {
            var e = edges[key];
            if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = sourceVertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        function sortFunction(a, b) {
            return a - b;
        }
    }
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
    EdgesGeometry.prototype.constructor = EdgesGeometry;
    var ShapeUtils = {
        area: function(contour) {
            var n = contour.length;
            var a = 0;
            for (var p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return a * .5;
        },
        triangulate: function() {
            function snip(contour, u, v, w, n, verts) {
                var p;
                var ax, ay, bx, by;
                var cx, cy, px, py;
                ax = contour[verts[u]].x;
                ay = contour[verts[u]].y;
                bx = contour[verts[v]].x;
                by = contour[verts[v]].y;
                cx = contour[verts[w]].x;
                cy = contour[verts[w]].y;
                if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0) return false;
                var aX, aY, bX, bY, cX, cY;
                var apx, apy, bpx, bpy, cpx, cpy;
                var cCROSSap, bCROSScp, aCROSSbp;
                aX = cx - bx;
                aY = cy - by;
                bX = ax - cx;
                bY = ay - cy;
                cX = bx - ax;
                cY = by - ay;
                for (p = 0; p < n; p++) {
                    px = contour[verts[p]].x;
                    py = contour[verts[p]].y;
                    if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy) continue;
                    apx = px - ax;
                    apy = py - ay;
                    bpx = px - bx;
                    bpy = py - by;
                    cpx = px - cx;
                    cpy = py - cy;
                    aCROSSbp = aX * bpy - aY * bpx;
                    cCROSSap = cX * apy - cY * apx;
                    bCROSScp = bX * cpy - bY * cpx;
                    if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON) return false;
                }
                return true;
            }
            return function triangulate(contour, indices) {
                var n = contour.length;
                if (n < 3) return null;
                var result = [], verts = [], vertIndices = [];
                var u, v, w;
                if (ShapeUtils.area(contour) > 0) {
                    for (v = 0; v < n; v++) verts[v] = v;
                } else {
                    for (v = 0; v < n; v++) verts[v] = n - 1 - v;
                }
                var nv = n;
                var count = 2 * nv;
                for (v = nv - 1; nv > 2; ) {
                    if (count-- <= 0) {
                        console.warn("SZX3D.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                        if (indices) return vertIndices;
                        return result;
                    }
                    u = v;
                    if (nv <= u) u = 0;
                    v = u + 1;
                    if (nv <= v) v = 0;
                    w = v + 1;
                    if (nv <= w) w = 0;
                    if (snip(contour, u, v, w, nv, verts)) {
                        var a, b, c, s, t;
                        a = verts[u];
                        b = verts[v];
                        c = verts[w];
                        result.push([ contour[a], contour[b], contour[c] ]);
                        vertIndices.push([ verts[u], verts[v], verts[w] ]);
                        for (s = v, t = v + 1; t < nv; s++, t++) {
                            verts[s] = verts[t];
                        }
                        nv--;
                        count = 2 * nv;
                    }
                }
                if (indices) return vertIndices;
                return result;
            };
        }(),
        triangulateShape: function(contour, holes) {
            function removeDupEndPts(points) {
                var l = points.length;
                if (l > 2 && points[l - 1].equals(points[0])) {
                    points.pop();
                }
            }
            removeDupEndPts(contour);
            holes.forEach(removeDupEndPts);
            function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                if (inSegPt1.x !== inSegPt2.x) {
                    if (inSegPt1.x < inSegPt2.x) {
                        return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
                    } else {
                        return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
                    }
                } else {
                    if (inSegPt1.y < inSegPt2.y) {
                        return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
                    } else {
                        return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
                    }
                }
            }
            function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
                var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
                var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
                var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
                var limit = seg1dy * seg2dx - seg1dx * seg2dy;
                var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                if (Math.abs(limit) > Number.EPSILON) {
                    var perpSeg2;
                    if (limit > 0) {
                        if (perpSeg1 < 0 || perpSeg1 > limit) return [];
                        perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                        if (perpSeg2 < 0 || perpSeg2 > limit) return [];
                    } else {
                        if (perpSeg1 > 0 || perpSeg1 < limit) return [];
                        perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                        if (perpSeg2 > 0 || perpSeg2 < limit) return [];
                    }
                    if (perpSeg2 === 0) {
                        if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit)) return [];
                        return [ inSeg1Pt1 ];
                    }
                    if (perpSeg2 === limit) {
                        if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit)) return [];
                        return [ inSeg1Pt2 ];
                    }
                    if (perpSeg1 === 0) return [ inSeg2Pt1 ];
                    if (perpSeg1 === limit) return [ inSeg2Pt2 ];
                    var factorSeg1 = perpSeg2 / limit;
                    return [ {
                        x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                        y: inSeg1Pt1.y + factorSeg1 * seg1dy
                    } ];
                } else {
                    if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy) return [];
                    var seg1Pt = seg1dx === 0 && seg1dy === 0;
                    var seg2Pt = seg2dx === 0 && seg2dy === 0;
                    if (seg1Pt && seg2Pt) {
                        if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y) return [];
                        return [ inSeg1Pt1 ];
                    }
                    if (seg1Pt) {
                        if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) return [];
                        return [ inSeg1Pt1 ];
                    }
                    if (seg2Pt) {
                        if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) return [];
                        return [ inSeg2Pt1 ];
                    }
                    var seg1min, seg1max, seg1minVal, seg1maxVal;
                    var seg2min, seg2max, seg2minVal, seg2maxVal;
                    if (seg1dx !== 0) {
                        if (inSeg1Pt1.x < inSeg1Pt2.x) {
                            seg1min = inSeg1Pt1;
                            seg1minVal = inSeg1Pt1.x;
                            seg1max = inSeg1Pt2;
                            seg1maxVal = inSeg1Pt2.x;
                        } else {
                            seg1min = inSeg1Pt2;
                            seg1minVal = inSeg1Pt2.x;
                            seg1max = inSeg1Pt1;
                            seg1maxVal = inSeg1Pt1.x;
                        }
                        if (inSeg2Pt1.x < inSeg2Pt2.x) {
                            seg2min = inSeg2Pt1;
                            seg2minVal = inSeg2Pt1.x;
                            seg2max = inSeg2Pt2;
                            seg2maxVal = inSeg2Pt2.x;
                        } else {
                            seg2min = inSeg2Pt2;
                            seg2minVal = inSeg2Pt2.x;
                            seg2max = inSeg2Pt1;
                            seg2maxVal = inSeg2Pt1.x;
                        }
                    } else {
                        if (inSeg1Pt1.y < inSeg1Pt2.y) {
                            seg1min = inSeg1Pt1;
                            seg1minVal = inSeg1Pt1.y;
                            seg1max = inSeg1Pt2;
                            seg1maxVal = inSeg1Pt2.y;
                        } else {
                            seg1min = inSeg1Pt2;
                            seg1minVal = inSeg1Pt2.y;
                            seg1max = inSeg1Pt1;
                            seg1maxVal = inSeg1Pt1.y;
                        }
                        if (inSeg2Pt1.y < inSeg2Pt2.y) {
                            seg2min = inSeg2Pt1;
                            seg2minVal = inSeg2Pt1.y;
                            seg2max = inSeg2Pt2;
                            seg2maxVal = inSeg2Pt2.y;
                        } else {
                            seg2min = inSeg2Pt2;
                            seg2minVal = inSeg2Pt2.y;
                            seg2max = inSeg2Pt1;
                            seg2maxVal = inSeg2Pt1.y;
                        }
                    }
                    if (seg1minVal <= seg2minVal) {
                        if (seg1maxVal < seg2minVal) return [];
                        if (seg1maxVal === seg2minVal) {
                            if (inExcludeAdjacentSegs) return [];
                            return [ seg2min ];
                        }
                        if (seg1maxVal <= seg2maxVal) return [ seg2min, seg1max ];
                        return [ seg2min, seg2max ];
                    } else {
                        if (seg1minVal > seg2maxVal) return [];
                        if (seg1minVal === seg2maxVal) {
                            if (inExcludeAdjacentSegs) return [];
                            return [ seg1min ];
                        }
                        if (seg1maxVal <= seg2maxVal) return [ seg1min, seg1max ];
                        return [ seg1min, seg2max ];
                    }
                }
            }
            function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
                var legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y;
                var otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y;
                var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
                var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                if (Math.abs(from2toAngle) > Number.EPSILON) {
                    var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                    if (from2toAngle > 0) {
                        return from2otherAngle >= 0 && other2toAngle >= 0;
                    } else {
                        return from2otherAngle >= 0 || other2toAngle >= 0;
                    }
                } else {
                    return from2otherAngle > 0;
                }
            }
            function removeHoles(contour, holes) {
                var shape = contour.concat();
                var hole;
                function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                    var lastShapeIdx = shape.length - 1;
                    var prevShapeIdx = inShapeIdx - 1;
                    if (prevShapeIdx < 0) prevShapeIdx = lastShapeIdx;
                    var nextShapeIdx = inShapeIdx + 1;
                    if (nextShapeIdx > lastShapeIdx) nextShapeIdx = 0;
                    var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                    if (!insideAngle) {
                        return false;
                    }
                    var lastHoleIdx = hole.length - 1;
                    var prevHoleIdx = inHoleIdx - 1;
                    if (prevHoleIdx < 0) prevHoleIdx = lastHoleIdx;
                    var nextHoleIdx = inHoleIdx + 1;
                    if (nextHoleIdx > lastHoleIdx) nextHoleIdx = 0;
                    insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                    if (!insideAngle) {
                        return false;
                    }
                    return true;
                }
                function intersectsShapeEdge(inShapePt, inHolePt) {
                    var sIdx, nextIdx, intersection;
                    for (sIdx = 0; sIdx < shape.length; sIdx++) {
                        nextIdx = sIdx + 1;
                        nextIdx %= shape.length;
                        intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                        if (intersection.length > 0) return true;
                    }
                    return false;
                }
                var indepHoles = [];
                function intersectsHoleEdge(inShapePt, inHolePt) {
                    var ihIdx, chkHole, hIdx, nextIdx, intersection;
                    for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
                        chkHole = holes[indepHoles[ihIdx]];
                        for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                            nextIdx = hIdx + 1;
                            nextIdx %= chkHole.length;
                            intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                            if (intersection.length > 0) return true;
                        }
                    }
                    return false;
                }
                var holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, failedCuts = [], tmpShape1, tmpShape2, tmpHole1, tmpHole2;
                for (var h = 0, hl = holes.length; h < hl; h++) {
                    indepHoles.push(h);
                }
                var minShapeIndex = 0;
                var counter = indepHoles.length * 2;
                while (indepHoles.length > 0) {
                    counter--;
                    if (counter < 0) {
                        console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                        break;
                    }
                    for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                        shapePt = shape[shapeIndex];
                        holeIndex = -1;
                        for (var h = 0; h < indepHoles.length; h++) {
                            holeIdx = indepHoles[h];
                            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                            if (failedCuts[cutKey] !== undefined) continue;
                            hole = holes[holeIdx];
                            for (var h2 = 0; h2 < hole.length; h2++) {
                                holePt = hole[h2];
                                if (!isCutLineInsideAngles(shapeIndex, h2)) continue;
                                if (intersectsShapeEdge(shapePt, holePt)) continue;
                                if (intersectsHoleEdge(shapePt, holePt)) continue;
                                holeIndex = h2;
                                indepHoles.splice(h, 1);
                                tmpShape1 = shape.slice(0, shapeIndex + 1);
                                tmpShape2 = shape.slice(shapeIndex);
                                tmpHole1 = hole.slice(holeIndex);
                                tmpHole2 = hole.slice(0, holeIndex + 1);
                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                                minShapeIndex = shapeIndex;
                                break;
                            }
                            if (holeIndex >= 0) break;
                            failedCuts[cutKey] = true;
                        }
                        if (holeIndex >= 0) break;
                    }
                }
                return shape;
            }
            var i, il, f, face, key, index, allPointsMap = {};
            var allpoints = contour.concat();
            for (var h = 0, hl = holes.length; h < hl; h++) {
                Array.prototype.push.apply(allpoints, holes[h]);
            }
            for (i = 0, il = allpoints.length; i < il; i++) {
                key = allpoints[i].x + ":" + allpoints[i].y;
                if (allPointsMap[key] !== undefined) {
                    console.warn("SZX3D.ShapeUtils: Duplicate point", key, i);
                }
                allPointsMap[key] = i;
            }
            var shapeWithoutHoles = removeHoles(contour, holes);
            var triangles = ShapeUtils.triangulate(shapeWithoutHoles, false);
            for (i = 0, il = triangles.length; i < il; i++) {
                face = triangles[i];
                for (f = 0; f < 3; f++) {
                    key = face[f].x + ":" + face[f].y;
                    index = allPointsMap[key];
                    if (index !== undefined) {
                        face[f] = index;
                    }
                }
            }
            return triangles.concat();
        },
        isClockWise: function(pts) {
            return ShapeUtils.area(pts) < 0;
        }
    };
    function ExtrudeGeometry(shapes, options) {
        if (typeof shapes === "undefined") {
            shapes = [];
            return;
        }
        Geometry.call(this);
        this.type = "ExtrudeGeometry";
        shapes = Array.isArray(shapes) ? shapes : [ shapes ];
        this.addShapeList(shapes, options);
        this.computeFaceNormals();
    }
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
    ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
        var sl = shapes.length;
        for (var s = 0; s < sl; s++) {
            var shape = shapes[s];
            this.addShape(shape, options);
        }
    };
    ExtrudeGeometry.prototype.addShape = function(shape, options) {
        var amount = options.amount !== undefined ? options.amount : 100;
        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        var steps = options.steps !== undefined ? options.steps : 1;
        var extrudePath = options.extrudePath;
        var extrudePts, extrudeByPath = false;
        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
        var splineTube, binormal, normal, position2;
        if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false;
            splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
        }
        if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
        }
        var ahole, h, hl;
        var scope = this;
        var shapesOffset = this.vertices.length;
        var shapePoints = shape.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            vertices = vertices.reverse();
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                    holes[h] = ahole.reverse();
                }
            }
            reverse = false;
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        var contour = vertices;
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
            if (!vec) console.error("SZX3D.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
        }
        var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
        function getBevelVec(inPt, inPrev, inNext) {
            var v_trans_x, v_trans_y, shrink_by = 1;
            var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
                var v_prev_len = Math.sqrt(v_prev_lensq);
                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                var ptNextShift_y = inNext.y + v_next_x / v_next_len;
                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                    return new Vector2(v_trans_x, v_trans_y);
                } else {
                    shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
            } else {
                var direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                    if (v_next_x > Number.EPSILON) {
                        direction_eq = true;
                    }
                } else {
                    if (v_prev_x < -Number.EPSILON) {
                        if (v_next_x < -Number.EPSILON) {
                            direction_eq = true;
                        }
                    } else {
                        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                            direction_eq = true;
                        }
                    }
                }
                if (direction_eq) {
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        var contourMovements = [];
        for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il) j = 0;
            if (k === il) k = 0;
            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            oneHoleMovements = [];
            for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il) j = 0;
                if (k === il) k = 0;
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (b = 0; b < bevelSegments; b++) {
            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);
            for (i = 0, il = contour.length; i < il; i++) {
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, -z);
            }
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (i = 0, il = ahole.length; i < il; i++) {
                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                    v(vert.x, vert.y, -z);
                }
            }
        }
        bs = bevelSize;
        for (i = 0; i < vlen; i++) {
            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
            } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        var s;
        for (s = 1; s <= steps; s++) {
            for (i = 0; i < vlen; i++) {
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert.x, vert.y, amount / steps * s);
                } else {
                    normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
        }
        for (b = bevelSegments - 1; b >= 0; b--) {
            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);
            for (i = 0, il = contour.length; i < il; i++) {
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, amount + z);
            }
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (i = 0, il = ahole.length; i < il; i++) {
                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, amount + z);
                    } else {
                        v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                    }
                }
            }
        }
        buildLidFaces();
        buildSideFaces();
        function buildLidFaces() {
            if (bevelEnabled) {
                var layer = 0;
                var offset = vlen * layer;
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
            } else {
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[2], face[1], face[0]);
                }
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
            }
        }
        function buildSideFaces() {
            var layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
            }
        }
        function sidewalls(contour, layeroffset) {
            var j, k;
            i = contour.length;
            while (--i >= 0) {
                j = i;
                k = i - 1;
                if (k < 0) k = contour.length - 1;
                var s = 0, sl = steps + bevelSegments * 2;
                for (s = 0; s < sl; s++) {
                    var slen1 = vlen * s;
                    var slen2 = vlen * (s + 1);
                    var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                    f4(a, b, c, d, contour, s, sl, j, k);
                }
            }
        }
        function v(x, y, z) {
            scope.vertices.push(new Vector3(x, y, z));
        }
        function f3(a, b, c) {
            a += shapesOffset;
            b += shapesOffset;
            c += shapesOffset;
            scope.faces.push(new Face3(a, b, c, null, null, 0));
            var uvs = uvgen.generateTopUV(scope, a, b, c);
            scope.faceVertexUvs[0].push(uvs);
        }
        function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
            a += shapesOffset;
            b += shapesOffset;
            c += shapesOffset;
            d += shapesOffset;
            scope.faces.push(new Face3(a, b, d, null, null, 1));
            scope.faces.push(new Face3(b, c, d, null, null, 1));
            var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
            scope.faceVertexUvs[0].push([ uvs[0], uvs[1], uvs[3] ]);
            scope.faceVertexUvs[0].push([ uvs[1], uvs[2], uvs[3] ]);
        }
    };
    ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(geometry, indexA, indexB, indexC) {
            var vertices = geometry.vertices;
            var a = vertices[indexA];
            var b = vertices[indexB];
            var c = vertices[indexC];
            return [ new Vector2(a.x, a.y), new Vector2(b.x, b.y), new Vector2(c.x, c.y) ];
        },
        generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
            var vertices = geometry.vertices;
            var a = vertices[indexA];
            var b = vertices[indexB];
            var c = vertices[indexC];
            var d = vertices[indexD];
            if (Math.abs(a.y - b.y) < .01) {
                return [ new Vector2(a.x, 1 - a.z), new Vector2(b.x, 1 - b.z), new Vector2(c.x, 1 - c.z), new Vector2(d.x, 1 - d.z) ];
            } else {
                return [ new Vector2(a.y, 1 - a.z), new Vector2(b.y, 1 - b.z), new Vector2(c.y, 1 - c.z), new Vector2(d.y, 1 - d.z) ];
            }
        }
    };
    function ShapeGeometry(shapes, curveSegments) {
        Geometry.call(this);
        this.type = "ShapeGeometry";
        if (typeof curveSegments === "object") {
            console.warn("SZX3D.ShapeGeometry: Options parameter has been removed.");
            curveSegments = curveSegments.curveSegments;
        }
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
        this.mergeVertices();
    }
    ShapeGeometry.prototype = Object.create(Geometry.prototype);
    ShapeGeometry.prototype.constructor = ShapeGeometry;
    function ShapeBufferGeometry(shapes, curveSegments) {
        BufferGeometry.call(this);
        this.type = "ShapeBufferGeometry";
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        curveSegments = curveSegments || 12;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var groupStart = 0;
        var groupCount = 0;
        if (Array.isArray(shapes) === false) {
            addShape(shapes);
        } else {
            for (var i = 0; i < shapes.length; i++) {
                addShape(shapes[i]);
                this.addGroup(groupStart, groupCount, i);
                groupStart += groupCount;
                groupCount = 0;
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function addShape(shape) {
            var i, l, shapeHole;
            var indexOffset = vertices.length / 3;
            var points = shape.extractPoints(curveSegments);
            var shapeVertices = points.shape;
            var shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
                shapeVertices = shapeVertices.reverse();
                for (i = 0, l = shapeHoles.length; i < l; i++) {
                    shapeHole = shapeHoles[i];
                    if (ShapeUtils.isClockWise(shapeHole) === true) {
                        shapeHoles[i] = shapeHole.reverse();
                    }
                }
            }
            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (i = 0, l = shapeHoles.length; i < l; i++) {
                shapeHole = shapeHoles[i];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (i = 0, l = shapeVertices.length; i < l; i++) {
                var vertex = shapeVertices[i];
                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y);
            }
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var a = face[0] + indexOffset;
                var b = face[1] + indexOffset;
                var c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this);
        this.type = "LatheGeometry";
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
        this.mergeVertices();
    }
    LatheGeometry.prototype = Object.create(Geometry.prototype);
    LatheGeometry.prototype.constructor = LatheGeometry;
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this);
        this.type = "LatheBufferGeometry";
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;
        phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
        var indices = [];
        var vertices = [];
        var uvs = [];
        var base;
        var inverseSegments = 1 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var i, j;
        for (i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength;
            var sin = Math.sin(phi);
            var cos = Math.cos(phi);
            for (j = 0; j <= points.length - 1; j++) {
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.push(vertex.x, vertex.y, vertex.z);
                uv.x = i / segments;
                uv.y = j / (points.length - 1);
                uvs.push(uv.x, uv.y);
            }
        }
        for (i = 0; i < segments; i++) {
            for (j = 0; j < points.length - 1; j++) {
                base = j + i * points.length;
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        this.computeVertexNormals();
        if (phiLength === Math.PI * 2) {
            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();
            base = segments * points.length * 3;
            for (i = 0, j = 0; i < points.length; i++, j += 3) {
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                n.addVectors(n1, n2).normalize();
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            }
        }
    }
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this);
        this.type = "PlaneGeometry";
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    }
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this);
        this.type = "PlaneBufferGeometry";
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments) || 1;
        var gridY = Math.floor(heightSegments) || 1;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var ix, iy;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
            }
        }
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = ix + 1 + gridX1 * (iy + 1);
                var d = ix + 1 + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = "RingGeometry";
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    }
    RingGeometry.prototype = Object.create(Geometry.prototype);
    RingGeometry.prototype.constructor = RingGeometry;
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = "RingBufferGeometry";
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        innerRadius = innerRadius || 20;
        outerRadius = outerRadius || 50;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var segment;
        var radius = innerRadius;
        var radiusStep = (outerRadius - innerRadius) / phiSegments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++) {
                segment = thetaStart + i / thetaSegments * thetaLength;
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, 0, 1);
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
        }
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = "SphereGeometry";
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    }
    SphereGeometry.prototype = Object.create(Geometry.prototype);
    SphereGeometry.prototype.constructor = SphereGeometry;
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = "SphereBufferGeometry";
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 50;
        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        var thetaEnd = thetaStart + thetaLength;
        var ix, iy;
        var index = 0;
        var grid = [];
        var vertex = new Vector3();
        var normal = new Vector3();
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (iy = 0; iy <= heightSegments; iy++) {
            var verticesRow = [];
            var v = iy / heightSegments;
            for (ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.set(vertex.x, vertex.y, vertex.z).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        for (iy = 0; iy < heightSegments; iy++) {
            for (ix = 0; ix < widthSegments; ix++) {
                var a = grid[iy][ix + 1];
                var b = grid[iy][ix];
                var c = grid[iy + 1][ix];
                var d = grid[iy + 1][ix + 1];
                if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
    function TextGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if ((font && font.isFont) === false) {
            console.error("SZX3D.TextGeometry: font parameter is not an instance of SZX3D.Font.");
            return new Geometry();
        }
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        parameters.amount = parameters.height !== undefined ? parameters.height : 50;
        if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
        ExtrudeGeometry.call(this, shapes, parameters);
        this.type = "TextGeometry";
    }
    TextGeometry.prototype = Object.create(ExtrudeGeometry.prototype);
    TextGeometry.prototype.constructor = TextGeometry;
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this);
        this.type = "TorusGeometry";
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    }
    TorusGeometry.prototype = Object.create(Geometry.prototype);
    TorusGeometry.prototype.constructor = TorusGeometry;
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this);
        this.type = "TorusBufferGeometry";
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radius = radius || 100;
        tube = tube || 40;
        radialSegments = Math.floor(radialSegments) || 8;
        tubularSegments = Math.floor(tubularSegments) || 6;
        arc = arc || Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();
        var j, i;
        for (j = 0; j <= radialSegments; j++) {
            for (i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices.push(vertex.x, vertex.y, vertex.z);
                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= radialSegments; j++) {
            for (i = 1; i <= tubularSegments; i++) {
                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this);
        this.type = "TorusKnotGeometry";
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        if (heightScale !== undefined) console.warn("SZX3D.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
        this.mergeVertices();
    }
    TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        BufferGeometry.call(this);
        this.type = "TorusKnotBufferGeometry";
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        radius = radius || 100;
        tube = tube || 40;
        tubularSegments = Math.floor(tubularSegments) || 64;
        radialSegments = Math.floor(radialSegments) || 8;
        p = p || 2;
        q = q || 3;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var i, j;
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var P1 = new Vector3();
        var P2 = new Vector3();
        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();
        for (i = 0; i <= tubularSegments; ++i) {
            var u = i / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + .01, p, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (j = 0; j <= radialSegments; ++j) {
                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.subVectors(vertex, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= tubularSegments; j++) {
            for (i = 1; i <= radialSegments; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u);
            var su = Math.sin(u);
            var quOverP = q / p * u;
            var cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * .5 * cu;
            position.y = radius * (2 + cs) * su * .5;
            position.z = radius * Math.sin(quOverP) * .5;
        }
    }
    TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this);
        this.type = "TubeGeometry";
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        if (taper !== undefined) console.warn("SZX3D.TubeGeometry: taper has been removed.");
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;
        this.fromBufferGeometry(bufferGeometry);
        this.mergeVertices();
    }
    TubeGeometry.prototype = Object.create(Geometry.prototype);
    TubeGeometry.prototype.constructor = TubeGeometry;
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        BufferGeometry.call(this);
        this.type = "TubeBufferGeometry";
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var i, j;
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        generateBufferData();
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateBufferData() {
            for (i = 0; i < tubularSegments; i++) {
                generateSegment(i);
            }
            generateSegment(closed === false ? tubularSegments : 0);
            generateUVs();
            generateIndices();
        }
        function generateSegment(i) {
            var P = path.getPointAt(i / tubularSegments);
            var N = frames.normals[i];
            var B = frames.binormals[i];
            for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);
                normal.x = cos * N.x + sin * B.x;
                normal.y = cos * N.y + sin * B.y;
                normal.z = cos * N.z + sin * B.z;
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }
        function generateUVs() {
            for (i = 0; i <= tubularSegments; i++) {
                for (j = 0; j <= radialSegments; j++) {
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.push(uv.x, uv.y);
                }
            }
        }
    }
    TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this);
        this.type = "PolyhedronGeometry";
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
        this.mergeVertices();
    }
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        BufferGeometry.call(this);
        this.type = "PolyhedronBufferGeometry";
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        radius = radius || 1;
        detail = detail || 0;
        var vertexBuffer = [];
        var uvBuffer = [];
        subdivide(detail);
        appplyRadius(radius);
        generateUVs();
        this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
        this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
        this.normalizeNormals();
        function subdivide(detail) {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            for (var i = 0; i < indices.length; i += 3) {
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                subdivideFace(a, b, c, detail);
            }
        }
        function subdivideFace(a, b, c, detail) {
            var cols = Math.pow(2, detail);
            var v = [];
            var i, j;
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                    if (j === 0 && i === cols) {
                        v[i][j] = aj;
                    } else {
                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }
            for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    if (j % 2 === 0) {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k]);
                        pushVertex(v[i][k]);
                    } else {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k + 1]);
                        pushVertex(v[i + 1][k]);
                    }
                }
            }
        }
        function appplyRadius(radius) {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }
        function generateUVs() {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + .5;
                var v = inclination(vertex) / Math.PI + .5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);
                if (max > .9 && min < .1) {
                    if (x0 < .2) uvBuffer[i + 0] += 1;
                    if (x1 < .2) uvBuffer[i + 2] += 1;
                    if (x2 < .2) uvBuffer[i + 4] += 1;
                }
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            var centroid = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if (azimuth < 0 && uv.x === 1) {
                uvBuffer[stride] = uv.x - 1;
            }
            if (vector.x === 0 && vector.z === 0) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + .5;
            }
        }
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = "DodecahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;
        var vertices = [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r ];
        var indices = [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = "DodecahedronBufferGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = "IcosahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1 ];
        var indices = [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = "IcosahedronBufferGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
    function OctahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = "OctahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    OctahedronGeometry.prototype = Object.create(Geometry.prototype);
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ];
        var indices = [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = "OctahedronBufferGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = "TetrahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ];
        var indices = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = "TetrahedronBufferGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this);
        this.type = "ParametricGeometry";
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
        this.mergeVertices();
    }
    ParametricGeometry.prototype = Object.create(Geometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;
    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this);
        this.type = "ParametricBufferGeometry";
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        var indices = [];
        var vertices = [];
        var uvs = [];
        var i, j;
        var sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            var v = i / stacks;
            for (j = 0; j <= slices; j++) {
                var u = j / slices;
                var p = func(u, v);
                vertices.push(p.x, p.y, p.z);
                uvs.push(u, v);
            }
        }
        for (i = 0; i < stacks; i++) {
            for (j = 0; j < slices; j++) {
                var a = i * sliceCount + j;
                var b = i * sliceCount + j + 1;
                var c = (i + 1) * sliceCount + j + 1;
                var d = (i + 1) * sliceCount + j;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
        this.computeVertexNormals();
    }
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
    function WireframeGeometry(geometry) {
        BufferGeometry.call(this);
        this.type = "WireframeGeometry";
        var vertices = [];
        var i, j, l, o, ol;
        var edge = [ 0, 0 ], edges = {}, e;
        var key, keys = [ "a", "b", "c" ];
        var vertex;
        if (geometry && geometry.isGeometry) {
            var faces = geometry.faces;
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (j = 0; j < 3; j++) {
                    edge[0] = face[keys[j]];
                    edge[1] = face[keys[(j + 1) % 3]];
                    edge.sort(sortFunction);
                    key = edge.toString();
                    if (edges[key] === undefined) {
                        edges[key] = {
                            index1: edge[0],
                            index2: edge[1]
                        };
                    }
                }
            }
            for (key in edges) {
                e = edges[key];
                vertex = geometry.vertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = geometry.vertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        } else if (geometry && geometry.isBufferGeometry) {
            var position, indices, groups;
            var group, start, count;
            var index1, index2;
            vertex = new Vector3();
            if (geometry.index !== null) {
                position = geometry.attributes.position;
                indices = geometry.index;
                groups = geometry.groups;
                if (groups.length === 0) {
                    geometry.addGroup(0, indices.count);
                }
                for (o = 0, ol = groups.length; o < ol; ++o) {
                    group = groups[o];
                    start = group.start;
                    count = group.count;
                    for (i = start, l = start + count; i < l; i += 3) {
                        for (j = 0; j < 3; j++) {
                            edge[0] = indices.getX(i + j);
                            edge[1] = indices.getX(i + (j + 1) % 3);
                            edge.sort(sortFunction);
                            key = edge.toString();
                            if (edges[key] === undefined) {
                                edges[key] = {
                                    index1: edge[0],
                                    index2: edge[1]
                                };
                            }
                        }
                    }
                }
                for (key in edges) {
                    e = edges[key];
                    vertex.fromBufferAttribute(position, e.index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex.fromBufferAttribute(position, e.index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            } else {
                position = geometry.attributes.position;
                for (i = 0, l = position.count / 3; i < l; i++) {
                    for (j = 0; j < 3; j++) {
                        index1 = 3 * i + j;
                        vertex.fromBufferAttribute(position, index1);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        index2 = 3 * i + (j + 1) % 3;
                        vertex.fromBufferAttribute(position, index2);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                }
            }
        }
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        function sortFunction(a, b) {
            return a - b;
        }
    }
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
    WireframeGeometry.prototype.constructor = WireframeGeometry;
    var Geometries = Object.freeze({
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        TextGeometry: TextGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        WireframeGeometry: WireframeGeometry
    });
    function Scene() {
        Object3D.call(this);
        this.type = "Scene";
        this.background = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
    }
    Scene.prototype = Object.create(Object3D.prototype);
    Scene.prototype.constructor = Scene;
    Scene.prototype.copy = function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    };
    Scene.prototype.toJSON = function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        if (this.background !== null) data.object.background = this.background.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    };
    function Fog(color, near, far) {
        this.name = "";
        this.color = new Color(color);
        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1e3;
    }
    Fog.prototype.isFog = true;
    Fog.prototype.clone = function() {
        return new Fog(this.color.getHex(), this.near, this.far);
    };
    Fog.prototype.toJSON = function(meta) {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    };
    function FogExp2(color, density) {
        this.name = "";
        this.color = new Color(color);
        this.density = density !== undefined ? density : 25e-5;
    }
    FogExp2.prototype.isFogExp2 = true;
    FogExp2.prototype.clone = function() {
        return new FogExp2(this.color.getHex(), this.density);
    };
    FogExp2.prototype.toJSON = function(meta) {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    };
    var textureId = 0;
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, "id", {
            value: textureId++
        });
        this.uuid = _Math.generateUUID();
        this.name = "";
        this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
        this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.format = format !== undefined ? format : RGBAFormat;
        this.type = type !== undefined ? type : UnsignedByteType;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding !== undefined ? encoding : LinearEncoding;
        this.version = 0;
        this.onUpdate = null;
    }
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = {
        constructor: Texture,
        isTexture: true,
        set needsUpdate(value) {
            if (value === true) this.version++;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
            if (source.onUpdate) this.onUpdate = source.onUpdate;
            return this;
        },
        toJSON: function(meta) {
            if (meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
            }
            function getDataURL(image) {
                var canvas;
                if (image.toDataURL !== undefined) {
                    canvas = image;
                } else {
                    canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height);
                }
                if (canvas.width > 2048 || canvas.height > 2048) {
                    return canvas.toDataURL("image/jpeg", .6);
                } else {
                    return canvas.toDataURL("image/png");
                }
            }
            var output = {
                metadata: {
                    version: 4.4,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [ this.repeat.x, this.repeat.y ],
                offset: [ this.offset.x, this.offset.y ],
                wrap: [ this.wrapS, this.wrapT ],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (this.image !== undefined) {
                var image = this.image;
                if (image.uuid === undefined) {
                    image.uuid = _Math.generateUUID();
                }
                if (meta.images[image.uuid] === undefined) {
                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: getDataURL(image)
                    };
                }
                output.image = image.uuid;
            }
            meta.textures[this.uuid] = output;
            return output;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        },
        transformUv: function(uv) {
            if (this.mapping !== UVMapping) return;
            uv.multiply(this.repeat);
            uv.add(this.offset);
            if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;

                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                        uv.x = Math.ceil(uv.x) - uv.x;
                    } else {
                        uv.x = uv.x - Math.floor(uv.x);
                    }
                    break;
                }
            }
            if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;

                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                        uv.y = Math.ceil(uv.y) - uv.y;
                    } else {
                        uv.y = uv.y - Math.floor(uv.y);
                    }
                    break;
                }
            }
            if (this.flipY) {
                uv.y = 1 - uv.y;
            }
        }
    };
    Object.assign(Texture.prototype, EventDispatcher.prototype);
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== undefined ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either SZX3D.DepthFormat or SZX3D.DepthStencilFormat");
        }
        if (type === undefined && format === DepthFormat) type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = {
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
    }
    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;
    CubeTexture.prototype.isCubeTexture = true;
    Object.defineProperty(CubeTexture.prototype, "images", {
        get: function() {
            return this.image;
        },
        set: function(value) {
            this.image = value;
        }
    });
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            width: width,
            height: height
        };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;
    CompressedTexture.prototype.isCompressedTexture = true;
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            data: data,
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;
    DataTexture.prototype.isDataTexture = true;
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.generateMipmaps = false;
        var scope = this;
        function update() {
            requestAnimationFrame(update);
            if (video.readyState >= video.HAVE_CURRENT_DATA) {
                scope.needsUpdate = true;
            }
        }
        update();
    }
    VideoTexture.prototype = Object.create(Texture.prototype);
    VideoTexture.prototype.constructor = VideoTexture;
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    var begin_vertex = "\nvec3 transformed = vec3( position );\n";
    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
    var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
    var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
    var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
    var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
    var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
    var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
    var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";
    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
    var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
    var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
    var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
    var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
    var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";
    var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars: lights_pars,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_template: lights_template,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_flip: normal_flip,
        normal_fragment: normal_fragment,
        normalmap_pars_fragment: normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert
    };
    var UniformsUtils = {
        merge: function(uniforms) {
            var merged = {};
            for (var u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) {
                    merged[p] = tmp[p];
                }
            }
            return merged;
        },
        clone: function(uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
                        if (parameter_src.onUpdate) {
                            uniforms_dst[u][p] = parameter_src;
                        } else {
                            uniforms_dst[u][p] = parameter_src.clone();
                        }
                    } else if (Array.isArray(parameter_src)) {
                        uniforms_dst[u][p] = parameter_src.slice(0);
                    } else {
                        uniforms_dst[u][p] = parameter_src;
                    }
                }
            }
            return uniforms_dst;
        }
    };
    var UniformsLib = {
        common: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new Vector4(0, 0, 1, 1)
            },
            specularMap: {
                value: null
            },
            alphaMap: {
                value: null
            },
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new Vector4(0, 0, 1, 1)
            }
        }
    };
    (function() {
        var LTC_MAT = [ 2e-4, -0, 1, -0, 504e-6, -0, 1, -0, .002016, -0, 1, -0, .004535, -0, 1, -0, .008063, -0, 1, -0, .012598, -0, 1, -0, .018141, -0, 1, -0, .024692, -0, 1, -0, .032252, -0, 1, -0, .040821, -0, 1, -0, .0504, -0, 1, -0, .060989, -0, 1, -0, .072591, -0, 1, -0, .085206, -0, 1, -0, .098836, -0, 1, -0, .113483, -0, 1, -0, .129147, -0, 1, -0, .145828, -0, 1, -0, .163499, -0, 1, -0, .181972, -0, 1, -0, .199498, -0, 1, -0, .220031, -0, 1, -0, .241588, -0, 1, -0, .26412, -0, 1, -0, .287521, -0, 1, -0, .311478, -0, 1, -0, .335127, -0, 1, -0, .359811, -0, 1, -0, .386446, -0, 1, -0, .413161, -0, 1, -0, .439142, -0, 1, -0, .467039, -0, 1, -0, .49517, -0, 1, -0, .522324, -0, 1, -0, .551482, -0, 1, -0, .579621, -0, 1, -0, .608255, -0, 1, -0, .636515, -0, 1, -0, .664835, -0, 1, -0, .692549, -0, 1, -0, .720375, -0, 1, -0, .747238, -0, 1, -0, .773956, -0, 1, -0, .799879, -0, 1, -0, .824889, -0, 1, -0, .849357, -0, 1, -0, .873016, -0, 1, -0, .89567, -0, 1, -0, .917194, -0, 1, -0, .937978, -0, 1, -0, .957872, -0, 1, -0, .976736, -0, 1, -0, .994433, -0, 1, -0, 1.011206, -0, 1, -0, 1.02682, -0, 1, -0, 1.04172, -0, 1, -0, 1.055657, -0, 1, -0, 1.068642, -0, 1, -0, 1.080646, -0, 1, -0, 1.091637, -0, 1, -0, 1.101837, -0, 1, -0, 1.111292, -0, 1, -0, 1.120025, -0, 1, -0, 1.127918, -0, 1, -0, 2e-4, -5e-6, 1.000623, .024938, 504e-6, -13e-6, 1.000643, .024938, .002016, -5e-5, 1.000618, .024938, .004535, -113e-6, 1.000621, .024938, .008063, -201e-6, 1.000746, .024938, .012596, -314e-6, 1.000463, .024937, .01814, -452e-6, 1.000511, .024939, .024693, -616e-6, 1.000541, .024938, .032253, -804e-6, 1.000684, .024938, .040815, -.001018, 1.000524, .02494, .050399, -.001257, 1.000582, .024937, .060989, -.001521, 1.000655, .024937, .072591, -.00181, 1.000608, .024938, .085204, -.002125, 1.000622, .024939, .098835, -.002465, 1.000632, .024937, .113483, -.00283, 1.00064, .024939, .129143, -.00322, 1.000568, .024938, .14583, -.003633, 1.000635, .024938, .163497, -.004062, 1.000626, .024938, .181956, -.004424, 1.000612, .024924, .199791, -.004593, 1.000627, .02489, .220029, -.00548, 1.000594, .024935, .241586, -.00601, 1.000616, .024933, .264115, -.00655, 1.000607, .024927, .287514, -.007072, 1.000595, .024909, .311455, -.007472, 1.000616, .024872, .335083, -.007491, 1.000589, .024755, .359805, -.00881, 1.000601, .024877, .386438, -.009282, 1.00064, .024824, .413131, -.009534, 1.000599, .024708, .439249, -.009701, 1.000497, .024573, .466997, -.010878, 1.000467, .024652, .495138, -.010959, 1.000539, .024455, .522654, -.011386, 1.000518, .024318, .551415, -.012022, 1.000533, .024216, .57961, -.011805, 1.000495, .023867, .608185, -.012773, 1.000474, .023834, .636492, -.012377, 1.000488, .023327, .664826, -.013172, 1.000576, .023205, .692674, -.012847, 1.000505, .022708, .720341, -.013141, 1.000424, .022349, .747373, -.013227, 1.000449, .021871, .77398, -.012739, 1.000478, .021171, .799839, -.012999, 1.000396, .020606, .825113, -.012727, 1.000425, .020006, .849579, -.01217, 1.000469, .019089, .873046, -.011855, 1.000411, .018291, .895777, -.011711, 1.000426, .017534, .917518, -.011107, 1.000373, .016542, .938264, -.010439, 1.000322, .015512, .958032, -.009807, 1.000324, .014491, .976838, -.009268, 1.000341, .013468, .994631, -.008662, 1.000318, .012376, 1.011434, -.007923, 1.000289, .011187, 1.027169, -.007132, 1.000216, .010078, 1.041929, -.006332, 1.000096, .008924, 1.055767, -.005554, 1.000156, .00777, 1.068595, -.004811, 1.000084, .006611, 1.080612, -.00395, 1.000047, .005485, 1.091785, -.003174, 1.000109, .004352, 1.101998, -.002363, 1.000029, .00318, 1.111423, -.001552, .999985, .002091, 1.120007, -786e-6, .999947, 991e-6, 1.127918, 4e-6, 1, -4e-6, 2e-4, -1e-5, 1.002495, .049907, 504e-6, -25e-6, 1.002476, .049908, .002016, -101e-6, 1.0025, .049908, .004535, -226e-6, 1.002487, .049908, .008062, -402e-6, 1.002364, .049908, .012598, -629e-6, 1.002412, .049908, .01814, -905e-6, 1.002379, .049908, .024691, -.001232, 1.00249, .049907, .032251, -.00161, 1.002398, .049908, .040821, -.002037, 1.002392, .049908, .050398, -.002515, 1.002431, .049907, .060989, -.003044, 1.002475, .049908, .072592, -.003623, 1.002546, .049907, .085204, -.004252, 1.002467, .049907, .098832, -.004932, 1.00245, .049908, .113481, -.005663, 1.002482, .049907, .129145, -.006443, 1.002443, .049907, .145825, -.007271, 1.002495, .049906, .163491, -.008128, 1.002475, .049903, .181911, -.008826, 1.002459, .049879, .200065, -.009285, 1.002443, .049824, .220025, -.010966, 1.00245, .049897, .241581, -.012025, 1.002463, .049893, .264099, -.013105, 1.002395, .049881, .287493, -.014145, 1.00239, .049855, .311399, -.014925, 1.002414, .049769, .335096, -.015239, 1.002363, .049591, .359815, -.017559, 1.002415, .049777, .386365, -.018554, 1.002354, .049675, .413017, -.019043, 1.002297, .049444, .439519, -.019815, 1.002284, .049253, .466938, -.021741, 1.002307, .049327, .494999, -.021887, 1.002181, .048922, .522922, -.022844, 1.002107, .048677, .55127, -.024014, 1.002101, .048478, .579771, -.024156, 1.00206, .047904, .608156, -.025317, 1.002077, .047594, .636662, -.025321, 1.001975, .046876, .664846, -.026018, 1.001992, .046354, .692877, -.026041, 1.001846, .045504, .720316, -.026252, 1.001846, .044655, .747658, -.026159, 1.001931, .04367, .774252, -.026086, 1.001845, .042515, .800179, -.025653, 1.001794, .041211, .825525, -.02517, 1.001787, .039823, .850013, -.024788, 1.001806, .038409, .873593, -.023992, 1.001688, .036767, .896343, -.022985, 1.001666, .0349, .918062, -.022005, 1.001548, .03301, .938928, -.02111, 1.001503, .031143, .958667, -.019893, 1.001341, .029059, .977457, -.018546, 1.001194, .026888, .995243, -.017152, 1.001095, .024713, 1.012023, -.01575, 1.0011, .022496, 1.027614, -.014289, 1.000851, .020153, 1.042389, -.012688, 1.000724, .017839, 1.056161, -.011118, 1.000572, .015529, 1.068968, -.00954, 1.000407, .01324, 1.080866, -.007963, 1.000258, .01094, 1.091944, -.006416, 1.000254, .008716, 1.102104, -.004771, 1.000175, .006434, 1.111571, -.003056, 1.000148, .004169, 1.120084, -.001458, 1.00005, .002033, 1.127981, 21e-6, .999987, -27e-6, 2e-4, -15e-6, 1.00562, .07494, 504e-6, -38e-6, 1.00565, .074939, .002016, -151e-6, 1.005613, .074939, .004535, -34e-5, 1.005618, .074939, .008062, -604e-6, 1.005614, .074939, .012597, -944e-6, 1.005616, .07494, .018141, -.001359, 1.005558, .074939, .024695, -.001851, 1.005495, .07494, .032253, -.002417, 1.005616, .074939, .040822, -.003059, 1.005591, .07494, .050399, -.003777, 1.005596, .07494, .060989, -.00457, 1.005599, .074939, .072591, -.00544, 1.005616, .07494, .085203, -.006385, 1.005616, .074939, .098833, -.007406, 1.005595, .074938, .113481, -.008502, 1.005605, .074938, .129147, -.009674, 1.005605, .074937, .145817, -.010916, 1.005513, .074937, .163485, -.012199, 1.005579, .074928, .181824, -.013172, 1.005552, .074885, .200274, -.0141, 1.005524, .074825, .220017, -.016464, 1.005529, .074928, .241568, -.018052, 1.00549, .074914, .264084, -.019671, 1.005457, .074898, .28745, -.021217, 1.005431, .07486, .311281, -.022341, 1.005395, .074717, .335228, -.023296, 1.00532, .074526, .360047, -.025965, 1.005302, .074649, .386273, -.027808, 1.005285, .074575, .412855, -.028504, 1.005167, .074237, .439705, -.030007, 1.005129, .074013, .466975, -.032263, 1.005082, .073967, .494874, -.032931, 1.00496, .073475, .523066, -.034348, 1.004834, .073084, .551198, -.035739, 1.004806, .072657, .579889, -.036575, 1.004687, .072029, .608282, -.037434, 1.004605, .071309, .636812, -.038323, 1.004589, .070507, .66501, -.038676, 1.004403, .069424, .693063, -.039237, 1.00434, .06837, .72075, -.039332, 1.004224, .066988, .747911, -.039179, 1.004117, .065447, .774576, -.03911, 1.004035, .063838, .800737, -.038542, 1.004027, .061923, .825966, -.037966, 1.003825, .059859, .850534, -.036943, 1.003786, .057529, .874289, -.035853, 1.00356, .055081, .897152, -.03473, 1.003549, .052476, .919029, -.033242, 1.003454, .049647, .939851, -.031508, 1.003215, .04667, .959599, -.029695, 1.002916, .043588, .978293, -.027845, 1.00272, .040401, .996085, -.025775, 1.002445, .03706, 1.012768, -.023607, 1.002133, .033726, 1.028404, -.021374, 1.001822, .030217, 1.04315, -.019108, 1.001602, .02682, 1.05676, -.016823, 1.001274, .023372, 1.069471, -.014378, 1.000964, .019891, 1.081283, -.011884, 1.000684, .016405, 1.092238, -.009398, 1.000514, .01295, 1.102384, -.00703, 1.000319, .009579, 1.111737, -.004751, 1.000225, .006384, 1.120274, -.002404, 1.000046, .003192, 1.128182, 31e-6, 1.00002, 33e-6, 2e-4, -2e-5, 1.010006, .100065, 504e-6, -5e-5, 1.009927, .100065, .002016, -202e-6, 1.010026, .100064, .004535, -454e-6, 1.010018, .100065, .008062, -807e-6, 1.009891, .100064, .012599, -.001261, 1.010175, .100064, .018141, -.001815, 1.010067, .100065, .024692, -.002471, 1.010014, .100066, .032251, -.003227, 1.00995, .100065, .040818, -.004084, 1.009963, .100067, .050401, -.005043, 1.010032, .100064, .060988, -.006102, 1.009979, .100064, .072588, -.007263, 1.009984, .100063, .085205, -.008525, 1.010023, .100063, .098832, -.009888, 1.00996, .100062, .113479, -.011352, 1.009974, .100063, .129142, -.012916, 1.009945, .100062, .145817, -.014573, 1.009924, .100058, .163468, -.016276, 1.009912, .10005, .181674, -.017411, 1.009859, .099975, .200435, -.019002, 1.009842, .099932, .220005, -.021978, 1.00982, .100043, .24155, -.024096, 1.009778, .100031, .264058, -.02625, 1.009765, .100002, .287399, -.028286, 1.009724, .099939, .311134, -.029698, 1.009596, .099748, .33535, -.031442, 1.009508, .099582, .360295, -.034401, 1.009475, .099613, .386112, -.03703, 1.009329, .099558, .412733, -.038163, 1.00925, .099137, .439833, -.04025, 1.009125, .098866, .467099, -.042583, 1.009011, .098626, .494828, -.044299, 1.008803, .098149, .523217, -.045876, 1.008712, .0976, .551338, -.04744, 1.008509, .096929, .579917, -.048995, 1.008371, .096178, .608454, -.049901, 1.008212, .095145, .636785, -.051224, 1.007963, .094151, .66522, -.051675, 1.007741, .092728, .693194, -.052278, 1.007616, .091195, .721008, -.052406, 1.007327, .089384, .748196, -.052529, 1.007219, .087461, .774975, -.05195, 1.006851, .085133, .801129, -.051456, 1.006732, .082628, .826668, -.050569, 1.006612, .079817, .851291, -.049328, 1.006374, .07671, .875056, -.047988, 1.006183, .073481, .897872, -.046149, 1.005742, .069943, .919803, -.044144, 1.005514, .066151, .940701, -.042095, 1.005153, .062247, .96058, -.03973, 1.004843, .058158, .979427, -.037104, 1.004535, .05385, .997157, -.034369, 1.004023, .049403, 1.013777, -.031555, 1.003622, .044944, 1.029452, -.028571, 1.003212, .040414, 1.044029, -.025416, 1.002698, .035723, 1.057586, -.022217, 1.002202, .031072, 1.070148, -.019037, 1.001703, .026429, 1.081875, -.015936, 1.001322, .021896, 1.092789, -.012734, 1.001053, .017288, 1.102704, -.009454, 1.000604, .012841, 1.112011, -.006199, 1.000387, .008446, 1.12059, -.00301, 1.000166, .004122, 1.128283, 27e-6, .999956, -38e-6, 2e-4, -25e-6, 1.015664, .125315, 504e-6, -63e-6, 1.015664, .125316, .002016, -253e-6, 1.015727, .125315, .004535, -568e-6, 1.015695, .125314, .008063, -.00101, 1.015823, .125316, .012599, -.001579, 1.015867, .125315, .018141, -.002273, 1.015758, .125316, .024691, -.003094, 1.015662, .125316, .032252, -.004042, 1.015674, .125316, .04082, -.005115, 1.015678, .125316, .0504, -.006316, 1.015684, .125315, .060989, -.007642, 1.015685, .125315, .07259, -.009096, 1.015703, .125314, .085203, -.010676, 1.015654, .125314, .098833, -.012383, 1.01567, .125315, .113477, -.014215, 1.015635, .125312, .129138, -.016173, 1.015599, .125311, .145815, -.018246, 1.01561, .125306, .16345, -.02036, 1.015564, .125294, .181595, -.021807, 1.01546, .125204, .200563, -.023971, 1.01544, .125165, .220186, -.02728, 1.015412, .12525, .241528, -.030164, 1.015342, .125267, .26402, -.032847, 1.015269, .125233, .287311, -.035345, 1.015232, .125138, .310993, -.037108, 1.015063, .124903, .335467, -.039653, 1.01497, .124749, .360497, -.042914, 1.014819, .124702, .385986, -.046142, 1.014685, .124623, .412703, -.04805, 1.014543, .124193, .439929, -.050527, 1.014315, .123833, .467163, -.05288, 1.014087, .123375, .494824, -.055672, 1.013898, .122982, .523222, -.057388, 1.013647, .122166, .551557, -.059328, 1.013403, .121343, .579884, -.061315, 1.013059, .12043, .608619, -.062531, 1.012745, .11914, .637014, -.063778, 1.012425, .117721, .665425, -.064734, 1.012067, .116069, .69358, -.065315, 1.011712, .114146, .721194, -.065535, 1.0112, .111846, .748586, -.065501, 1.010896, .109309, .775437, -.065091, 1.010576, .106504, .801554, -.064332, 1.010136, .103308, .827079, -.063078, 1.009629, .099695, .851693, -.061728, 1.009233, .095946, .875586, -.059853, 1.008726, .091802, .898589, -.057727, 1.008412, .087339, .920421, -.055377, 1.007767, .082687, .941533, -.052571, 1.007529, .077716, .961426, -.049544, 1.006929, .072574, .980287, -.0464, 1.006393, .067217, .99808, -.042966, 1.005872, .061757, 1.01494, -.039321, 1.005346, .056072, 1.030455, -.035585, 1.004609, .05041, 1.045078, -.031823, 1.004151, .044622, 1.058555, -.027947, 1.003421, .038893, 1.071009, -.023891, 1.002704, .032977, 1.082594, -.019822, 1.002023, .02729, 1.093265, -.015765, 1.001403, .021543, 1.103132, -.01179, 1.000944, .016072, 1.112348, -.007784, 1.00055, .010511, 1.120845, -.003849, 1.000224, .005174, 1.128573, 57e-6, .999975, -39e-6, 2e-4, -3e-5, 1.022609, .150725, 504e-6, -76e-6, 1.022728, .150725, .002016, -304e-6, 1.022728, .150725, .004535, -684e-6, 1.022733, .150725, .008062, -.001215, 1.022715, .150725, .012598, -.001899, 1.02272, .150725, .018141, -.002734, 1.022659, .150725, .024694, -.003722, 1.022801, .150724, .032254, -.004861, 1.022779, .150726, .040815, -.006152, 1.022693, .150724, .0504, -.007596, 1.022716, .150725, .06099, -.009192, 1.022733, .150725, .072587, -.010939, 1.02263, .150723, .085203, -.012839, 1.022676, .150725, .098828, -.014891, 1.022659, .150725, .113473, -.017095, 1.022589, .15072, .129137, -.019449, 1.022572, .150716, .145803, -.021938, 1.022508, .150712, .163417, -.024443, 1.022471, .150691, .18158, -.026329, 1.022406, .1506, .200667, -.028997, 1.022336, .150553, .220429, -.032584, 1.022296, .15061, .241497, -.03626, 1.022202, .150658, .263975, -.039465, 1.022119, .150619, .28721, -.042385, 1.021988, .15049, .310935, -.044758, 1.021771, .150241, .335556, -.047922, 1.021658, .150076, .360667, -.051493, 1.021437, .149931, .386028, -.054931, 1.021228, .149754, .412665, -.058007, 1.021023, .1494, .439951, -.060813, 1.020723, .148913, .467262, -.063461, 1.020332, .148319, .494972, -.066738, 1.020097, .147798, .523153, -.068976, 1.01963, .146903, .5517, -.071268, 1.019245, .145863, .580046, -.073439, 1.018797, .144695, .608649, -.075193, 1.018201, .143237, .637239, -.076536, 1.017746, .141463, .665388, -.077771, 1.017111, .139462, .693755, -.078344, 1.016609, .137082, .721345, -.078817, 1.015863, .134403, .748879, -.078512, 1.01539, .131252, .77556, -.078128, 1.014652, .127866, .801897, -.077094, 1.013877, .123928, .827193, -.075863, 1.013021, .119733, .85199, -.073973, 1.012395, .115055, .875823, -.071765, 1.011595, .110098, .898655, -.069241, 1.010862, .104722, .920915, -.066232, 1.010185, .098991, .941969, -.06298, 1.009588, .093044, .961882, -.059507, 1.008777, .086925, .980952, -.055606, 1.008252, .08052, .998955, -.051503, 1.007633, .07389, 1.015756, -.047292, 1.006908, .067302, 1.031571, -.042804, 1.006338, .060412, 1.046095, -.038132, 1.005512, .053497, 1.059542, -.03338, 1.004592, .046569, 1.072006, -.028613, 1.003731, .039679, 1.083348, -.023811, 1.002871, .032772, 1.093969, -.01893, 1.002068, .025894, 1.103697, -.014098, 1.001284, .019178, 1.112813, -.009339, 1.00082, .012652, 1.121193, -.004661, 1.000324, .006226, 1.12893, 52e-6, .999988, -8e-6, 2e-4, -35e-6, 1.030857, .176327, 504e-6, -89e-6, 1.031137, .176326, .002016, -355e-6, 1.031049, .176325, .004535, -8e-4, 1.031105, .176326, .008062, -.001422, 1.030973, .176326, .012598, -.002221, 1.031168, .176326, .018141, -.003199, 1.031093, .176326, .024695, -.004354, 1.031297, .176326, .032253, -.005687, 1.031091, .176327, .040821, -.007197, 1.031012, .176326, .050399, -.008886, 1.031068, .176325, .060987, -.010752, 1.030967, .176323, .072588, -.012797, 1.031028, .176324, .0852, -.015019, 1.030985, .176322, .098829, -.017419, 1.030983, .17632, .113474, -.019997, 1.030953, .176317, .129133, -.022748, 1.030891, .176312, .1458, -.025655, 1.030825, .176306, .163372, -.02851, 1.030781, .176279, .181578, -.030914, 1.030683, .176187, .200761, -.034076, 1.030574, .176139, .220645, -.037985, 1.030476, .17616, .241473, -.042391, 1.030384, .176238, .263922, -.046105, 1.030241, .176175, .287074, -.04939, 1.030049, .176013, .310915, -.052511, 1.029839, .175776, .335604, -.056236, 1.029608, .175578, .360775, -.060118, 1.029355, .175359, .386196, -.063907, 1.029052, .175083, .412599, -.067997, 1.028766, .174791, .439916, -.071088, 1.028326, .174174, .467444, -.074247, 1.02789, .173487, .495132, -.077728, 1.027374, .172774, .523117, -.080822, 1.026763, .171824, .551783, -.083228, 1.026205, .170554, .580234, -.085682, 1.025614, .16909, .608568, -.08786, 1.024668, .167468, .637357, -.089346, 1.023939, .165283, .665507, -.090704, 1.022946, .162966, .693704, -.091388, 1.02201, .160131, .721396, -.091783, 1.021085, .156957, .748676, -.091688, 1.019894, .153292, .77537, -.090992, 1.018608, .149158, .801547, -.089881, 1.017646, .144551, .827013, -.088267, 1.016355, .139614, .851708, -.086132, 1.015446, .134026, .875652, -.083707, 1.014321, .128101, .898703, -.080619, 1.013454, .121841, .920904, -.07728, 1.012634, .115379, .942077, -.073484, 1.01177, .108355, .962245, -.069252, 1.010894, .101153, .981385, -.064807, 1.010114, .093666, .999379, -.06008, 1.009294, .086007, 1.016494, -.055007, 1.008591, .078194, 1.032357, -.04976, 1.007821, .070328, 1.047061, -.044468, 1.006871, .062358, 1.060675, -.03896, 1.006062, .054279, 1.073032, -.033343, 1.004911, .046158, 1.084293, -.027699, 1.003791, .038111, 1.094724, -.02213, 1.002744, .030239, 1.104302, -.016508, 1.001815, .022397, 1.11329, -.010846, 1.001083, .014747, 1.121649, -.005294, 1.00049, .007234, 1.12923, 71e-6, .999975, -53e-6, 2e-4, -4e-5, 1.040431, .202155, 504e-6, -102e-6, 1.040912, .202154, .002016, -407e-6, 1.041328, .202152, .004535, -917e-6, 1.040877, .202154, .008063, -.00163, 1.040867, .202153, .012598, -.002547, 1.04087, .202153, .01814, -.003667, 1.040808, .202153, .024692, -.004991, 1.040861, .202153, .032252, -.006519, 1.040861, .202153, .040822, -.008252, 1.040864, .202153, .050397, -.010187, 1.040717, .202151, .060988, -.012327, 1.040791, .202152, .072582, -.014669, 1.04064, .202149, .085198, -.017217, 1.040716, .202147, .098827, -.019968, 1.040748, .202141, .113467, -.022921, 1.040632, .202142, .129129, -.026074, 1.040606, .202137, .145793, -.029399, 1.040566, .202127, .163294, -.032524, 1.040459, .202078, .181589, -.035552, 1.040315, .201996, .200844, -.039208, 1.040221, .201948, .220835, -.043489, 1.040047, .201945, .241471, -.048523, 1.039921, .202031, .263854, -.052764, 1.039756, .201957, .286935, -.056387, 1.039497, .201743, .310902, -.060338, 1.039252, .201531, .335642, -.064594, 1.038954, .201286, .360859, -.068772, 1.038582, .200983, .386419, -.073086, 1.03816, .200651, .412588, -.077887, 1.037724, .200343, .439836, -.081391, 1.037182, .199618, .467538, -.085121, 1.036602, .198839, .495286, -.088718, 1.035893, .197895, .523231, -.092514, 1.035121, .196887, .55173, -.095238, 1.034127, .19539, .580302, -.097949, 1.033131, .193668, .608559, -.100418, 1.031962, .191773, .637224, -.102129, 1.030838, .189319, .665597, -.103578, 1.029511, .186529, .693535, -.104652, 1.028263, .183303, .721325, -.104766, 1.026611, .179497, .748384, -.104717, 1.025128, .175283, .775058, -.103846, 1.023385, .170493, .801387, -.102728, 1.022236, .165187, .826412, -.100679, 1.019908, .159362, .851314, -.098451, 1.018839, .153059, .8751, -.095363, 1.017306, .146284, .89828, -.092008, 1.016151, .138975, .92045, -.088095, 1.01488, .131361, .941727, -.08369, 1.013556, .123417, .962308, -.079077, 1.012998, .115201, .981364, -.073894, 1.011841, .106711, .999798, -.068435, 1.011021, .098063, 1.016983, -.06283, 1.010194, .089183, 1.033039, -.056914, 1.009292, .08019, 1.047994, -.050721, 1.008474, .07101, 1.06158, -.044454, 1.007386, .061867, 1.074023, -.038145, 1.006135, .052711, 1.08547, -.031679, 1.00489, .043595, 1.095673, -.025157, 1.003627, .034506, 1.105, -.018702, 1.002331, .025468, 1.113795, -.012458, 1.001278, .016834, 1.122012, -.006169, 1.000548, .008265, 1.129683, 78e-6, .999988, -72e-6, 2e-4, -46e-6, 1.052496, .228243, 504e-6, -115e-6, 1.052079, .228243, .002016, -46e-5, 1.052079, .228241, .004535, -.001035, 1.052091, .228242, .008062, -.00184, 1.051962, .228242, .012598, -.002875, 1.052087, .228242, .018141, -.00414, 1.052088, .228242, .024692, -.005636, 1.052096, .228239, .032251, -.007361, 1.052029, .228243, .04082, -.009316, 1.052038, .228241, .050399, -.011501, 1.052042, .228239, .06099, -.013917, 1.052046, .228238, .072586, -.016562, 1.05199, .228236, .085198, -.019437, 1.051946, .228234, .098824, -.022542, 1.051879, .228229, .113467, -.025875, 1.051841, .228227, .129121, -.02943, 1.051724, .228219, .14578, -.03317, 1.051672, .228205, .163222, -.036567, 1.051556, .228143, .181604, -.040245, 1.051382, .228069, .200913, -.044395, 1.05123, .22801, .221005, -.049088, 1.051062, .227988, .241667, -.054506, 1.050881, .228044, .263777, -.059437, 1.050643, .227986, .286841, -.06359, 1.050312, .227755, .310879, -.068224, 1.050009, .227525, .33565, -.072986, 1.049597, .227253, .360869, -.077435, 1.049121, .226845, .386609, -.082385, 1.048587, .226466, .412742, -.08757, 1.047987, .226059, .439789, -.091929, 1.047308, .225331, .467558, -.096038, 1.046423, .224409, .495406, -.099938, 1.045481, .223288, .523417, -.10405, 1.044512, .222066, .551755, -.107503, 1.043408, .220487, .580468, -.110234, 1.042016, .218451, .608904, -.112993, 1.040535, .2162, .63723, -.115173, 1.038934, .213458, .665566, -.116433, 1.036961, .210158, .693413, -.117589, 1.03513, .206457, .721025, -.117885, 1.03308, .202197, .748054, -.117606, 1.030752, .197296, .774631, -.116771, 1.028608, .191813, .800677, -.115194, 1.02635, .185691, .826062, -.113138, 1.024472, .179053, .85059, -.110359, 1.022174, .171839, .87455, -.107072, 1.020381, .164067, .897567, -.103268, 1.018777, .155959, .919609, -.098794, 1.016886, .14732, .941177, -.094067, 1.01588, .138365, .961752, -.08867, 1.014616, .129051, .981518, -.082965, 1.013807, .119515, .99988, -.076971, 1.012793, .109897, 1.01737, -.070518, 1.011894, .099872, 1.033661, -.06383, 1.010943, .089883, 1.048672, -.05704, 1.009802, .079691, 1.062479, -.049917, 1.00867, .069458, 1.075052, -.042735, 1.007429, .059191, 1.086371, -.035513, 1.005991, .048894, 1.096623, -.028359, 1.004468, .03877, 1.105871, -.021111, 1.002927, .028745, 1.114481, -.013908, 1.001728, .018884, 1.12261, -.006843, 1.00074, .009264, 1.130165, 62e-6, .999983, -6e-6, 2e-4, -51e-6, 1.064931, .25463, 504e-6, -128e-6, 1.064668, .25463, .002016, -513e-6, 1.064794, .25463, .004535, -.001155, 1.064851, .25463, .008063, -.002053, 1.064966, .25463, .012598, -.003208, 1.06484, .25463, .01814, -.004619, 1.064602, .254631, .024695, -.006288, 1.064965, .254632, .032251, -.008211, 1.064795, .25463, .040821, -.010393, 1.064802, .254628, .050398, -.01283, 1.064758, .254627, .060987, -.015525, 1.064731, .254625, .072584, -.018474, 1.064615, .254621, .085199, -.021682, 1.064672, .254619, .098826, -.025144, 1.06463, .254613, .113465, -.02886, 1.064515, .254606, .129119, -.032823, 1.064416, .254598, .145767, -.036969, 1.064347, .254579, .16319, -.040754, 1.064132, .254506, .181622, -.044989, 1.063951, .254437, .200981, -.049642, 1.063745, .25437, .221145, -.054776, 1.063547, .254324, .241896, -.060538, 1.063289, .254346, .263684, -.066113, 1.063013, .254296, .286796, -.070925, 1.062625, .254059, .310867, -.076187, 1.062216, .253817, .335644, -.081406, 1.061703, .253481, .360917, -.086336, 1.061066, .253005, .386786, -.09179, 1.060454, .252558, .412921, -.09723, 1.059568, .252008, .439722, -.102574, 1.058706, .251323, .467559, -.106972, 1.057682, .250239, .495605, -.111329, 1.056612, .248944, .523589, -.115561, 1.055101, .247471, .551787, -.119732, 1.053745, .245777, .580426, -.122711, 1.051829, .243448, .608778, -.125436, 1.049642, .240769, .637069, -.127993, 1.047749, .237739, .665251, -.129448, 1.045244, .233928, .692977, -.130408, 1.042279, .22964, .720346, -.130931, 1.039693, .224829, .747365, -.130392, 1.036675, .219144, .773734, -.12954, 1.033719, .212965, .799578, -.127689, 1.030774, .206047, .825002, -.125456, 1.028551, .198576, .849564, -.122291, 1.0258, .190471, .873412, -.11872, 1.023657, .181739, .896628, -.114323, 1.021381, .172586, .918952, -.109587, 1.019674, .162914, .940602, -.104093, 1.018126, .153039, .960917, -.098187, 1.016339, .142774, .980911, -.091963, 1.01544, .132316, .999686, -.085159, 1.014377, .121453, 1.017538, -.078139, 1.013498, .110527, 1.033918, -.070797, 1.012332, .099437, 1.04939, -.063129, 1.011368, .088157, 1.063402, -.055354, 1.010111, .076951, 1.076096, -.047522, 1.008774, .065616, 1.087562, -.039447, 1.007202, .05431, 1.097591, -.031359, 1.005346, .042948, 1.106782, -.023393, 1.00371, .031799, 1.115234, -.015461, 1.002116, .020943, 1.123166, -.007589, 1.000858, .010288, 1.130796, 104e-6, 1.000032, -24e-6, 2e-4, -56e-6, 1.07878, .281356, 504e-6, -142e-6, 1.079271, .281355, .002015, -567e-6, 1.078635, .281355, .004535, -.001276, 1.079164, .281356, .008064, -.002269, 1.0793, .281355, .012598, -.003544, 1.079149, .281355, .018143, -.005104, 1.079329, .281355, .024691, -.006947, 1.079073, .281353, .032254, -.009074, 1.079253, .281354, .040822, -.011484, 1.079176, .281353, .050399, -.014177, 1.079057, .281349, .060987, -.017153, 1.079007, .281347, .072586, -.020412, 1.078998, .281343, .085203, -.023956, 1.078962, .281336, .098823, -.027778, 1.078839, .281332, .113464, -.031882, 1.078783, .281325, .129114, -.036255, 1.078633, .281315, .145748, -.04079, 1.078545, .281287, .163179, -.045024, 1.078311, .281208, .181649, -.049791, 1.078135, .281137, .201042, -.054953, 1.077845, .281063, .221267, -.060551, 1.077576, .281006, .242114, -.066663, 1.077257, .280978, .263568, -.072771, 1.076897, .280925, .286744, -.078349, 1.076405, .280689, .31084, -.084201, 1.075898, .280418, .335612, -.089846, 1.075287, .28002, .360975, -.095394, 1.074482, .279513, .386932, -.10129, 1.073617, .278961, .413171, -.107042, 1.072719, .278283, .439886, -.113083, 1.071698, .277547, .467535, -.11801, 1.070213, .276311, .495701, -.122793, 1.068857, .274867, .523772, -.127278, 1.067037, .273153, .551849, -.131671, 1.064923, .271176, .580338, -.135293, 1.062749, .268626, .608771, -.138065, 1.059944, .265569, .636756, -.140565, 1.056851, .262054, .664574, -.142434, 1.053461, .257807, .692151, -.143237, 1.04991, .25293, .719376, -.143717, 1.046426, .247414, .745852, -.143117, 1.042377, .241001, .7723, -.141975, 1.038789, .233797, .79805, -.140114, 1.03529, .226218, .82337, -.137379, 1.032374, .217785, .847735, -.134119, 1.028853, .208748, .871897, -.129985, 1.026395, .198877, .89495, -.125324, 1.023787, .188803, .917909, -.120007, 1.022073, .178493, .939567, -.114099, 1.020098, .167466, .960534, -.107748, 1.018851, .156223, .980423, -.100748, 1.017362, .144716, .999334, -.093494, 1.015961, .133028, 1.017561, -.085728, 1.015059, .120953, 1.034225, -.077627, 1.013888, .108943, 1.049937, -.069375, 1.012898, .096678, 1.064265, -.060807, 1.011635, .08435, 1.077188, -.052052, 1.010095, .071964, 1.088637, -.043304, 1.008399, .059531, 1.098766, -.034458, 1.006397, .047134, 1.107697, -.025637, 1.004354, .034887, 1.116055, -.016932, 1.002611, .022948, 1.123819, -.008437, 1.001023, .011386, 1.131333, 87e-6, .999952, -97e-6, 2e-4, -62e-6, 1.095622, .308458, 504e-6, -155e-6, 1.094863, .308458, .002016, -622e-6, 1.095169, .308458, .004535, -.001399, 1.095156, .308458, .008063, -.002487, 1.095413, .308455, .012598, -.003886, 1.095147, .308458, .018141, -.005596, 1.09515, .308457, .024692, -.007616, 1.09514, .308457, .032252, -.009947, 1.095098, .308456, .040822, -.012589, 1.095096, .308453, .050399, -.015541, 1.09507, .308451, .060985, -.018803, 1.094922, .308448, .072583, -.022375, 1.094902, .308444, .085197, -.026258, 1.094882, .308438, .098822, -.030448, 1.094775, .308429, .11346, -.034944, 1.094641, .308419, .129112, -.039731, 1.09453, .308403, .145711, -.04461, 1.094332, .308365, .163178, -.049362, 1.094149, .308285, .181679, -.054666, 1.093876, .30821, .201109, -.060336, 1.093603, .308132, .221388, -.066414, 1.09325, .308047, .242315, -.072881, 1.092835, .307985, .263651, -.079453, 1.092391, .307902, .28672, -.085882, 1.091866, .307688, .310817, -.092274, 1.091225, .307379, .335562, -.098306, 1.090346, .306906, .361043, -.104572, 1.089423, .306374, .387051, -.110843, 1.088437, .30571, .413405, -.117062, 1.087228, .304906, .440122, -.123501, 1.085879, .304017, .467522, -.129245, 1.084197, .302783, .495721, -.134285, 1.082284, .301104, .523925, -.139143, 1.080109, .299142, .551814, -.143638, 1.077043, .296825, .579878, -.147774, 1.074071, .294071, .608316, -.150724, 1.070621, .290519, .636059, -.153168, 1.06639, .286424, .663481, -.155139, 1.062069, .281559, .690753, -.155944, 1.057211, .276024, .717767, -.156176, 1.052682, .269622, .743937, -.155783, 1.047747, .262532, .770214, -.154245, 1.04351, .254609, .795542, -.152192, 1.039121, .246007, .821099, -.149256, 1.035962, .236663, .845452, -.145605, 1.03232, .226751, .86978, -.141186, 1.02939, .216165, .893141, -.136137, 1.026485, .204937, .916034, -.130332, 1.024389, .193624, .938089, -.12404, 1.02227, .181756, .959488, -.117011, 1.020457, .169339, .979594, -.109617, 1.018871, .156875, .998912, -.101562, 1.017533, .144288, 1.0171, -.093164, 1.016445, .13137, 1.034413, -.084488, 1.015453, .118322, 1.050347, -.075377, 1.014259, .104963, 1.064958, -.066108, 1.013057, .091722, 1.078045, -.056702, 1.011491, .078231, 1.089749, -.047106, 1.009662, .064797, 1.099831, -.037467, 1.007417, .051315, 1.108789, -.02799, 1.005144, .038064, 1.116865, -.018464, 1.002925, .025008, 1.124609, -.009068, 1.001221, .01225, 1.13204, 93e-6, .999984, -71e-6, 2e-4, -67e-6, 1.112554, .335981, 504e-6, -169e-6, 1.11266, .335981, .002016, -677e-6, 1.112827, .335981, .004533, -.001523, 1.112147, .335982, .008063, -.002709, 1.112882, .335979, .012598, -.004233, 1.112891, .33598, .018141, -.006095, 1.112882, .33598, .024693, -.008296, 1.112877, .335978, .032252, -.010834, 1.11286, .335976, .040824, -.013713, 1.112965, .335974, .050398, -.016927, 1.112753, .335971, .060991, -.020482, 1.112826, .33597, .072587, -.024371, 1.112676, .335962, .085199, -.028597, 1.112593, .335955, .098822, -.033159, 1.112453, .335943, .113461, -.038052, 1.112329, .33593, .129108, -.043255, 1.112144, .33591, .145665, -.048412, 1.111905, .335857, .163185, -.053786, 1.111668, .335781, .18171, -.059608, 1.111345, .335696, .201166, -.065794, 1.110979, .335606, .221489, -.072361, 1.110553, .335505, .242471, -.079184, 1.110112, .335396, .2639, -.086213, 1.109584, .335271, .286688, -.093491, 1.108927, .335089, .310773, -.100406, 1.108091, .334737, .335573, -.106987, 1.107169, .334208, .361117, -.113844, 1.106097, .3336, .387175, -.120463, 1.104826, .332828, .413665, -.127245, 1.103415, .331929, .440386, -.133927, 1.101632, .330851, .467527, -.140496, 1.099563, .329538, .49563, -.145874, 1.096956, .327618, .523864, -.150997, 1.094201, .32539, .551705, -.155713, 1.090342, .322688, .579383, -.159993, 1.08601, .319483, .607301, -.163238, 1.081226, .315522, .634873, -.165667, 1.076065, .31084, .662028, -.167606, 1.070466, .305377, .688755, -.168626, 1.064601, .299056, .715612, -.168578, 1.059269, .291963, .741604, -.167961, 1.053648, .284018, .767757, -.166439, 1.048928, .275474, .793264, -.164023, 1.044343, .266056, .818165, -.160965, 1.039909, .25575, .843255, -.156896, 1.03618, .244843, .867249, -.152262, 1.032303, .233464, .890994, -.146655, 1.029365, .221128, .913829, -.140574, 1.026607, .208554, .936508, -.13364, 1.024512, .195772, .95772, -.12622, 1.022421, .18242, .97894, -.118164, 1.021293, .168852, .998285, -.109558, 1.019444, .155261, 1.016764, -.100562, 1.017825, .141395, 1.034387, -.091064, 1.016996, .127311, 1.050916, -.081468, 1.015945, .113089, 1.065652, -.071463, 1.014547, .098879, 1.079155, -.06124, 1.013066, .084468, 1.090822, -.05098, 1.010788, .06994, 1.1011, -.040549, 1.008563, .055475, 1.109824, -.030101, 1.00595, .041033, 1.117828, -.019884, 1.003453, .027022, 1.125443, -.0099, 1.001484, .013306, 1.132869, 94e-6, 1.000004, -46e-6, 2e-4, -73e-6, 1.132849, .36397, 504e-6, -183e-6, 1.132155, .363969, .002016, -734e-6, 1.132516, .363969, .004535, -.001651, 1.132256, .363969, .008062, -.002934, 1.132318, .363966, .012597, -.004585, 1.132386, .363968, .018141, -.006602, 1.132457, .363967, .024693, -.008987, 1.132511, .363967, .032252, -.011737, 1.132488, .363965, .040819, -.014853, 1.132241, .363959, .050398, -.018336, 1.132372, .363958, .060988, -.022185, 1.132373, .363954, .072582, -.026396, 1.132137, .363943, .085195, -.030973, 1.132071, .363935, .098822, -.035913, 1.131978, .363922, .113461, -.041209, 1.131801, .363905, .129116, -.046833, 1.131535, .363867, .14564, -.052346, 1.13129, .363814, .163199, -.058275, 1.131046, .363734, .181742, -.064623, 1.130671, .363642, .201227, -.071336, 1.130224, .363539, .221587, -.078396, 1.129758, .363419, .242625, -.085545, 1.129213, .363256, .264183, -.09311, 1.128549, .363097, .286668, -.101206, 1.127767, .362939, .310745, -.108586, 1.126796, .362516, .335602, -.115827, 1.125686, .361953, .361202, -.123212, 1.124451, .361275, .387298, -.130294, 1.122861, .360376, .413918, -.137553, 1.121154, .359362, .44068, -.144577, 1.118825, .358069, .467667, -.151558, 1.116002, .356581, .495449, -.157621, 1.112778, .354531, .523514, -.162844, 1.108842, .351915, .55125, -.167744, 1.104075, .348797, .578629, -.172132, 1.098733, .345222, .605757, -.175733, 1.092224, .340665, .633392, -.178109, 1.086201, .335286, .660783, -.180009, 1.08011, .329286, .687219, -.181105, 1.073419, .322319, .713873, -.181046, 1.06741, .314616, .740094, -.180219, 1.061414, .306014, .765233, -.178559, 1.055287, .296704, .790885, -.175806, 1.049727, .286394, .815464, -.172354, 1.044519, .275189, .840259, -.168048, 1.040375, .263441, .864285, -.162904, 1.03601, .250918, .888806, -.157194, 1.033525, .237611, .911682, -.150486, 1.02949, .223809, .934481, -.143212, 1.026778, .209705, .956337, -.135233, 1.024632, .195281, .97738, -.12665, 1.022737, .180878, .997427, -.117552, 1.02111, .166112, 1.016666, -.107814, 1.019869, .151231, 1.034337, -.097814, 1.018543, .136375, 1.051082, -.08733, 1.017476, .121187, 1.066326, -.076614, 1.016083, .106043, 1.079897, -.065793, 1.014227, .090566, 1.092136, -.054654, 1.012334, .074988, 1.102315, -.043516, 1.009627, .059577, 1.111105, -.032509, 1.006808, .044202, 1.118861, -.021381, 1.003917, .028995, 1.126363, -.010489, 1.00167, .014269, 1.133598, 83e-6, .999989, -35e-6, 2e-4, -79e-6, 1.155026, .39247, 504e-6, -198e-6, 1.154184, .392469, .002016, -791e-6, 1.15399, .392469, .004535, -.00178, 1.154045, .392469, .008063, -.003164, 1.154007, .392466, .012598, -.004944, 1.154022, .392469, .018141, -.007119, 1.154015, .392468, .024692, -.00969, 1.154017, .392466, .032254, -.012656, 1.154069, .392465, .040826, -.016018, 1.15398, .392459, .050399, -.019771, 1.153911, .392456, .060987, -.023919, 1.15386, .392447, .072588, -.028461, 1.153777, .392442, .085197, -.033393, 1.153582, .392428, .098822, -.038716, 1.153434, .392412, .113462, -.044422, 1.153271, .39239, .129101, -.050455, 1.153019, .392359, .145642, -.056392, 1.152721, .392283, .163223, -.062859, 1.152404, .392201, .181779, -.069721, 1.151941, .392099, .201289, -.076968, 1.151422, .391978, .221678, -.084518, 1.150861, .391833, .242752, -.092017, 1.150156, .391618, .264474, -.100184, 1.149402, .391421, .286768, -.108921, 1.148545, .391249, .310719, -.116815, 1.147388, .390773, .335638, -.124785, 1.146042, .390168, .36124, -.13263, 1.144529, .389394, .387443, -.140298, 1.142602, .388391, .414067, -.147913, 1.140361, .387199, .440904, -.155362, 1.137612, .385742, .467771, -.162574, 1.133659, .383926, .494907, -.169312, 1.129246, .381715, .522801, -.174778, 1.124228, .378678, .550751, -.179824, 1.118697, .375158, .578018, -.184284, 1.112019, .370851, .605291, -.188215, 1.105151, .365928, .632269, -.19076, 1.097677, .360114, .659432, -.192457, 1.090816, .353498, .685839, -.193458, 1.083286, .346094, .711876, -.193502, 1.076245, .337754, .738184, -.192371, 1.069684, .328412, .763723, -.190531, 1.063249, .318164, .789192, -.187726, 1.057265, .3069, .813744, -.183783, 1.051177, .295021, .838408, -.179328, 1.045902, .282144, .862116, -.173573, 1.040853, .268438, .885636, -.16735, 1.036515, .254108, .909342, -.160229, 1.033269, .239082, .931962, -.152529, 1.029627, .224024, .954671, -.14408, 1.027507, .208393, .975707, -.135023, 1.024657, .19263, .996644, -.125258, 1.022998, .176741, 1.015817, -.115089, 1.021234, .160926, 1.034301, -.104317, 1.020025, .145042, 1.051131, -.093218, 1.018739, .129052, 1.066836, -.081828, 1.017419, .112905, 1.081027, -.070132, 1.015714, .096578, 1.093225, -.058382, 1.013465, .080077, 1.103691, -.046527, 1.010853, .06358, 1.112431, -.034624, 1.007702, .047118, 1.120035, -.022913, 1.004551, .031018, 1.127336, -.011284, 1.001924, .015283, 1.13451, 17e-5, .999937, -58e-6, 2e-4, -84e-6, 1.177044, .421534, 504e-6, -212e-6, 1.177312, .421533, .002016, -85e-5, 1.17773, .421533, .004535, -.001912, 1.177722, .421533, .008063, -.003399, 1.177844, .421529, .012598, -.00531, 1.177768, .421533, .018141, -.007646, 1.17773, .421531, .024692, -.010407, 1.177663, .42153, .032252, -.013592, 1.177681, .421527, .040821, -.017201, 1.177562, .421524, .050401, -.021234, 1.177445, .421516, .060988, -.025688, 1.177461, .421509, .07259, -.030565, 1.177364, .421498, .0852, -.03586, 1.177205, .421482, .098823, -.041572, 1.177011, .421462, .113465, -.047694, 1.176794, .421436, .129094, -.054122, 1.176504, .421396, .145652, -.06053, 1.176203, .421311, .163245, -.067517, 1.175805, .421218, .181825, -.074919, 1.175271, .421108, .20136, -.0827, 1.174717, .420974, .221773, -.090727, 1.174021, .420795, .242908, -.098719, 1.173173, .420536, .264742, -.107417, 1.172285, .420296, .287091, -.116601, 1.171326, .420065, .310723, -.125265, 1.169907, .419582, .335685, -.133876, 1.168352, .418912, .361285, -.14214, 1.166322, .418006, .387562, -.150436, 1.164136, .416899, .414175, -.158388, 1.161162, .415513, .441021, -.166258, 1.157608, .413836, .467698, -.17372, 1.152519, .411702, .49473, -.180843, 1.14702, .409102, .522524, -.186906, 1.141256, .405789, .550055, -.192004, 1.134114, .401759, .577512, -.196588, 1.127086, .397153, .604348, -.20042, 1.119029, .391767, .63097, -.20332, 1.110308, .385573, .658023, -.204883, 1.102643, .378245, .684422, -.205716, 1.094573, .370191, .710405, -.205767, 1.086405, .361231, .736417, -.204513, 1.078712, .351106, .761836, -.202281, 1.071619, .340096, .78714, -.199395, 1.064873, .328139, .812197, -.195185, 1.058313, .315044, .836342, -.190191, 1.052085, .300933, .860311, -.184343, 1.046705, .286411, .883597, -.177415, 1.041072, .270897, .906852, -.170003, 1.036797, .254825, .929991, -.161592, 1.033264, .238176, .952478, -.152792, 1.03025, .221581, .974216, -.143032, 1.027331, .204378, .995372, -.132922, 1.025135, .18747, 1.01533, -.122009, 1.02325, .170538, 1.03407, -.11074, 1.022021, .153777, 1.051295, -.099016, 1.020271, .136916, 1.06746, -.08692, 1.018948, .11988, 1.082022, -.074729, 1.017336, .102565, 1.094378, -.062036, 1.01482, .084994, 1.104998, -.049413, 1.011999, .06765, 1.113773, -.036812, 1.008711, .050148, 1.121263, -.024274, 1.005141, .032976, 1.12842, -.012038, 1.002196, .016239, 1.135496, 106e-6, 1.000042, -62e-6, 2e-4, -9e-5, 1.203048, .451217, 504e-6, -227e-6, 1.203226, .451215, .002016, -909e-6, 1.20345, .451215, .004535, -.002046, 1.203569, .451215, .008062, -.003638, 1.203609, .451209, .012598, -.005684, 1.20358, .451214, .018141, -.008185, 1.203515, .451212, .024694, -.011141, 1.203618, .451211, .032253, -.014549, 1.203609, .451207, .040815, -.018409, 1.203302, .451203, .050401, -.022727, 1.203454, .451195, .06099, -.027495, 1.20348, .451188, .072591, -.032713, 1.20322, .451172, .085203, -.038378, 1.203058, .451154, .098829, -.044489, 1.202838, .45113, .113466, -.051031, 1.20253, .451098, .129084, -.057808, 1.20227, .451041, .145669, -.064769, 1.201904, .450956, .163278, -.072278, 1.201411, .450853, .18188, -.080224, 1.200825, .450721, .201436, -.088537, 1.200164, .450566, .221865, -.097009, 1.199335, .450351, .243083, -.105591, 1.198383, .450062, .265033, -.114818, 1.19738, .449769, .287456, -.124372, 1.196137, .449438, .310758, -.133892, 1.194554, .448974, .335721, -.143052, 1.192649, .448216, .361348, -.151868, 1.190233, .447202, .387573, -.160644, 1.187211, .445926, .414159, -.169028, 1.183452, .444313, .44095, -.177169, 1.178562, .442315, .467998, -.18509, 1.17354, .43996, .494566, -.192396, 1.166344, .436989, .52173, -.198915, 1.159283, .433439, .549405, -.20424, 1.151503, .428984, .576755, -.208861, 1.143004, .423839, .603635, -.212734, 1.134099, .418012, .629979, -.215712, 1.124555, .411445, .656597, -.217385, 1.115293, .403628, .683317, -.218093, 1.10646, .394639, .70899, -.217835, 1.097389, .385012, .734898, -.216774, 1.08894, .373999, .760342, -.21412, 1.080385, .362128, .785517, -.210821, 1.072959, .349184, .809933, -.206443, 1.06545, .33508, .834339, -.200942, 1.058701, .320257, .858793, -.194938, 1.052711, .304133, .8823, -.187615, 1.047044, .287771, .90556, -.179626, 1.042083, .270571, .927916, -.170753, 1.037077, .252741, .950415, -.16127, 1.0332, .234656, .97292, -.151239, 1.030418, .216652, .993893, -.140358, 1.027479, .198252, 1.014204, -.128963, 1.024897, .180113, 1.033878, -.117128, 1.023648, .162282, 1.051754, -.104678, 1.02223, .144366, 1.067924, -.092, 1.020453, .126455, 1.082643, -.078837, 1.018518, .108194, 1.095503, -.065669, 1.016199, .089966, 1.10629, -.052345, 1.013113, .07153, 1.115219, -.039024, 1.009636, .053158, 1.122587, -.025789, 1.005801, .034959, 1.129461, -.012622, 1.002442, .017222, 1.136468, 152e-6, .999964, -65e-6, 2e-4, -96e-6, 1.231156, .481574, 504e-6, -243e-6, 1.232187, .481572, .002016, -971e-6, 1.231948, .481572, .004535, -.002184, 1.231919, .481572, .008061, -.003882, 1.231453, .481566, .012597, -.006066, 1.2318, .481572, .018142, -.008736, 1.231756, .481569, .024693, -.011889, 1.232062, .48157, .032254, -.015528, 1.231915, .481563, .040822, -.01965, 1.231863, .481559, .050402, -.024255, 1.231737, .48155, .060992, -.029342, 1.231678, .481537, .072592, -.034908, 1.231537, .481521, .085207, -.040953, 1.231336, .481499, .098834, -.047469, 1.231071, .481469, .113474, -.054441, 1.230757, .481431, .129077, -.061556, 1.230424, .481359, .145691, -.069091, 1.230022, .481269, .163321, -.077151, 1.229461, .481156, .181936, -.085636, 1.228718, .481011, .201516, -.094484, 1.228023, .48083, .221963, -.103362, 1.227057, .480562, .243264, -.112628, 1.225997, .480247, .265291, -.122366, 1.224744, .479891, .287824, -.132256, 1.223255, .479461, .310927, -.142614, 1.221348, .478978, .335749, -.152326, 1.218953, .478132, .361361, -.161747, 1.215806, .476971, .38748, -.170879, 1.211853, .475477, .414231, -.179865, 1.207783, .473686, .441065, -.188331, 1.202051, .471415, .467923, -.196454, 1.195463, .468647, .494526, -.204048, 1.187542, .465459, .521318, -.21102, 1.179235, .46165, .548654, -.21652, 1.17011, .456868, .575778, -.221098, 1.160163, .451227, .60261, -.224923, 1.149751, .444866, .628891, -.227895, 1.139169, .437577, .655635, -.23002, 1.129736, .429369, .682115, -.230419, 1.119516, .419673, .707514, -.229789, 1.108277, .409143, .733169, -.22852, 1.099159, .397296, .758342, -.225793, 1.089839, .384578, .783477, -.222049, 1.081428, .370323, .808497, -.217562, 1.073742, .355253, .83279, -.211697, 1.06585, .339282, .856677, -.204989, 1.058834, .322181, .880662, -.197653, 1.053291, .30461, .903474, -.188858, 1.046822, .286042, .926313, -.179746, 1.041663, .267224, .948458, -.169542, 1.036532, .247978, .970873, -.159005, 1.033008, .228535, .992958, -.147658, 1.029844, .208819, 1.013413, -.135771, 1.02693, .189486, 1.033483, -.123256, 1.025545, .170422, 1.051872, -.110401, 1.023935, .152075, 1.068396, -.09686, 1.022092, .133169, 1.083731, -.083259, 1.020221, .114022, 1.096849, -.069266, 1.017663, .094772, 1.107864, -.055203, 1.014524, .075432, 1.1166, -.041097, 1.010514, .05598, 1.123871, -.027083, 1.006313, .036839, 1.130718, -.01351, 1.002778, .018156, 1.137649, 154e-6, 1.000033, -28e-6, 2e-4, -103e-6, 1.264025, .51267, 504e-6, -258e-6, 1.262437, .512667, .002016, -.001033, 1.262691, .512668, .004535, -.002325, 1.262834, .512667, .008063, -.004133, 1.262783, .512659, .012598, -.006458, 1.262803, .512666, .018141, -.009299, 1.26272, .512665, .024683, -.012652, 1.262061, .512655, .032257, -.016532, 1.262858, .512656, .040826, -.020919, 1.262709, .512649, .050403, -.02582, 1.262685, .512639, .060993, -.031233, 1.262544, .512625, .072597, -.037157, 1.262435, .512607, .085211, -.043587, 1.262209, .512581, .098842, -.05052, 1.261907, .512544, .113484, -.057926, 1.261575, .5125, .129097, -.06546, 1.261293, .51242, .145727, -.073543, 1.260736, .512316, .163375, -.082134, 1.260117, .51219, .182011, -.091173, 1.259299, .512024, .201598, -.10054, 1.258381, .51181, .222084, -.109931, 1.257293, .511505, .243446, -.119838, 1.25605, .511151, .265574, -.13009, 1.254607, .510724, .28823, -.140421, 1.252808, .510191, .311336, -.151343, 1.250489, .509627, .335719, -.161689, 1.247279, .508688, .361314, -.171748, 1.243467, .507393, .387541, -.181399, 1.239145, .505758, .414204, -.190768, 1.23376, .503676, .441092, -.199659, 1.227433, .501129, .467789, -.207934, 1.219247, .498078, .494454, -.215747, 1.210441, .49463, .52095, -.222869, 1.200559, .490467, .547802, -.228881, 1.189872, .485444, .575563, -.23376, 1.180081, .479268, .602426, -.237566, 1.168544, .472272, .628772, -.240447, 1.156546, .46439, .654963, -.242427, 1.145123, .455345, .681384, -.24298, 1.134322, .444885, .707173, -.24215, 1.122665, .433338, .732477, -.240435, 1.111733, .420647, .757567, -.237806, 1.101271, .406799, .782341, -.233503, 1.091341, .391761, .80669, -.228346, 1.082042, .375576, .830804, -.222386, 1.073504, .358545, .85494, -.215141, 1.06588, .340431, .878709, -.207207, 1.05885, .32169, .901928, -.198273, 1.052588, .30193, .924845, -.188476, 1.046521, .281513, .946932, -.177996, 1.040966, .261234, .969256, -.166644, 1.03667, .240356, .991323, -.154968, 1.032694, .219748, 1.013013, -.142425, 1.030061, .199103, 1.032845, -.129456, 1.027254, .178936, 1.051887, -.115763, 1.025497, .159243, 1.069179, -.101851, 1.023807, .13956, 1.084499, -.087357, 1.021441, .119607, 1.097921, -.072796, 1.01878, .099501, 1.109281, -.058037, 1.015566, .079211, 1.118194, -.043226, 1.011494, .058873, 1.125351, -.028633, 1.007089, .038736, 1.132002, -.013996, 1.003014, .019063, 1.138951, 132e-6, 1.000036, -7e-6, 2e-4, -109e-6, 1.296791, .544571, 504e-6, -274e-6, 1.296055, .544568, .002016, -.001098, 1.297239, .544568, .004535, -.00247, 1.2966, .544568, .008062, -.00439, 1.296368, .544559, .012597, -.00686, 1.296454, .544566, .018141, -.009878, 1.296522, .544565, .024693, -.013444, 1.296536, .54456, .032256, -.017559, 1.296638, .544557, .040824, -.022218, 1.296491, .544547, .050408, -.027426, 1.296552, .544532, .060997, -.033173, 1.296283, .544518, .0726, -.039463, 1.296113, .544496, .08522, -.046292, 1.295894, .544466, .098851, -.053648, 1.295545, .544422, .113496, -.061487, 1.295201, .544371, .129112, -.069467, 1.294754, .544273, .145765, -.078092, 1.294209, .54416, .163431, -.087231, 1.293534, .544017, .182088, -.096837, 1.29258, .543828, .201698, -.106713, 1.291586, .543585, .222231, -.116699, 1.290325, .543238, .243653, -.127208, 1.288888, .542836, .265855, -.137949, 1.287131, .542329, .288623, -.148847, 1.284936, .5417, .31183, -.160204, 1.282109, .540997, .335728, -.171324, 1.278036, .540045, .361403, -.181915, 1.273912, .538603, .387647, -.192124, 1.268881, .536741, .414217, -.201807, 1.262363, .534432, .44109, -.211093, 1.254755, .531623, .467823, -.219678, 1.245456, .528314, .494361, -.227581, 1.234953, .524391, .521264, -.235087, 1.224839, .519902, .547881, -.241508, 1.213175, .514574, .574965, -.246315, 1.200505, .507837, .601847, -.250061, 1.187901, .500286, .628207, -.252822, 1.174601, .491502, .654445, -.254691, 1.161944, .481726, .680175, -.255318, 1.149305, .470727, .706168, -.254257, 1.136708, .458045, .731458, -.2521, 1.124047, .444438, .756378, -.249115, 1.112942, .429611, .781311, -.244899, 1.1018, .413501, .805755, -.239225, 1.091662, .395889, .829867, -.23283, 1.082291, .37786, .853067, -.225193, 1.07282, .358704, .877084, -.216648, 1.065415, .338413, .900123, -.20739, 1.058403, .317596, .92337, -.197095, 1.051412, .296301, .946021, -.186084, 1.045877, .274498, .967669, -.174262, 1.040316, .252565, .989761, -.161814, 1.035489, .230312, 1.012163, -.149076, 1.03254, .208746, 1.032547, -.135299, 1.029598, .18718, 1.052032, -.121277, 1.027355, .166482, 1.069907, -.106582, 1.025622, .145939, 1.085563, -.091589, 1.023244, .125362, 1.099447, -.076263, 1.020661, .104087, 1.110848, -.060825, 1.017035, .083036, 1.119923, -.045319, 1.012675, .061719, 1.126805, -.029852, 1.007668, .040583, 1.133282, -.014846, 1.003335, .019969, 1.140128, 149e-6, 1.000024, -37e-6, 2e-4, -116e-6, 1.334863, .57735, 504e-6, -291e-6, 1.33335, .577348, .002015, -.001164, 1.332853, .577347, .004535, -.002618, 1.333295, .577347, .008062, -.004655, 1.333189, .577336, .012598, -.007273, 1.333309, .577345, .018141, -.010472, 1.333274, .577342, .024694, -.014253, 1.333231, .577339, .032254, -.018614, 1.333265, .577332, .040827, -.023556, 1.333261, .577321, .0504, -.029069, 1.332893, .577309, .061, -.035166, 1.332998, .577288, .072608, -.041833, 1.332901, .577263, .085227, -.049067, 1.332603, .577226, .098864, -.05686, 1.332264, .577177, .113507, -.065114, 1.331825, .577109, .129146, -.07361, 1.331311, .577005, .145808, -.082766, 1.330639, .576872, .163494, -.092458, 1.329878, .576709, .182176, -.102639, 1.328889, .576501, .201804, -.112983, 1.32771, .576207, .222394, -.12365, 1.326256, .575823, .243881, -.13478, 1.324593, .575363, .266122, -.145931, 1.322426, .574751, .289043, -.1575, 1.319837, .574033, .31233, -.169208, 1.316301, .573181, .33612, -.181125, 1.312251, .572188, .361506, -.192232, 1.307003, .570631, .387757, -.202981, 1.301068, .568558, .414365, -.21316, 1.293695, .566027, .440986, -.222617, 1.283958, .562942, .467943, -.231583, 1.274057, .559219, .494821, -.239881, 1.262864, .554913, .521486, -.247336, 1.250633, .549953, .547884, -.253921, 1.237448, .544251, .574582, -.259099, 1.223164, .53712, .601342, -.262695, 1.208784, .52865, .627861, -.265337, 1.194424, .518978, .653745, -.266872, 1.179361, .508525, .679348, -.267403, 1.16501, .496705, .705068, -.266429, 1.151693, .482926, .730312, -.263829, 1.137584, .468519, .755576, -.260491, 1.125328, .452213, .780371, -.256166, 1.113759, .435127, .804632, -.250079, 1.101656, .416833, .828983, -.243181, 1.091235, .397009, .852585, -.235383, 1.081475, .376647, .875237, -.226031, 1.071806, .355506, .899152, -.216343, 1.064453, .333133, .922121, -.205772, 1.057161, .311073, .944523, -.19398, 1.050447, .287781, .967313, -.18192, 1.044531, .26435, .989042, -.168822, 1.039312, .241128, 1.010881, -.15535, 1.035298, .218138, 1.032368, -.141231, 1.032073, .195579, 1.052254, -.126521, 1.029395, .173399, 1.070207, -.111243, 1.026938, .151866, 1.086528, -.095617, 1.024957, .130711, 1.10067, -.079687, 1.021924, .108865, 1.112461, -.063593, 1.018281, .08676, 1.121588, -.047313, 1.013747, .064575, 1.128522, -.031385, 1.008433, .042499, 1.134759, -.015356, 1.003569, .02084, 1.141448, 114e-6, .999978, -56e-6, 2e-4, -122e-6, 1.372763, .611086, 503e-6, -308e-6, 1.371456, .611084, .002016, -.001232, 1.37344, .611084, .004535, -.002771, 1.373387, .611083, .008061, -.004926, 1.372916, .611083, .012601, -.0077, 1.373956, .611084, .018142, -.011084, 1.373419, .611078, .024695, -.015087, 1.373492, .611074, .032255, -.019701, 1.37336, .611066, .040827, -.02493, 1.373327, .611055, .050408, -.030769, 1.373222, .611037, .061004, -.037217, 1.373079, .611014, .072613, -.04427, 1.372895, .610982, .085238, -.051923, 1.372624, .610941, .098878, -.060161, 1.372252, .610883, .113522, -.068785, 1.371785, .610798, .129176, -.077863, 1.371103, .610683, .145876, -.087593, 1.370541, .610537, .16357, -.097847, 1.369496, .610349, .182283, -.108592, 1.368477, .610109, .20193, -.11942, 1.36698, .609763, .22257, -.130789, 1.365375, .609343, .244123, -.142514, 1.363456, .608815, .266437, -.154232, 1.360916, .608114, .289467, -.16637, 1.357909, .607291, .312861, -.178505, 1.353588, .606272, .336736, -.19098, 1.349211, .605153, .36174, -.202859, 1.343319, .603548, .387878, -.213997, 1.335908, .601268, .414357, -.224584, 1.326676, .598499, .441442, -.234664, 1.317331, .595066, .468409, -.243875, 1.305818, .590996, .494999, -.252121, 1.291863, .586293, .52173, -.259714, 1.278212, .58084, .547894, -.266242, 1.262656, .574494, .573865, -.271578, 1.246364, .567007, .601124, -.275503, 1.231274, .557771, .627606, -.277954, 1.215252, .547255, .654004, -.279404, 1.199977, .535766, .679554, -.279632, 1.183995, .522792, .70428, -.278457, 1.167428, .508488, .72983, -.275706, 1.15276, .492425, .754376, -.27164, 1.137942, .475285, .779209, -.266911, 1.125222, .456679, .803562, -.260838, 1.112179, .437267, .827985, -.253353, 1.101439, .416227, .851737, -.245027, 1.08989, .394728, .87485, -.235719, 1.080018, .372244, .89768, -.225051, 1.070807, .348846, .921351, -.214051, 1.06318, .324961, .943818, -.202039, 1.056148, .300836, .966368, -.189134, 1.049277, .276333, .987426, -.175613, 1.042176, .251862, 1.010162, -.161473, 1.038567, .227217, 1.031224, -.146866, 1.034102, .203582, 1.052317, -.131644, 1.0316, .180629, 1.070879, -.115909, 1.028913, .158165, 1.087407, -.099638, 1.026193, .135905, 1.102159, -.083091, 1.023567, .113394, 1.114006, -.066178, 1.019567, .090325, 1.123374, -.04943, 1.014856, .067302, 1.13031, -.032557, 1.009141, .044264, 1.136334, -.016157, 1.003984, .021807, 1.142961, 172e-6, .999951, -77e-6, 2e-4, -129e-6, 1.416584, .645866, 504e-6, -326e-6, 1.417762, .645865, .002016, -.001302, 1.417825, .645866, .004535, -.002929, 1.417142, .645865, .008062, -.005207, 1.416968, .645864, .012598, -.008136, 1.417109, .645862, .018141, -.011715, 1.417001, .645859, .02469, -.015941, 1.416878, .645853, .032257, -.020823, 1.417134, .645843, .040827, -.026347, 1.416983, .645829, .050411, -.032518, 1.416949, .645808, .061007, -.03933, 1.416694, .645781, .072621, -.046783, 1.416599, .645746, .085249, -.054865, 1.416241, .645695, .098897, -.063563, 1.415832, .64563, .113546, -.072607, 1.415264, .645529, .12922, -.082257, 1.414482, .645396, .145888, -.092515, 1.413626, .645268, .163659, -.103393, 1.41271, .645018, .182385, -.114684, 1.411418, .644739, .202078, -.126098, 1.409822, .644348, .222772, -.138145, 1.407948, .643872, .24437, -.150405, 1.405678, .643255, .266787, -.162798, 1.402763, .642463, .289844, -.175434, 1.398863, .641504, .31354, -.188158, 1.394695, .640346, .337489, -.201014, 1.389376, .639042, .362008, -.213719, 1.382439, .637412, .38799, -.225248, 1.373281, .63493, .414728, -.236348, 1.363729, .631861, .441635, -.246701, 1.352304, .628155, .468588, -.256167, 1.339162, .623625, .495337, -.264662, 1.323811, .618458, .521886, -.272207, 1.30763, .612373, .548355, -.27889, 1.291265, .605263, .574535, -.284442, 1.273752, .597048, .60087, -.288389, 1.256171, .587401, .627715, -.290816, 1.238447, .576001, .65383, -.291886, 1.221036, .563198, .679175, -.291629, 1.202283, .549249, .704539, -.290489, 1.185866, .533881, .729126, -.287529, 1.168822, .516966, .754297, -.283184, 1.152934, .498501, .778678, -.277732, 1.137821, .478728, .802473, -.271203, 1.123387, .457814, .826596, -.263494, 1.110573, .435865, .850835, -.254572, 1.099099, .412597, .874203, -.244815, 1.088403, .388995, .897271, -.233993, 1.078085, .364487, .919667, -.221934, 1.068543, .339344, .943001, -.209714, 1.061081, .31377, .965688, -.196367, 1.054023, .287928, .987598, -.182263, 1.047247, .262157, 1.00928, -.167775, 1.041376, .236855, 1.031762, -.15253, 1.037647, .211847, 1.051965, -.136809, 1.033396, .187546, 1.071699, -.120418, 1.031021, .164186, 1.088881, -.103618, 1.028403, .141184, 1.103482, -.086271, 1.024987, .117665, 1.115646, -.068973, 1.020884, .093896, 1.125258, -.051285, 1.015966, .069978, 1.132045, -.033998, 1.00999, .046126, 1.138004, -.016696, 1.00427, .022635, 1.144463, 89e-6, .999987, -16e-6, 2e-4, -136e-6, 1.463614, .681786, 504e-6, -344e-6, 1.465345, .681785, .002015, -.001374, 1.464172, .681783, .004535, -.003092, 1.464846, .681784, .008062, -.005496, 1.464783, .681784, .012598, -.008588, 1.464883, .681781, .018141, -.012366, 1.46474, .681777, .024692, -.016829, 1.464665, .68177, .032258, -.02198, 1.46472, .68176, .040829, -.027811, 1.464625, .681742, .050415, -.034324, 1.464571, .68172, .061013, -.041513, 1.464346, .681688, .072628, -.049375, 1.464131, .681644, .085264, -.057903, 1.463847, .681588, .098918, -.067067, 1.463369, .681509, .113568, -.07657, 1.462549, .681389, .129265, -.086782, 1.461703, .681239, .145997, -.097637, 1.46084, .681047, .163751, -.109101, 1.459737, .680806, .182505, -.120922, 1.458231, .68048, .202241, -.133007, 1.456393, .680042, .222987, -.145693, 1.454258, .679503, .244638, -.158488, 1.451543, .678792, .267132, -.171585, 1.448115, .677907, .290365, -.184746, 1.443992, .676796, .314178, -.198101, 1.439271, .675498, .338289, -.21137, 1.43283, .673922, .362543, -.224489, 1.424163, .672151, .38847, -.236914, 1.41516, .669601, .415105, -.248342, 1.403811, .666255, .441925, -.258957, 1.390149, .662166, .468668, -.268556, 1.374104, .657229, .49572, -.277359, 1.358102, .651347, .522574, -.285078, 1.340754, .644598, .548981, -.291718, 1.322033, .63682, .574946, -.297087, 1.302148, .627812, .600744, -.301079, 1.28213, .617485, .627565, -.303566, 1.263339, .605047, .653598, -.30433, 1.242712, .591167, .679239, -.30382, 1.223212, .576025, .704043, -.302064, 1.203763, .559649, .728796, -.299095, 1.185434, .541271, .753581, -.294392, 1.16763, .5218, .778577, -.288603, 1.15193, .500628, .80255, -.281604, 1.136072, .478434, .825803, -.273472, 1.121673, .455384, .849768, -.264011, 1.108491, .430811, .87325, -.253653, 1.09655, .405524, .896725, -.242642, 1.085905, .380038, .919158, -.230191, 1.075091, .353482, .942236, -.217145, 1.066848, .326605, .965031, -.203555, 1.05931, .299842, .987048, -.188777, 1.051749, .272859, 1.008718, -.173613, 1.044999, .24604, 1.031097, -.157972, 1.040066, .219826, 1.052493, -.141589, 1.035951, .194278, 1.071773, -.124814, 1.03252, .16983, 1.089646, -.107321, 1.029803, .146135, 1.104932, -.089726, 1.026612, .122127, 1.117687, -.071433, 1.022391, .097461, 1.127188, -.053395, 1.017113, .072556, 1.13401, -.035151, 1.010934, .047749, 1.139746, -.017427, 1.004633, .02353, 1.146205, 151e-6, 1.00002, -106e-6, 2e-4, -144e-6, 1.517643, .718949, 504e-6, -362e-6, 1.516387, .718947, .002016, -.001449, 1.516742, .718946, .004536, -.003261, 1.517196, .718946, .008063, -.005796, 1.516806, .718945, .012598, -.009057, 1.516986, .718943, .01814, -.013039, 1.516603, .718937, .024694, -.017747, 1.516739, .718929, .03226, -.023178, 1.516994, .718917, .040831, -.029325, 1.516649, .718896, .050419, -.036192, 1.516594, .71887, .061019, -.04377, 1.516327, .718833, .072638, -.052056, 1.516054, .718782, .085274, -.061039, 1.515628, .718714, .098938, -.070676, 1.515199, .718623, .113607, -.080679, 1.514222, .718483, .129329, -.091485, 1.513354, .718316, .146077, -.102931, 1.512301, .718096, .163856, -.114986, 1.510977, .717818, .18264, -.127305, 1.509225, .717432, .202432, -.140147, 1.507152, .716939, .223229, -.153468, 1.50478, .716331, .244943, -.166875, 1.501612, .715527, .267559, -.180658, 1.497898, .714523, .290926, -.194405, 1.493208, .713266, .314863, -.208302, 1.487388, .711758, .339053, -.22202, 1.479677, .709982, .363627, -.235683, 1.47095, .707958, .388887, -.248723, 1.459907, .705346, .415474, -.260563, 1.446579, .701644, .442065, -.271352, 1.429962, .697134, .469418, -.281541, 1.414343, .691665, .496419, -.290429, 1.395681, .685227, .523071, -.298032, 1.375347, .677815, .549641, -.304679, 1.354816, .669063, .575489, -.309902, 1.332505, .659071, .601108, -.313771, 1.309752, .647799, .627199, -.316225, 1.288381, .634856, .653243, -.316679, 1.265785, .619627, .67896, -.315816, 1.244333, .603244, .704055, -.313776, 1.223315, .585191, .728713, -.310417, 1.203142, .565969, .753301, -.305786, 1.184323, .545347, .77789, -.299262, 1.16607, .522753, .802354, -.29183, 1.149599, .499017, .826005, -.283281, 1.133655, .474335, .84892, -.273512, 1.118132, .449019, .872765, -.262525, 1.105606, .422329, .89595, -.250769, 1.093539, .395057, .918816, -.238257, 1.082388, .367709, .941089, -.224381, 1.072484, .33935, .964514, -.210289, 1.064054, .311239, .987128, -.195488, 1.056645, .283272, 1.009064, -.179491, 1.049549, .255163, 1.030163, -.163172, 1.042741, .227757, 1.052502, -.146457, 1.03827, .20097, 1.072971, -.129054, 1.035014, .175767, 1.091223, -.111285, 1.032231, .151118, 1.106518, -.092617, 1.028211, .126196, 1.119235, -.074168, 1.023686, .100828, 1.129311, -.055212, 1.018311, .07524, 1.135983, -.036571, 1.011485, .049558, 1.141648, -.017954, 1.004952, .024273, 1.147938, 125e-6, 1.000009, -48e-6, 199e-6, -151e-6, 1.566887, .757466, 504e-6, -382e-6, 1.574111, .757466, .002016, -.001527, 1.573735, .757466, .004535, -.003435, 1.573737, .757466, .008062, -.006107, 1.573782, .757464, .012599, -.009542, 1.573796, .75746, .018142, -.013739, 1.57371, .757455, .024694, -.018697, 1.573562, .757446, .032259, -.024418, 1.573667, .757429, .040834, -.030895, 1.573555, .757407, .050422, -.038127, 1.573383, .757376, .061025, -.046108, 1.573086, .757332, .07265, -.054835, 1.572833, .757274, .085296, -.064294, 1.572395, .757195, .098962, -.074376, 1.571729, .757087, .113649, -.084955, 1.570571, .756925, .129389, -.096334, 1.569582, .756729, .146167, -.108406, 1.568444, .756481, .163973, -.121056, 1.566905, .756158, .182798, -.13397, 1.564939, .755715, .20265, -.147522, 1.562666, .755167, .223502, -.161466, 1.559877, .754465, .245269, -.175539, 1.556008, .753552, .26801, -.189957, 1.552013, .75242, .291474, -.204361, 1.546509, .751008, .315527, -.218714, 1.539575, .749266, .339954, -.233029, 1.530968, .747232, .364649, -.247149, 1.520994, .744906, .38952, -.260672, 1.507748, .742123, .415717, -.272873, 1.491777, .738187, .442862, -.284317, 1.475658, .733189, .469939, -.294552, 1.456572, .727165, .496916, -.303517, 1.435237, .720043, .52348, -.311061, 1.412192, .71164, .550092, -.317596, 1.389033, .702174, .576384, -.322921, 1.365086, .691225, .60228, -.326806, 1.341317, .678841, .627676, -.329057, 1.316518, .664815, .653458, -.329372, 1.291877, .648548, .679227, -.328067, 1.268126, .630676, .704476, -.325585, 1.244424, .611585, .729232, -.321775, 1.22301, .590803, .753405, -.316713, 1.201297, .568653, .777274, -.309858, 1.181071, .544763, .801882, -.301866, 1.162826, .519747, .82603, -.292861, 1.145704, .493531, .849359, -.282794, 1.129629, .4669, .871837, -.271197, 1.114155, .43923, .895896, -.258954, 1.102334, .41057, .918951, -.245878, 1.090163, .381314, .941148, -.231897, 1.078738, .352268, .963464, -.216743, 1.068862, .322688, .986628, -.201486, 1.061077, .293523, 1.009289, -.185521, 1.053561, .264125, 1.030659, -.168429, 1.046627, .235706, 1.052382, -.15121, 1.040953, .208022, 1.073476, -.133289, 1.036534, .181245, 1.092237, -.114768, 1.03358, .155661, 1.1082, -.095917, 1.029997, .130223, 1.121435, -.076492, 1.025374, .104098, 1.131382, -.057204, 1.019485, .077776, 1.137994, -.037747, 1.012188, .05125, 1.143441, -.018673, 1.005309, .025245, 1.149714, 216e-6, 1.000004, -12e-5, 2e-4, -159e-6, 1.633988, .797469, 504e-6, -402e-6, 1.636076, .797469, .002016, -.001607, 1.635679, .797467, .004535, -.003617, 1.63604, .797468, .008063, -.00643, 1.636159, .797467, .012599, -.010046, 1.636128, .797462, .018141, -.014464, 1.63573, .797457, .024696, -.019685, 1.635836, .797445, .032259, -.025705, 1.635719, .797426, .040835, -.032523, 1.63561, .797401, .050425, -.040135, 1.63546, .797363, .061033, -.048536, 1.635182, .797313, .072661, -.057718, 1.634817, .797243, .085315, -.067666, 1.634314, .79715, .098985, -.078179, 1.63335, .797016, .113699, -.089383, 1.632253, .796839, .129456, -.101364, 1.631025, .796623, .146275, -.114081, 1.629867, .796331, .164108, -.127318, 1.628043, .795956, .182983, -.140901, 1.625813, .795458, .202891, -.155174, 1.623149, .794834, .223787, -.169654, 1.619686, .794015, .245678, -.18454, 1.615694, .793013, .268495, -.199543, 1.610812, .791727, .292093, -.214639, 1.604629, .790107, .316184, -.229499, 1.596061, .788154, .340986, -.244407, 1.587195, .785797, .365808, -.258907, 1.575031, .783093, .390528, -.272746, 1.559448, .77997, .41651, -.285845, 1.543294, .775852, .443443, -.297404, 1.523476, .770323, .470442, -.307757, 1.501515, .763721, .497499, -.316846, 1.477841, .755889, .524316, -.324561, 1.452427, .746662, .551212, -.33106, 1.427421, .736004, .577323, -.335956, 1.400369, .72381, .602976, -.339501, 1.373093, .710184, .628357, -.341577, 1.345853, .695017, .653642, -.342031, 1.31904, .677972, .67944, -.340342, 1.29249, .658877, .704744, -.337356, 1.267182, .638085, .729692, -.333042, 1.24328, .615615, .75392, -.327504, 1.219751, .592054, .777695, -.320537, 1.197796, .566967, .801426, -.31188, 1.176872, .540643, .825649, -.302211, 1.15816, .512906, .849282, -.291665, 1.141257, .484587, .872341, -.28005, 1.125469, .455556, .89511, -.266978, 1.110222, .425652, .918841, -.253326, 1.097419, .395015, .941209, -.238899, 1.086101, .364948, .963142, -.223523, 1.075023, .334151, .985996, -.207346, 1.065628, .303708, 1.008718, -.190889, 1.057256, .273008, 1.030554, -.173517, 1.04972, .243221, 1.053085, -.155645, 1.043837, .214426, 1.074267, -.137472, 1.039312, .187036, 1.093591, -.118385, 1.035457, .160512, 1.10985, -.098883, 1.03163, .134384, 1.123516, -.07905, 1.026762, .107424, 1.133578, -.058977, 1.02064, .080317, 1.140289, -.039013, 1.013096, .052944, 1.14561, -.019228, 1.005694, .025989, 1.151704, 105e-6, .999981, -19e-6, 2e-4, -168e-6, 1.704841, .839096, 504e-6, -423e-6, 1.704242, .839097, .002016, -.001691, 1.703821, .839091, .004534, -.003805, 1.703804, .839094, .008063, -.006765, 1.704224, .839092, .012598, -.01057, 1.704013, .839087, .018142, -.015219, 1.703889, .839079, .024697, -.020712, 1.704023, .839066, .032261, -.027046, 1.703836, .839045, .040837, -.034218, 1.703608, .839014, .050429, -.042224, 1.703414, .838972, .061041, -.051061, 1.703148, .838912, .072676, -.060717, 1.702744, .838831, .08534, -.071175, 1.702223, .838724, .099023, -.082182, 1.700984, .838567, .113759, -.094007, 1.699764, .838367, .129546, -.106621, 1.698462, .838112, .146382, -.119956, 1.696938, .837782, .16426, -.13376, 1.694868, .837346, .183188, -.148108, 1.692262, .83678, .203158, -.163075, 1.689251, .836073, .224147, -.178255, 1.685408, .835148, .246147, -.1939, 1.680946, .833992, .269072, -.209553, 1.675277, .832546, .292718, -.225226, 1.667626, .830727, .317159, -.240836, 1.658952, .82851, .341979, -.256103, 1.647624, .825843, .366844, -.270887, 1.633014, .82276, .392043, -.285324, 1.617191, .819159, .417356, -.298817, 1.597501, .814788, .444093, -.310711, 1.575184, .808751, .471379, -.32141, 1.55159, .801294, .498267, -.330421, 1.524134, .792711, .525401, -.338331, 1.496672, .78248, .551846, -.34443, 1.467062, .770659, .578009, -.349047, 1.436943, .757348, .604054, -.35249, 1.407611, .742541, .629387, -.354158, 1.377441, .726071, .654435, -.354422, 1.347651, .707524, .679845, -.352663, 1.318769, .687067, .704892, -.348994, 1.2906, .664637, .729763, -.344105, 1.263997, .640663, .754345, -.338129, 1.239273, .615484, .778629, -.330905, 1.215858, .58921, .801939, -.322113, 1.192318, .56155, .825723, -.311673, 1.17138, .532175, .849387, -.30041, 1.152991, .502055, .872792, -.288328, 1.136139, .471308, .895083, -.275087, 1.119534, .440427, .918335, -.2607, 1.105542, .40926, .941577, -.245717, 1.09307, .377142, .963992, -.230079, 1.081207, .345289, .98651, -.213523, 1.071488, .313508, 1.008806, -.196157, 1.062011, .281962, 1.030724, -.178467, 1.05324, .251177, 1.053782, -.160291, 1.047057, .220986, 1.075451, -.141308, 1.041842, .192256, 1.094947, -.121975, 1.037704, .165023, 1.111783, -.101744, 1.0333, .138228, 1.125525, -.081476, 1.028234, .110679, 1.135873, -.06077, 1.021695, .082672, 1.142478, -.040207, 1.013838, .054506, 1.147889, -.019908, 1.006166, .026938, 1.153852, 204e-6, .999983, -123e-6, 199e-6, -176e-6, 1.771601, .882501, 504e-6, -445e-6, 1.779195, .882504, .002016, -.001779, 1.779635, .882498, .004536, -.004003, 1.779586, .882499, .008062, -.007115, 1.778613, .882496, .012598, -.011116, 1.778678, .882492, .018142, -.016005, 1.778531, .882481, .024696, -.021782, 1.778556, .882466, .032262, -.028444, 1.778507, .882442, .040842, -.035987, 1.778385, .882408, .050436, -.044404, 1.778034, .882364, .061053, -.053695, 1.777761, .882287, .072692, -.063842, 1.777256, .88219, .085364, -.074821, 1.776518, .882067, .099064, -.086368, 1.77508, .881884, .113828, -.098805, 1.773836, .881657, .129649, -.11209, 1.77237, .881361, .146518, -.126067, 1.770594, .880982, .16444, -.140493, 1.768089, .880484, .183437, -.155646, 1.765301, .879843, .203468, -.171266, 1.761698, .879035, .224562, -.187231, 1.757518, .877982, .246665, -.20354, 1.752318, .876667, .269652, -.219916, 1.745356, .875028, .293531, -.236255, 1.737186, .872977, .318048, -.25241, 1.726709, .870448, .342963, -.268192, 1.713109, .8674, .368336, -.283587, 1.698087, .863882, .393512, -.298186, 1.678638, .859724, .418602, -.311882, 1.655604, .854835, .44508, -.3245, 1.63225, .848353, .472289, -.335295, 1.605069, .840218, .499128, -.344256, 1.573846, .830556, .525834, -.351716, 1.54112, .819269, .553177, -.358241, 1.511385, .806222, .57948, -.36264, 1.477866, .791647, .605205, -.365513, 1.444218, .775398, .630617, -.366822, 1.410954, .757144, .65573, -.366785, 1.37901, .737323, .680529, -.364904, 1.34728, .715601, .7058, -.36099, 1.316416, .691547, .73055, -.355397, 1.286344, .666141, .75497, -.348664, 1.258954, .638929, .779042, -.340774, 1.232965, .611015, .802839, -.331767, 1.209775, .581877, .825793, -.321054, 1.185813, .551509, .849512, -.309016, 1.16508, .519698, .87312, -.296369, 1.147091, .487506, .895942, -.282704, 1.129658, .45532, .917996, -.268007, 1.113463, .422605, .941281, -.252329, 1.10004, .389347, .964584, -.236203, 1.087973, .35643, .986371, -.219209, 1.075983, .323089, 1.009522, -.201588, 1.06694, .290806, 1.031976, -.183296, 1.057999, .258682, 1.053461, -.164509, 1.049542, .227722, 1.076121, -.145165, 1.043718, .197439, 1.096597, -.125199, 1.039607, .169578, 1.113908, -.104921, 1.035528, .142222, 1.127939, -.083623, 1.029807, .113802, 1.138391, -.062589, 1.023312, .085164, 1.14511, -.041376, 1.014806, .056186, 1.150141, -.020433, 1.006501, .027654, 1.156069, 97e-6, .999949, -46e-6, 2e-4, -185e-6, 1.858268, .927857, 504e-6, -468e-6, 1.861583, .927859, .002016, -.00187, 1.860659, .927855, .004535, -.004208, 1.860963, .927867, .008063, -.00748, 1.860766, .927855, .012594, -.011683, 1.859996, .927851, .018142, -.016828, 1.860739, .927839, .024698, -.022901, 1.860763, .927818, .032263, -.029903, 1.860501, .927791, .040846, -.037834, 1.860431, .927751, .05044, -.04668, 1.859827, .92769, .061066, -.056446, 1.859624, .92761, .072713, -.067109, 1.859039, .927505, .085393, -.078613, 1.858144, .927357, .09912, -.090747, 1.856618, .927145, .11391, -.10385, 1.855221, .926884, .129755, -.117777, 1.85347, .926546, .146669, -.132441, 1.851413, .926104, .164648, -.147565, 1.848498, .92553, .183708, -.16347, 1.845281, .924802, .203832, -.179763, 1.841273, .923871, .225029, -.196564, 1.836481, .922691, .247221, -.213537, 1.830273, .921198, .270343, -.230662, 1.822374, .91932, .294399, -.24774, 1.812975, .917008, .31904, -.264448, 1.800693, .914141, .344269, -.280831, 1.785923, .910707, .369625, -.296478, 1.767203, .906585, .394925, -.311287, 1.744434, .901918, .420583, -.325578, 1.720938, .89624, .4462, -.338384, 1.693005, .889335, .472969, -.349187, 1.660901, .880394, .50049, -.358687, 1.628806, .869705, .527312, -.366042, 1.593001, .857145, .554207, -.372045, 1.557046, .842943, .58062, -.376134, 1.520192, .826837, .60648, -.378636, 1.482947, .808891, .631815, -.379414, 1.445954, .789119, .657021, -.378972, 1.410833, .767564, .681686, -.376728, 1.376575, .744338, .706498, -.372844, 1.342935, .718799, .731258, -.366649, 1.311052, .691756, .755937, -.359354, 1.280478, .662683, .779259, -.350487, 1.250585, .632892, .803295, -.340941, 1.225722, .60216, .82657, -.330174, 1.201003, .57052, .849954, -.317854, 1.178488, .537651, .873696, -.304426, 1.158302, .503799, .896695, -.29012, 1.139886, .469645, .919149, -.275106, 1.122884, .435625, .942121, -.259282, 1.107691, .401228, .964627, -.242123, 1.093661, .367086, .986614, -.224575, 1.08158, .332885, 1.009623, -.206837, 1.071375, .299209, 1.033126, -.188092, 1.062241, .266187, 1.054954, -.168637, 1.052912, .233733, 1.07766, -.149166, 1.047047, .203192, 1.097983, -.128587, 1.041607, .173918, 1.115586, -.107339, 1.03685, .145531, 1.13017, -.086203, 1.031427, .11689, 1.141018, -.064171, 1.024395, .087388, 1.147681, -.04253, 1.015719, .057733, 1.15256, -.021011, 1.006883, .028413, 1.158406, 158e-6, .999897, -106e-6, 2e-4, -195e-6, 1.950982, .975366, 504e-6, -491e-6, 1.950207, .975365, .002015, -.001966, 1.950675, .975362, .004535, -.004423, 1.951281, .97537, .008062, -.007863, 1.951045, .975362, .012597, -.012285, 1.951199, .975356, .018145, -.017692, 1.951528, .97534, .024699, -.024074, 1.951194, .975321, .032266, -.031434, 1.950865, .975288, .040853, -.039771, 1.951038, .975244, .050452, -.049067, 1.950336, .975173, .061077, -.059324, 1.949805, .975078, .072736, -.070526, 1.949133, .974951, .085431, -.082528, 1.947947, .974777, .099182, -.095345, 1.946337, .97454, .113999, -.109118, 1.944725, .974241, .129888, -.123741, 1.942857, .973852, .146842, -.139071, 1.940251, .973342, .16489, -.154986, 1.937086, .972684, .184025, -.171661, 1.933404, .971856, .204245, -.188672, 1.92877, .970785, .225528, -.206252, 1.923041, .969448, .247841, -.223972, 1.915788, .967742, .271157, -.241827, 1.907008, .965607, .295297, -.259562, 1.895854, .963007, .320121, -.276909, 1.881289, .959722, .345566, -.293883, 1.864528, .955831, .371012, -.309816, 1.842062, .951127, .396834, -.325157, 1.818068, .945725, .422277, -.339357, 1.788874, .939318, .447928, -.352387, 1.758283, .93147, .474315, -.36368, 1.723668, .9219, .50156, -.372963, 1.686081, .909996, .528391, -.380159, 1.645816, .896244, .554754, -.385545, 1.603709, .880326, .581888, -.389778, 1.565475, .862716, .607791, -.391839, 1.524196, .843146, .633511, -.392331, 1.483921, .821554, .658621, -.391193, 1.445013, .798336, .68316, -.388424, 1.406963, .773299, .707429, -.384104, 1.370996, .746668, .732212, -.377945, 1.335879, .717502, .756871, -.369856, 1.302489, .686954, .781065, -.360707, 1.271815, .655372, .804167, -.350091, 1.242416, .622683, .827948, -.338941, 1.217208, .589185, .850901, -.326427, 1.192354, .555005, .873589, -.312199, 1.169639, .519594, .897085, -.297374, 1.150181, .484105, .920459, -.281932, 1.132858, .448661, .942637, -.265625, 1.115401, .413051, .965341, -.248332, 1.101078, .377329, .98753, -.229983, 1.087377, .342349, 1.010739, -.211647, 1.076582, .307824, 1.033449, -.192725, 1.0659, .273368, 1.055618, -.172726, 1.056958, .240238, 1.079345, -.15264, 1.04962, .208322, 1.100058, -.131931, 1.044084, .178242, 1.118547, -.110351, 1.039387, .149493, 1.132748, -.088128, 1.033049, .119673, 1.143419, -.066069, 1.025521, .089728, 1.150316, -.043513, 1.016378, .059253, 1.155208, -.021593, 1.007506, .02914, 1.160871, 111e-6, .999916, -35e-6, 201e-6, -206e-6, 2.061, 1.025243, 504e-6, -516e-6, 2.049647, 1.025237, .002015, -.002066, 2.050169, 1.025237, .004535, -.00465, 2.051254, 1.025255, .008063, -.008266, 2.051302, 1.025236, .0126, -.012915, 2.051508, 1.025226, .018144, -.018594, 2.050981, 1.025215, .0247, -.025304, 2.050841, 1.02519, .032267, -.033038, 2.050537, 1.025152, .040852, -.041795, 2.05066, 1.02509, .05046, -.05157, 2.049921, 1.025017, .061094, -.062347, 2.04935, 1.024908, .072762, -.074111, 2.048517, 1.02476, .085475, -.086661, 2.047009, 1.024555, .099249, -.10016, 2.045261, 1.024278, .114106, -.114628, 2.043508, 1.023941, .130032, -.130002, 2.041321, 1.023488, .14705, -.145985, 2.038299, 1.022905, .165164, -.162762, 2.034658, 1.022151, .18438, -.180172, 2.030312, 1.0212, .204704, -.198022, 2.024944, 1.019966, .226129, -.216359, 2.018546, 1.018424, .248582, -.234923, 2.010153, 1.016519, .272011, -.253474, 1.999659, 1.014072, .296259, -.27182, 1.986076, 1.011071, .321423, -.289959, 1.970618, 1.007389, .346897, -.307283, 1.949667, 1.002955, .37275, -.323817, 1.925287, .997633, .398603, -.339241, 1.896006, .991354, .424351, -.353633, 1.863658, .983937, .449887, -.36666, 1.82743, .975254, .475715, -.378213, 1.789521, .964753, .502204, -.387133, 1.745632, .951594, .530179, -.394976, 1.705347, .936344, .556732, -.400134, 1.658928, .918907, .583123, -.403439, 1.613077, .899504, .609477, -.405285, 1.567884, .878172, .634927, -.405055, 1.523507, .854396, .660357, -.403494, 1.481712, .829259, .684851, -.400104, 1.439, .802359, .709654, -.395536, 1.400956, .773534, .733472, -.388996, 1.362156, .74323, .757502, -.380263, 1.325113, .71109, .782249, -.370594, 1.292913, .677166, .806017, -.359509, 1.262088, .642527, .828687, -.347126, 1.232059, .607589, .852372, -.334474, 1.20716, .571938, .874266, -.320074, 1.181978, .535518, .898168, -.304719, 1.161156, .498375, .920456, -.288246, 1.140667, .461179, .942832, -.271311, 1.12278, .424533, .966458, -.254154, 1.108743, .387784, .988907, -.235659, 1.093872, .351689, 1.011557, -.216322, 1.081959, .315743, 1.035099, -.197007, 1.070885, .280402, 1.056354, -.176878, 1.059968, .246472, 1.079854, -.156058, 1.051815, .212818, 1.101494, -.134772, 1.045757, .182143, 1.120587, -.113071, 1.041169, .152867, 1.135399, -.090411, 1.034844, .122796, 1.146612, -.067477, 1.026974, .091888, 1.153168, -.044849, 1.017303, .060779, 1.157912, -.021998, 1.007735, .029919, 1.163607, 121e-6, .999959, 3e-6, 2e-4, -216e-6, 2.163956, 1.077737, 504e-6, -543e-6, 2.161128, 1.077732, .002016, -.002173, 2.162732, 1.077729, .004535, -.004887, 2.161402, 1.077749, .008066, -.008692, 2.163252, 1.077732, .012599, -.013576, 2.1613, 1.077727, .018145, -.019546, 2.161151, 1.077702, .024702, -.026599, 2.161223, 1.077675, .032272, -.034729, 2.160949, 1.077632, .040862, -.043936, 2.160967, 1.077575, .05047, -.054203, 2.160035, 1.077473, .061113, -.065528, 2.15949, 1.077348, .072794, -.077882, 2.158517, 1.077178, .085528, -.09103, 2.156605, 1.076937, .099337, -.105251, 2.154828, 1.076631, .114228, -.120456, 2.152812, 1.076229, .130202, -.136573, 2.150298, 1.075713, .147284, -.153306, 2.146752, 1.075031, .16548, -.170931, 2.142744, 1.074173, .184793, -.189083, 2.137475, 1.073063, .205224, -.20784, 2.13132, 1.071683, .226743, -.226939, 2.123154, 1.069914, .249401, -.246344, 2.114086, 1.067718, .272955, -.26564, 2.101599, 1.064924, .297494, -.284846, 2.086612, 1.061512, .322731, -.303452, 2.067356, 1.057359, .348451, -.32133, 2.043711, 1.052294, .374451, -.338201, 2.015033, 1.046153, .400454, -.353816, 1.981139, 1.039003, .426434, -.368216, 1.944128, 1.030498, .452088, -.381251, 1.903094, 1.020454, .477901, -.392833, 1.860402, 1.008793, .504173, -.402408, 1.814402, .994791, .53152, -.409545, 1.766273, .977733, .558049, -.414351, 1.714119, .958625, .584778, -.417437, 1.664612, .937189, .610808, -.418519, 1.613793, .913543, .636915, -.418094, 1.565942, .888137, .662204, -.415742, 1.518783, .860728, .686848, -.411746, 1.473306, .831793, .710992, -.406153, 1.430153, .800862, .735382, -.399519, 1.389824, .768768, .759079, -.390927, 1.350744, .734825, .782912, -.380111, 1.313559, .69945, .806746, -.368383, 1.280028, .663191, .830269, -.355606, 1.249814, .625927, .853305, -.341988, 1.221138, .588644, .876326, -.327545, 1.195837, .550849, .898322, -.311779, 1.171844, .512694, .921811, -.294944, 1.150671, .474225, .944563, -.277333, 1.132224, .435772, .967089, -.25934, 1.115422, .398001, .989754, -.240836, 1.100405, .360802, 1.01247, -.221293, 1.086533, .323566, 1.036426, -.201191, 1.075496, .287387, 1.058709, -.18059, 1.064233, .252184, 1.081593, -.15981, 1.055296, .218441, 1.103146, -.137772, 1.047978, .186223, 1.122814, -.115347, 1.042693, .156019, 1.13779, -.092582, 1.036049, .125579, 1.149184, -.069152, 1.027944, .093986, 1.156062, -.045661, 1.018039, .062122, 1.160733, -.022719, 1.008072, .03065, 1.166487, 231e-6, 1.000063, -12e-5, 201e-6, -228e-6, 2.308308, 1.133128, 504e-6, -571e-6, 2.283756, 1.133123, .002016, -.002284, 2.283756, 1.133123, .004535, -.005138, 2.28331, 1.133144, .008048, -.009119, 2.266192, 1.133138, .0126, -.014274, 2.284377, 1.13311, .018147, -.020553, 2.284204, 1.133093, .024702, -.027964, 2.283517, 1.13306, .032272, -.03651, 2.282997, 1.133007, .040866, -.046188, 2.282986, 1.13293, .050481, -.056979, 2.28226, 1.132824, .061133, -.068881, 2.281533, 1.132678, .07283, -.08185, 2.280504, 1.132481, .085592, -.095657, 2.278304, 1.132202, .099431, -.110594, 2.276269, 1.131845, .11436, -.12659, 2.27389, 1.131383, .130388, -.143454, 2.270761, 1.130784, .147547, -.161029, 2.266794, 1.130003, .165836, -.179523, 2.262332, 1.129016, .185269, -.198527, 2.256326, 1.127738, .205822, -.218138, 2.249031, 1.126156, .227527, -.238141, 2.239993, 1.124132, .250325, -.258302, 2.228878, 1.121594, .27407, -.278329, 2.214204, 1.118449, .298793, -.29831, 2.196654, 1.114528, .324131, -.317462, 2.173394, 1.109783, .350101, -.335853, 2.146395, 1.103901, .376293, -.353064, 2.112341, 1.096954, .402547, -.36895, 2.0737, 1.088642, .428791, -.383462, 2.031152, 1.078946, .454976, -.396635, 1.986661, 1.067536, .480566, -.407873, 1.937038, 1.054403, .506154, -.417303, 1.885155, 1.038894, .532862, -.424194, 1.830369, 1.020535, .560354, -.429344, 1.776976, .999295, .587114, -.431949, 1.721214, .97599, .613345, -.432547, 1.665739, .950239, .639335, -.431338, 1.6122, .922467, .664996, -.428473, 1.561035, .892593, .688947, -.423355, 1.50824, .861325, .713403, -.417235, 1.461776, .828289, .737649, -.409848, 1.418888, .793863, .761275, -.400901, 1.376807, .758074, .784778, -.390174, 1.337204, .721974, .808762, -.377683, 1.301527, .682718, .831993, -.364037, 1.267144, .644001, .854696, -.349494, 1.236023, .605478, .877933, -.334499, 1.209284, .565588, .90018, -.318435, 1.183967, .526138, .923039, -.301669, 1.161513, .486524, .945895, -.283298, 1.140838, .446747, .968069, -.264438, 1.122475, .408041, .991179, -.245463, 1.106968, .369477, 1.012926, -.22568, 1.091435, .331626, 1.036995, -.205401, 1.079561, .294288, 1.060909, -.18431, 1.068215, .257696, 1.083531, -.162846, 1.058133, .223343, 1.105644, -.14104, 1.050851, .190541, 1.125691, -.117965, 1.045001, .15931, 1.141297, -.094377, 1.038028, .128238, 1.152672, -.070831, 1.029694, .096282, 1.159333, -.046853, 1.019136, .06372, 1.163819, -.022991, 1.008518, .031234, 1.169564, 125e-6, 1.000069, -24e-6, 202e-6, -241e-6, 2.458341, 1.191742, 504e-6, -6e-4, 2.418738, 1.19174, .002015, -.002401, 2.418821, 1.19173, .004535, -.005405, 2.421986, 1.191756, .008071, -.009618, 2.424988, 1.191753, .0126, -.015012, 2.420242, 1.191727, .018145, -.021612, 2.419937, 1.191703, .024704, -.02941, 2.419746, 1.191662, .032278, -.038398, 2.419409, 1.191604, .040874, -.048574, 2.418995, 1.191515, .050496, -.05992, 2.41819, 1.191389, .06116, -.072432, 2.417487, 1.191221, .072871, -.086009, 2.415853, 1.190984, .085664, -.100559, 2.413669, 1.190664, .099543, -.116283, 2.411423, 1.190256, .11452, -.133071, 2.408711, 1.189719, .130616, -.15067, 2.4049, 1.189019, .147856, -.169197, 2.400512, 1.188125, .166235, -.188545, 2.394939, 1.186972, .185804, -.20848, 2.388232, 1.185515, .206488, -.228883, 2.37919, 1.183673, .228383, -.249897, 2.369208, 1.181382, .251305, -.270851, 2.355459, 1.178478, .275349, -.29178, 2.339142, 1.174857, .300106, -.312257, 2.316655, 1.170411, .325849, -.332225, 2.29154, 1.164883, .351782, -.350862, 2.257242, 1.158196, .378248, -.368431, 2.218671, 1.150173, .404674, -.384428, 2.17368, 1.140703, .431385, -.39923, 2.127083, 1.129555, .457407, -.411875, 2.073236, 1.116436, .483275, -.423013, 2.018223, 1.101373, .509278, -.432624, 1.962674, 1.084257, .534751, -.439261, 1.900814, 1.064592, .561895, -.443801, 1.839558, 1.040881, .588677, -.445872, 1.777763, 1.015208, .6149, -.445896, 1.71655, .987252, .641051, -.444148, 1.657984, .957271, .666409, -.440299, 1.600832, .924841, .691872, -.435318, 1.548237, .891185, .716638, -.428631, 1.497572, .855929, .739864, -.419872, 1.447043, .819676, .763707, -.410456, 1.403648, .781455, .786744, -.39939, 1.360844, .742965, .809585, -.386381, 1.320529, .70326, .834164, -.372622, 1.286467, .662385, .856713, -.357177, 1.252306, .621379, .87982, -.341458, 1.22307, .580238, .902721, -.325024, 1.197115, .539028, .92465, -.307543, 1.172314, .498592, .947613, -.289557, 1.151171, .45798, .96959, -.269799, 1.129986, .417696, .992961, -.250111, 1.113321, .377529, 1.014582, -.229761, 1.097149, .339096, 1.038069, -.209375, 1.083913, .301119, 1.061661, -.188038, 1.071241, .263506, 1.085069, -.165874, 1.060508, .227921, 1.107744, -.143437, 1.05293, .194062, 1.127982, -.120574, 1.046396, .162506, 1.144541, -.096569, 1.03988, .130788, 1.155876, -.072039, 1.030946, .098057, 1.162719, -.047888, 1.020124, .064956, 1.167089, -.02374, 1.008953, .031966, 1.172775, 277e-6, 1.000067, -111e-6, 2e-4, -251e-6, 2.573709, 1.253951, 504e-6, -632e-6, 2.572401, 1.25394, .002015, -.002527, 2.571267, 1.253927, .004535, -.005687, 2.572481, 1.253948, .008062, -.010108, 2.571851, 1.253941, .012588, -.01578, 2.568431, 1.253934, .018139, -.022731, 2.569765, 1.253893, .024709, -.030948, 2.572115, 1.253853, .032283, -.040401, 2.571456, 1.253785, .040883, -.051105, 2.571041, 1.253683, .050514, -.063041, 2.570153, 1.253538, .061188, -.076195, 2.569085, 1.253336, .072926, -.090402, 2.567184, 1.253065, .085746, -.105745, 2.564731, 1.252697, .099661, -.122296, 2.561995, 1.252218, .114699, -.139912, 2.559019, 1.25159, .130882, -.158362, 2.555017, 1.250766, .148202, -.177856, 2.549419, 1.249744, .166706, -.198049, 2.542908, 1.248423, .186404, -.219014, 2.535205, 1.246741, .207272, -.240376, 2.524893, 1.244596, .229345, -.26223, 2.512804, 1.241917, .252494, -.284134, 2.496923, 1.23861, .27669, -.305828, 2.476583, 1.234474, .301798, -.327107, 2.451548, 1.229292, .327423, -.3473, 2.41863, 1.222997, .353848, -.366699, 2.381002, 1.215366, .380342, -.384421, 2.334413, 1.206199, .40739, -.400855, 2.28566, 1.195374, .433913, -.415241, 2.228604, 1.18229, .460837, -.428275, 2.171532, 1.167385, .486381, -.438573, 2.105639, 1.150401, .511959, -.447348, 2.040835, 1.13099, .537586, -.454152, 1.974797, 1.109302, .564035, -.458684, 1.907895, 1.084131, .59069, -.460058, 1.839482, 1.055803, .61725, -.459662, 1.772332, 1.025103, .643406, -.45726, 1.707313, .992502, .668794, -.452666, 1.644722, .957657, .69393, -.446641, 1.586832, .92134, .718708, -.439121, 1.531197, .883841, .743469, -.430429, 1.480765, .844931, .76608, -.419622, 1.430338, .804786, .789801, -.408368, 1.386295, .764206, .812718, -.395392, 1.343758, .722565, .835453, -.380699, 1.304655, .680585, .858801, -.364834, 1.269287, .637235, .881537, -.348092, 1.237493, .594579, .904656, -.331087, 1.208862, .552313, .926357, -.312966, 1.182365, .51008, .949001, -.294684, 1.159452, .468677, .971598, -.275361, 1.138706, .426723, .994905, -.254947, 1.120552, .385875, 1.017981, -.234109, 1.104215, .345751, 1.04084, -.21304, 1.089276, .306762, 1.063893, -.191616, 1.075845, .269066, 1.086907, -.169272, 1.063788, .232171, 1.109937, -.146076, 1.054977, .197826, 1.130808, -.122544, 1.048572, .165272, 1.146831, -.098492, 1.040742, .13328, 1.158955, -.07371, 1.031818, .100262, 1.166161, -.04861, 1.020747, .066165, 1.170491, -.024209, 1.00938, .032741, 1.176111, 1e-5, 1.000042, 56e-6, 202e-6, -267e-6, 2.786357, 1.320169, 504e-6, -665e-6, 2.741889, 1.320168, .002015, -.00266, 2.74, 1.320143, .004536, -.005987, 2.744276, 1.320161, .008063, -.010644, 2.743432, 1.320162, .0126, -.016628, 2.741741, 1.320148, .018144, -.023937, 2.741314, 1.320127, .024708, -.032577, 2.741916, 1.320061, .03229, -.042536, 2.742132, 1.319976, .040894, -.053799, 2.741199, 1.319861, .050533, -.066361, 2.740258, 1.319691, .061223, -.080202, 2.739045, 1.319458, .072985, -.095109, 2.736519, 1.319138, .085841, -.111296, 2.733903, 1.318715, .099808, -.128685, 2.730944, 1.318156, .114903, -.147202, 2.727293, 1.317424, .131164, -.166575, 2.722169, 1.316485, .148599, -.187019, 2.716148, 1.315274, .167245, -.20824, 2.708701, 1.313733, .187078, -.230151, 2.698998, 1.311792, .208153, -.252538, 2.687341, 1.309343, .230418, -.275295, 2.672621, 1.306247, .253802, -.298066, 2.653619, 1.302374, .278261, -.320673, 2.629943, 1.297573, .303527, -.342528, 2.599228, 1.291625, .329571, -.363531, 2.562226, 1.284374, .355939, -.382963, 2.515491, 1.275478, .382987, -.401306, 2.464858, 1.264866, .409917, -.417455, 2.404877, 1.252184, .437015, -.432067, 2.341408, 1.237415, .463474, -.444204, 2.271837, 1.220687, .489835, -.454631, 2.200593, 1.200973, .516054, -.463338, 2.129733, 1.179346, .541397, -.469425, 2.055635, 1.155039, .566798, -.473526, 1.980812, 1.127866, .593114, -.474632, 1.904723, 1.097304, .619945, -.473597, 1.832456, 1.063603, .646325, -.470656, 1.761501, 1.027971, .67232, -.465675, 1.694248, .990692, .697163, -.458527, 1.629227, .951582, .721472, -.449904, 1.568132, .911197, .745855, -.44014, 1.512084, .869745, .770089, -.429338, 1.460694, .827648, .792546, -.416701, 1.410739, .784728, .815161, -.403151, 1.365438, .741884, .837994, -.388714, 1.324811, .6978, .86122, -.372573, 1.287723, .653341, .883737, -.355024, 1.252491, .609455, .906784, -.337092, 1.221844, .565275, .928493, -.31837, 1.192881, .521558, .951495, -.299605, 1.169131, .478149, .973586, -.280067, 1.146316, .436325, .9964, -.259823, 1.12786, .394409, 1.01978, -.238313, 1.110521, .353045, 1.042775, -.216506, 1.093915, .312803, 1.066822, -.194695, 1.080326, .2741, 1.089869, -.17229, 1.067722, .236657, 1.113606, -.149264, 1.058471, .201603, 1.134229, -.124814, 1.050701, .168398, 1.150922, -.10007, 1.043051, .135616, 1.163224, -.075155, 1.033742, .102144, 1.169965, -.049933, 1.021818, .067532, 1.1742, -.024461, 1.009916, .033215, 1.179766, 188e-6, 1.000045, -14e-6, 202e-6, -281e-6, 2.964186, 1.39088, 505e-6, -702e-6, 2.945157, 1.390903, .002015, -.002802, 2.931184, 1.390863, .004535, -.006307, 2.935673, 1.3909, .008063, -.011213, 2.934274, 1.39089, .012598, -.017516, 2.932216, 1.390876, .018147, -.025221, 2.933324, 1.390832, .024711, -.034322, 2.933945, 1.390769, .032295, -.04481, 2.933496, 1.390674, .040904, -.056673, 2.932487, 1.390538, .050555, -.069906, 2.931571, 1.390342, .061259, -.084468, 2.929914, 1.390064, .073053, -.100152, 2.927039, 1.389695, .085948, -.117202, 2.924241, 1.389201, .099968, -.135531, 2.92076, 1.388548, .115135, -.154906, 2.915998, 1.387692, .131496, -.175352, 2.910285, 1.386611, .149049, -.196783, 2.903174, 1.38519, .167848, -.219066, 2.894584, 1.383407, .187879, -.241983, 2.883171, 1.381148, .209143, -.265398, 2.869102, 1.378261, .231689, -.289254, 2.852238, 1.37469, .255223, -.312776, 2.828264, 1.370166, .279952, -.33626, 2.800175, 1.364591, .305572, -.358865, 2.764282, 1.357758, .33165, -.380223, 2.717845, 1.349413, .358491, -.400252, 2.665326, 1.339084, .385445, -.418422, 2.602293, 1.326773, .412947, -.434993, 2.536973, 1.312141, .439681, -.448757, 2.459463, 1.295205, .467272, -.461427, 2.38625, 1.275573, .493568, -.471102, 2.303225, 1.2534, .519743, -.47893, 2.221945, 1.22889, .544882, -.484098, 2.136425, 1.20173, .57069, -.488125, 2.057093, 1.172022, .595905, -.489185, 1.975334, 1.139312, .622747, -.487535, 1.895055, 1.103038, .648695, -.483482, 1.815995, 1.064364, .675159, -.478096, 1.744272, 1.024098, .700714, -.470492, 1.675257, .982186, .725641, -.461398, 1.609135, .939137, .748552, -.449825, 1.545091, .894791, .772808, -.438185, 1.489394, .850373, .795928, -.425073, 1.437026, .805287, .8189, -.411028, 1.389654, .760003, .841633, -.396047, 1.345873, .714914, .863213, -.379637, 1.305185, .669271, .886662, -.362227, 1.269147, .622935, .908504, -.343068, 1.234714, .577757, .931425, -.323982, 1.204997, .532922, .953835, -.304347, 1.178871, .488154, .975813, -.284219, 1.155019, .444885, .997662, -.263544, 1.133941, .402224, 1.021167, -.242611, 1.1161, .36053, 1.044038, -.220065, 1.098348, .318968, 1.068837, -.19758, 1.084605, .279107, 1.092548, -.174779, 1.071217, .241111, 1.116157, -.151596, 1.060486, .204913, 1.137486, -.127478, 1.052751, .17141, 1.154694, -.101915, 1.044807, .137999, 1.166867, -.076246, 1.034824, .103807, 1.173715, -.050661, 1.022501, .068802, 1.178236, -.025355, 1.010324, .034155, 1.183545, 205e-6, 1.000059, -11e-5, 201e-6, -294e-6, 3.16108, 1.466721, 505e-6, -74e-5, 3.155526, 1.466737, .002016, -.002957, 3.152852, 1.466688, .004537, -.006655, 3.150654, 1.466667, .008066, -.011828, 3.153109, 1.466694, .012604, -.018479, 3.152143, 1.466721, .01815, -.026598, 3.151025, 1.466636, .024714, -.036191, 3.1503, 1.466562, .032301, -.047249, 3.149861, 1.46645, .040924, -.059766, 3.149548, 1.466289, .050579, -.073703, 3.147516, 1.466055, .061306, -.089022, 3.14568, 1.465738, .073135, -.105563, 3.142428, 1.465301, .086075, -.123544, 3.139113, 1.464715, .100153, -.142853, 3.135064, 1.463956, .115411, -.163183, 3.129509, 1.462962, .131876, -.18476, 3.122959, 1.46167, .14957, -.207172, 3.114153, 1.460045, .168523, -.230578, 3.103626, 1.457945, .188784, -.254658, 3.090818, 1.455279, .210264, -.279114, 3.073352, 1.451998, .23303, -.30393, 3.052592, 1.44778, .256959, -.328517, 3.025187, 1.442568, .281901, -.352755, 2.990341, 1.436026, .307728, -.375894, 2.94682, 1.427979, .334197, -.397924, 2.892845, 1.418249, .360966, -.417914, 2.827937, 1.40637, .388478, -.436526, 2.758006, 1.392134, .415567, -.452366, 2.674696, 1.375244, .443518, -.466917, 2.595136, 1.35566, .470631, -.478417, 2.504173, 1.333123, .497419, -.487825, 2.413227, 1.308181, .523961, -.495064, 2.321239, 1.280227, .549708, -.499844, 2.228911, 1.249894, .575296, -.502844, 2.138834, 1.21713, .600168, -.503368, 2.04903, 1.181412, .625874, -.501622, 1.962267, 1.142648, .652164, -.496936, 1.8769, 1.101268, .678029, -.490319, 1.796344, 1.057782, .703248, -.481575, 1.718925, 1.012884, .72852, -.471822, 1.648358, .966487, .752577, -.460134, 1.581989, .91988, .776163, -.447164, 1.520109, .873087, .800016, -.433601, 1.465081, .825803, .822176, -.418388, 1.412564, .778249, .844873, -.402704, 1.366184, .730849, .865955, -.385633, 1.321865, .684037, .888173, -.368255, 1.283464, .637192, .910994, -.349332, 1.249215, .590131, .93427, -.329612, 1.218366, .543213, .956653, -.309228, 1.189808, .497752, .978476, -.28831, 1.163674, .452837, 1.000755, -.267243, 1.141389, .409481, 1.023827, -.246015, 1.122012, .367354, 1.045572, -.223777, 1.103303, .325171, 1.070445, -.200837, 1.08801, .284442, 1.094268, -.177211, 1.07365, .245138, 1.118639, -.153531, 1.063051, .208289, 1.139786, -.129074, 1.053921, .173607, 1.157848, -.104051, 1.045968, .140467, 1.170697, -.077694, 1.035782, .105594, 1.177874, -.051393, 1.023483, .069898, 1.182242, -.025392, 1.01062, .034532, 1.187612, -32e-6, 1.000062, -35e-6, 202e-6, -313e-6, 3.450327, 1.548291, 504e-6, -78e-5, 3.396162, 1.548289, .002015, -.00312, 3.395621, 1.54826, .004533, -.007019, 3.394299, 1.548217, .008066, -.012486, 3.398803, 1.548274, .0126, -.0195, 3.396363, 1.548245, .018151, -.028076, 3.396805, 1.548192, .024722, -.038209, 3.396384, 1.548109, .032306, -.049868, 3.395158, 1.547979, .040936, -.063077, 3.394303, 1.547785, .05061, -.077791, 3.392979, 1.547513, .06136, -.093869, 3.38991, 1.547134, .073227, -.11138, 3.386669, 1.546619, .086217, -.130371, 3.382974, 1.545938, .100364, -.150684, 3.378046, 1.545039, .115733, -.172116, 3.371719, 1.54388, .132309, -.194809, 3.363764, 1.54238, .150174, -.218431, 3.353699, 1.540462, .16934, -.242954, 3.341397, 1.538002, .189788, -.268175, 3.324957, 1.534894, .211581, -.293776, 3.304776, 1.530954, .234561, -.319619, 3.278192, 1.526033, .258776, -.345089, 3.24491, 1.519926, .284059, -.370176, 3.203338, 1.512296, .310312, -.394171, 3.152477, 1.502956, .336748, -.416137, 3.083616, 1.491463, .364029, -.436752, 3.010481, 1.477493, .391575, -.455102, 2.925454, 1.460933, .419409, -.471378, 2.83438, 1.441554, .446811, -.484714, 2.733329, 1.418861, .474489, -.496021, 2.63363, 1.393405, .501751, -.504991, 2.530935, 1.364633, .528488, -.511392, 2.426653, 1.333234, .554428, -.515395, 2.323633, 1.299138, .580434, -.517761, 2.224964, 1.262462, .605474, -.517598, 2.127228, 1.223784, .629888, -.514946, 2.030545, 1.182321, .655579, -.510177, 1.93907, 1.138515, .68194, -.503097, 1.852355, 1.091502, .707228, -.493537, 1.768084, 1.043464, .731894, -.482372, 1.69084, .994242, .756741, -.470312, 1.619277, .944749, .78016, -.456412, 1.55343, .894816, .803384, -.441492, 1.493357, .845202, .826347, -.425944, 1.43783, .795954, .849145, -.409532, 1.388578, .746915, .870617, -.391988, 1.341527, .698025, .892943, -.374229, 1.302188, .649579, .913828, -.355148, 1.262877, .601833, .93683, -.335238, 1.230136, .554521, .958687, -.313939, 1.199596, .507208, .982008, -.292741, 1.173619, .461357, 1.003691, -.27094, 1.149015, .416031, 1.027223, -.249102, 1.128689, .372457, 1.050048, -.226899, 1.109444, .330281, 1.074105, -.204329, 1.092943, .288987, 1.098971, -.18056, 1.078591, .249075, 1.123324, -.155987, 1.066885, .211519, 1.145445, -.130929, 1.057617, .176506, 1.162856, -.105269, 1.048453, .142345, 1.17536, -.079267, 1.037439, .107452, 1.182514, -.052547, 1.024393, .071252, 1.186575, -.025744, 1.011093, .035019, 1.19205, 318e-6, 1.000013, -152e-6, 204e-6, -334e-6, 3.909175, 1.636412, 504e-6, -825e-6, 3.678647, 1.63641, .002015, -.003298, 3.678315, 1.636387, .004533, -.007417, 3.674126, 1.63631, .008062, -.01319, 3.676771, 1.636376, .012603, -.020613, 3.678135, 1.636369, .018153, -.029675, 3.677315, 1.636299, .024723, -.040378, 3.676872, 1.636196, .032318, -.052708, 3.67575, 1.636038, .040955, -.06666, 3.674803, 1.63581, .050645, -.082203, 3.672735, 1.635494, .061429, -.09915, 3.669047, 1.635048, .073333, -.117679, 3.665401, 1.634437, .086388, -.137725, 3.661315, 1.633634, .10062, -.159081, 3.654992, 1.632571, .116087, -.181721, 3.647341, 1.631202, .13282, -.205611, 3.637877, 1.629432, .150867, -.230542, 3.626333, 1.627161, .170234, -.256239, 3.610671, 1.624266, .190981, -.282751, 3.591685, 1.620589, .213013, -.30943, 3.565864, 1.615999, .236387, -.336427, 3.534826, 1.610216, .260943, -.362931, 3.493984, 1.603047, .286497, -.388644, 3.442075, 1.59392, .312769, -.412912, 3.375973, 1.582961, .339832, -.435635, 3.299355, 1.569343, .367214, -.456181, 3.208994, 1.553137, .394935, -.474325, 3.10891, 1.533791, .422935, -.490318, 3.001767, 1.511093, .451166, -.503827, 2.891735, 1.485145, .478695, -.514185, 2.77343, 1.455617, .506313, -.522502, 2.657639, 1.422946, .533427, -.528119, 2.541132, 1.387843, .559942, -.53143, 2.42695, 1.349542, .58515, -.531978, 2.312437, 1.309303, .6105, -.531054, 2.205966, 1.26628, .63538, -.528058, 2.101993, 1.221709, .659852, -.522751, 2.00295, 1.175062, .685151, -.515026, 1.908647, 1.125078, .71092, -.50502, 1.819389, 1.074296, .736066, -.493268, 1.735806, 1.02242, .760503, -.480032, 1.658607, .97023, .785091, -.465986, 1.589424, .917077, .807523, -.449721, 1.522533, .864888, .830974, -.433461, 1.465416, .813006, .852659, -.415808, 1.409076, .761689, .874841, -.397855, 1.360758, .711258, .896322, -.379041, 1.316829, .661721, .918134, -.360048, 1.278574, .612263, .939356, -.340108, 1.2422, .564369, .961025, -.318877, 1.210305, .516506, .984371, -.29713, 1.183689, .469342, 1.006905, -.274661, 1.157466, .42308, 1.029941, -.252234, 1.135066, .378315, 1.052751, -.229268, 1.114518, .335169, 1.077981, -.206662, 1.09776, .293336, 1.102542, -.183331, 1.082051, .252984, 1.126539, -.158797, 1.068935, .21499, 1.149023, -.133014, 1.058996, .178903, 1.16755, -.106641, 1.050245, .144559, 1.179994, -.079952, 1.038648, .108667, 1.187104, -.053316, 1.025284, .072209, 1.191406, -.026826, 1.011453, .035833, 1.196748, 226e-6, 1.000034, -61e-6, 2e-4, -346e-6, 3.996419, 1.732034, 504e-6, -873e-6, 4.000138, 1.732038, .002016, -.003492, 4.002078, 1.732012, .004538, -.007859, 4.005626, 1.731962, .008064, -.013963, 3.9985, 1.731999, .01259, -.021794, 3.995024, 1.732004, .018154, -.031406, 3.999233, 1.731901, .024727, -.042733, 3.998497, 1.731774, .032327, -.055781, 3.997064, 1.731599, .040974, -.070543, 3.995856, 1.731325, .050685, -.086984, 3.993839, 1.730945, .061506, -.104897, 3.989519, 1.730417, .073458, -.124506, 3.985313, 1.729697, .086573, -.145706, 3.979984, 1.728747, .100909, -.168211, 3.972562, 1.727491, .116509, -.192198, 3.963836, 1.725854, .133404, -.21728, 3.951919, 1.723749, .151659, -.243556, 3.937734, 1.721093, .171288, -.270611, 3.919021, 1.71764, .192301, -.298389, 3.895171, 1.713272, .214683, -.326338, 3.864171, 1.707825, .238392, -.354394, 3.824682, 1.700956, .263151, -.381636, 3.771168, 1.692392, .289155, -.408266, 3.709961, 1.681769, .315832, -.43307, 3.630302, 1.668539, .342942, -.455741, 3.534719, 1.652513, .370892, -.476655, 3.431531, 1.633428, .398985, -.494692, 3.314933, 1.610694, .427206, -.510313, 3.189741, 1.58424, .455266, -.52276, 3.058325, 1.554195, .483472, -.532872, 2.927213, 1.520805, .511192, -.540229, 2.794112, 1.484026, .538706, -.545105, 2.663786, 1.443796, .565422, -.547251, 2.534841, 1.401429, .59127, -.547115, 2.408437, 1.356231, .616787, -.545113, 2.291284, 1.308887, .64138, -.540853, 2.177478, 1.260447, .665344, -.534561, 2.069265, 1.210634, .690147, -.527115, 1.969776, 1.158569, .714578, -.516171, 1.870847, 1.104593, .740349, -.504048, 1.782674, 1.049578, .764563, -.489683, 1.698614, .994458, .78871, -.474541, 1.624447, .938612, .812154, -.458099, 1.554453, .883694, .834566, -.440345, 1.490045, .83022, .857486, -.422491, 1.432889, .776499, .879224, -.403588, 1.380669, .724257, .899971, -.383819, 1.333124, .673311, .922111, -.36425, 1.292648, .622999, .942842, -.343873, 1.253933, .573304, .964398, -.323206, 1.221027, .52509, .98686, -.301711, 1.191806, .47758, 1.00976, -.278695, 1.165162, .430624, 1.033347, -.255591, 1.141715, .384482, 1.055937, -.232039, 1.119739, .340532, 1.081178, -.208664, 1.102117, .297311, 1.105696, -.184935, 1.085062, .256227, 1.129575, -.160673, 1.070918, .217709, 1.152135, -.135414, 1.060642, .181471, 1.171221, -.108462, 1.051041, .14638, 1.184412, -.081008, 1.039694, .11012, 1.19182, -.05371, 1.025903, .073052, 1.196195, -.026625, 1.011816, .036129, 1.201677, -175e-6, .999945, 98e-6, 196e-6, -36e-5, 4.100786, 1.83629, 504e-6, -925e-6, 4.370184, 1.836295, .002018, -.003706, 4.385247, 1.836243, .004534, -.008324, 4.370146, 1.83621, .008064, -.014805, 4.372335, 1.836256, .012597, -.023116, 4.359918, 1.836259, .018158, -.033299, 4.371503, 1.836123, .024732, -.045301, 4.370533, 1.835988, .032344, -.059143, 4.369649, 1.835768, .040999, -.074779, 4.367861, 1.835454, .050739, -.092178, 4.364322, 1.834974, .061594, -.111161, 4.359221, 1.834355, .073604, -.131958, 4.35462, 1.833499, .086796, -.154393, 4.347915, 1.832355, .101246, -.178201, 4.339152, 1.83088, .11699, -.203531, 4.328327, 1.828936, .134086, -.230043, 4.31424, 1.826442, .152589, -.257718, 4.296795, 1.82323, .172514, -.286176, 4.273985, 1.819124, .193853, -.315295, 4.244136, 1.813909, .216582, -.344507, 4.205152, 1.80741, .240668, -.373646, 4.154781, 1.799084, .265904, -.401897, 4.091563, 1.788905, .292226, -.429136, 4.013199, 1.776206, .319045, -.454057, 3.912886, 1.7605, .346721, -.477219, 3.800927, 1.741586, .374849, -.497883, 3.675652, 1.718818, .403078, -.515504, 3.536892, 1.692138, .431597, -.530621, 3.391351, 1.661434, .460246, -.542852, 3.242817, 1.626989, .488899, -.552238, 3.093685, 1.588582, .517215, -.559045, 2.944163, 1.5463, .54448, -.562351, 2.794189, 1.501299, .571542, -.563394, 2.650239, 1.453758, .598167, -.56259, 2.513757, 1.403321, .624104, -.559636, 2.384203, 1.352431, .648789, -.554148, 2.259149, 1.298758, .672715, -.546779, 2.14025, 1.244943, .696258, -.537896, 2.030401, 1.189971, .720048, -.527401, 1.928311, 1.134526, .744078, -.514142, 1.830175, 1.076504, .768895, -.499352, 1.740731, 1.018032, .792551, -.482982, 1.658911, .96025, .817007, -.466406, 1.586579, .903029, .839035, -.447616, 1.516969, .846484, .862742, -.429261, 1.458675, .79142, .884307, -.409479, 1.402989, .737125, .905641, -.389303, 1.352817, .683912, .926185, -.368344, 1.306684, .63269, .947229, -.347366, 1.267395, .581739, .969502, -.32672, 1.233192, .532305, .990758, -.304973, 1.201017, .484166, 1.012749, -.282816, 1.173018, .437385, 1.035533, -.259084, 1.147184, .390755, 1.059915, -.235239, 1.125388, .345399, 1.084348, -.211044, 1.105859, .301356, 1.109544, -.186698, 1.088888, .259708, 1.13377, -.1619, 1.073848, .220324, 1.157553, -.136604, 1.06319, .183857, 1.176461, -.110428, 1.05311, .148521, 1.190137, -.082898, 1.041484, .112124, 1.197215, -.054554, 1.026844, .07416, 1.201654, -.026744, 1.012264, .036527, 1.207085, 399e-6, 1.000034, -201e-6, 191e-6, -373e-6, 4.194318, 1.950551, 504e-6, -983e-6, 4.80435, 1.950552, .002015, -.003931, 4.80282, 1.950518, .004536, -.008847, 4.805254, 1.950472, .008064, -.015725, 4.804152, 1.950517, .012693, -.02474, 4.826828, 1.949914, .018159, -.035365, 4.803103, 1.950349, .02474, -.048122, 4.80322, 1.950183, .032361, -.062822, 4.801522, 1.949917, .041034, -.07943, 4.799593, 1.949538, .050815, -.097841, 4.797179, 1.948972, .061702, -.118026, 4.789557, 1.948246, .073766, -.140112, 4.783293, 1.947204, .087066, -.163819, 4.775698, 1.945855, .101637, -.189122, 4.764612, 1.944052, .117558, -.215884, 4.751486, 1.94171, .134884, -.243968, 4.734791, 1.938727, .153637, -.27317, 4.712078, 1.934891, .17389, -.303146, 4.683575, 1.929976, .195643, -.333704, 4.646766, 1.92374, .218767, -.36417, 4.596814, 1.915888, .243337, -.39453, 4.535509, 1.90597, .26886, -.423512, 4.452006, 1.893623, .295173, -.450609, 4.345682, 1.878286, .322784, -.476488, 4.231632, 1.859391, .350616, -.49942, 4.093553, 1.836912, .379127, -.519862, 3.944127, 1.809625, .40786, -.537373, 3.782223, 1.778529, .436717, -.551802, 3.615563, 1.742684, .465345, -.562951, 3.440672, 1.702289, .494158, -.571334, 3.26807, 1.658666, .522896, -.577227, 3.100668, 1.611027, .551379, -.580514, 2.937615, 1.559742, .578992, -.58061, 2.778703, 1.507257, .605095, -.577729, 2.621626, 1.451941, .630653, -.573, 2.476506, 1.395218, .656175, -.566944, 2.341592, 1.337862, .681036, -.558988, 2.216478, 1.279275, .704713, -.549211, 2.096972, 1.220526, .726894, -.53719, 1.983311, 1.161709, .749865, -.524167, 1.8811, 1.102095, .773553, -.508991, 1.785637, 1.042039, .797102, -.491658, 1.697234, .981588, .821187, -.474093, 1.62025, .921265, .843848, -.45498, 1.547071, .862757, .866662, -.435421, 1.482008, .8047, .888696, -.41499, 1.424116, .749432, .910945, -.394472, 1.372658, .694767, .9323, -.373239, 1.325157, .641106, .95285, -.351347, 1.282217, .589689, .974718, -.329809, 1.244897, .539322, .996445, -.307902, 1.212306, .490083, 1.01758, -.285392, 1.181402, .442702, 1.040342, -.262782, 1.155996, .395911, 1.064399, -.238995, 1.131708, .350206, 1.089464, -.214297, 1.111215, .305175, 1.115565, -.189293, 1.093094, .262686, 1.14064, -.163843, 1.077994, .223078, 1.163824, -.137789, 1.066014, .185651, 1.182577, -.111087, 1.055615, .150045, 1.195775, -.083945, 1.04294, .113457, 1.203175, -.056145, 1.028015, .075453, 1.207282, -.027685, 1.012552, .037217, 1.213019, 362e-6, .999938, -293e-6, 187e-6, -388e-6, 4.316009, 2.0765, 504e-6, -.001048, 5.317799, 2.076499, .002014, -.004182, 5.306557, 2.076523, .004539, -.009425, 5.317505, 2.076453, .008063, -.016737, 5.312143, 2.07641, .012614, -.026171, 5.316434, 2.076389, .018158, -.037641, 5.307836, 2.076265, .024767, -.051266, 5.315297, 2.076044, .032372, -.066859, 5.307433, 2.075743, .041066, -.084538, 5.304809, 2.07527, .050871, -.104062, 5.299277, 2.074622, .061821, -.125613, 5.293419, 2.073708, .07397, -.149085, 5.286629, 2.072457, .087375, -.174214, 5.275937, 2.070804, .102105, -.201136, 5.263267, 2.068647, .118223, -.229505, 5.246309, 2.065846, .135814, -.259217, 5.225496, 2.062189, .154887, -.28999, 5.19658, 2.057566, .17551, -.321618, 5.160716, 2.051593, .197636, -.353632, 5.112202, 2.043949, .221168, -.385303, 5.046981, 2.034445, .246099, -.416511, 4.965386, 2.022368, .27207, -.446377, 4.860735, 2.00716, .29909, -.474279, 4.73514, 1.988598, .326702, -.499809, 4.584962, 1.965865, .355017, -.52279, 4.420447, 1.938705, .383856, -.542755, 4.241942, 1.90637, .413059, -.559903, 4.053302, 1.869455, .441882, -.573174, 3.852753, 1.827946, .471516, -.584151, 3.660377, 1.781652, .500872, -.591843, 3.466027, 1.730885, .529677, -.596253, 3.272812, 1.676821, .557683, -.597604, 3.084286, 1.620064, .585652, -.596591, 2.906111, 1.560909, .612819, -.593138, 2.738258, 1.500318, .639848, -.588245, 2.584172, 1.438127, .664758, -.58014, 2.430697, 1.375746, .688754, -.570189, 2.290701, 1.312727, .712848, -.55942, 2.162679, 1.250063, .735111, -.54657, 2.042186, 1.18784, .757521, -.532944, 1.933435, 1.125513, .780056, -.517981, 1.833524, 1.063827, .802513, -.500724, 1.739053, 1.002154, .825462, -.481625, 1.652381, .939811, .848973, -.462327, 1.57756, .878279, .871521, -.441928, 1.509291, .8192, .892325, -.420297, 1.443799, .761607, .914935, -.399072, 1.389647, .705351, .936429, -.377232, 1.339903, .650213, .957614, -.355091, 1.295467, .597773, .979578, -.332767, 1.256692, .545914, 1.00086, -.310147, 1.221666, .495661, 1.02255, -.287395, 1.190775, .448026, 1.045005, -.264582, 1.162641, .40049, 1.068703, -.241464, 1.138358, .354088, 1.093098, -.217504, 1.115973, .309812, 1.11923, -.19214, 1.096284, .266297, 1.144608, -.165975, 1.080042, .225831, 1.168599, -.139174, 1.067749, .187761, 1.18797, -.11191, 1.056635, .151322, 1.20124, -.083978, 1.043566, .114337, 1.208895, -.056089, 1.028366, .076083, 1.213344, -.028369, 1.013074, .037735, 1.21922, -534e-6, .999968, 76e-6, 182e-6, -404e-6, 4.433519, 2.216201, 504e-6, -.001117, 5.911693, 2.216198, .002017, -.004469, 5.919142, 2.21619, .004536, -.010051, 5.913172, 2.21613, .008065, -.017867, 5.911791, 2.216145, .012467, -.027603, 5.785357, 2.216447, .018156, -.040159, 5.901121, 2.215958, .024758, -.05467, 5.908781, 2.215654, .032395, -.071352, 5.906098, 2.215283, .041108, -.090201, 5.902558, 2.214715, .050955, -.111004, 5.895707, 2.213905, .061968, -.134002, 5.888736, 2.212807, .074206, -.159038, 5.880633, 2.211303, .087742, -.185801, 5.867001, 2.209297, .102652, -.214368, 5.851446, 2.206657, .119006, -.244573, 5.830722, 2.203232, .136883, -.276067, 5.802688, 2.198778, .156335, -.30866, 5.767185, 2.193091, .177396, -.34194, 5.719726, 2.185858, .20007, -.375591, 5.658792, 2.176584, .224067, -.408564, 5.573508, 2.164759, .24942, -.440668, 5.465696, 2.149777, .275879, -.471138, 5.332207, 2.131225, .303307, -.499204, 5.173339, 2.108794, .331189, -.524547, 4.985102, 2.080585, .359932, -.547256, 4.785788, 2.047792, .389063, -.566479, 4.569344, 2.009518, .418725, -.583031, 4.349557, 1.965601, .448181, -.595809, 4.121278, 1.916911, .477703, -.605102, 3.892291, 1.86353, .507999, -.612462, 3.676557, 1.806286, .536889, -.615451, 3.456241, 1.745841, .565778, -.616029, 3.249464, 1.681137, .593863, -.613644, 3.050273, 1.615238, .62077, -.608268, 2.859599, 1.548003, .647171, -.601116, 2.683287, 1.480447, .673458, -.59284, 2.524036, 1.412084, .698064, -.581973, 2.371046, 1.34513, .721011, -.568963, 2.229104, 1.27844, .744293, -.555642, 2.103213, 1.212448, .766314, -.540934, 1.98537, 1.146287, .788164, -.525271, 1.878842, 1.0826, .809019, -.507986, 1.779821, 1.019978, .830947, -.489717, 1.69163, .956931, .853732, -.469345, 1.607513, .894207, .874904, -.447618, 1.531176, .833436, .897289, -.426124, 1.467302, .773611, .919226, -.404025, 1.408321, .716016, .94086, -.381454, 1.356209, .659515, .962764, -.358901, 1.310082, .604629, .984322, -.335983, 1.268485, .552335, 1.005343, -.312533, 1.230662, .501591, 1.028153, -.289452, 1.199168, .452032, 1.049283, -.265754, 1.168575, .404347, 1.073687, -.242571, 1.143533, .357445, 1.097546, -.218681, 1.119859, .312534, 1.12334, -.194465, 1.099634, .269437, 1.148166, -.168797, 1.081968, .228586, 1.172518, -.141552, 1.068789, .189866, 1.19293, -.113325, 1.057548, .152772, 1.206816, -.0848, 1.044145, .11539, 1.215045, -.056019, 1.028938, .076493, 1.220048, -.027733, 1.013338, .037767, 1.225852, 5e-5, .999927, -16e-5, 178e-6, -422e-6, 4.587902, 2.372253, 504e-6, -.001195, 6.624675, 2.372248, .002016, -.004782, 6.626884, 2.372187, .004531, -.010746, 6.607379, 2.372318, .008081, -.019161, 6.640102, 2.372084, .012637, -.029945, 6.653708, 2.372128, .018167, -.042999, 6.623837, 2.371902, .024769, -.058516, 6.624484, 2.371595, .032421, -.07637, 6.620877, 2.37112, .041164, -.096474, 6.615235, 2.370428, .051057, -.118786, 6.607844, 2.36944, .062136, -.14339, 6.599216, 2.368075, .07449, -.170034, 6.588018, 2.366218, .088179, -.198717, 6.572526, 2.363747, .103307, -.229147, 6.551868, 2.360517, .119964, -.261253, 6.526089, 2.356304, .138173, -.294703, 6.489593, 2.350797, .158072, -.329261, 6.443573, 2.343783, .179592, -.364298, 6.379764, 2.334673, .202709, -.399375, 6.295845, 2.323125, .227335, -.433616, 6.184929, 2.308547, .25323, -.466794, 6.045905, 2.28998, .2801, -.497509, 5.871803, 2.266964, .308146, -.525956, 5.672422, 2.239074, .336544, -.551101, 5.443256, 2.204809, .365223, -.572471, 5.188034, 2.164827, .395484, -.592088, 4.943783, 2.119489, .424416, -.606026, 4.6664, 2.067262, .455641, -.619671, 4.418961, 2.009937, .485298, -.627583, 4.152737, 1.9489, .514774, -.632072, 3.893344, 1.882692, .544172, -.634033, 3.645332, 1.814073, .573283, -.633239, 3.414651, 1.742717, .602155, -.630008, 3.195712, 1.669703, .63052, -.62455, 2.994536, 1.596021, .657121, -.615749, 2.799373, 1.522572, .682071, -.604738, 2.616102, 1.448978, .707605, -.593301, 2.456112, 1.37625, .731492, -.579628, 2.303517, 1.305297, .754139, -.564473, 2.16534, 1.235548, .776505, -.548787, 2.041646, 1.167051, .796833, -.531415, 1.923334, 1.100534, .817565, -.513778, 1.818176, 1.035144, .837981, -.495167, 1.72383, .971583, .858513, -.47569, 1.638448, .908841, .879892, -.454099, 1.55942, .846701, .902258, -.432038, 1.491471, .785332, .924114, -.409316, 1.428878, .726409, .94423, -.385618, 1.370785, .668588, .967001, -.362604, 1.323529, .612943, .988579, -.339117, 1.279679, .559038, 1.01021, -.315355, 1.240104, .506867, 1.032084, -.291408, 1.205261, .456934, 1.054671, -.267387, 1.175197, .407792, 1.078314, -.243346, 1.148153, .360992, 1.102443, -.219205, 1.123799, .315577, 1.128524, -.194996, 1.102624, .271742, 1.153989, -.169897, 1.085134, .230702, 1.17942, -.14396, 1.071699, .192146, 1.200098, -.116173, 1.060179, .155164, 1.214837, -.086655, 1.04629, .117071, 1.222749, -.056956, 1.03004, .07745, 1.227273, -.027883, 1.01365, .038092, 1.233293, 831e-6, 1.000043, -462e-6, 173e-6, -442e-6, 4.741539, 2.547922, 504e-6, -.001284, 7.491127, 2.547919, .002014, -.005132, 7.484889, 2.547844, .004523, -.011521, 7.439875, 2.547587, .008059, -.020524, 7.483694, 2.547725, .012586, -.032029, 7.470912, 2.547685, .018081, -.045948, 7.422534, 2.547686, .024783, -.062844, 7.487581, 2.547107, .032451, -.082011, 7.483603, 2.546522, .041233, -.10354, 7.475124, 2.545684, .051181, -.127537, 7.467521, 2.544438, .062347, -.153921, 7.456266, 2.542744, .074829, -.182427, 7.440422, 2.540459, .088703, -.213134, 7.420694, 2.53738, .10408, -.24575, 7.394875, 2.533347, .12105, -.279941, 7.358515, 2.528069, .139697, -.315591, 7.313001, 2.521237, .160036, -.35198, 7.246342, 2.512378, .182147, -.388993, 7.163688, 2.500993, .205799, -.42557, 7.048339, 2.48645, .231091, -.461093, 6.902586, 2.468174, .257405, -.494668, 6.712721, 2.444774, .284956, -.525889, 6.491261, 2.415538, .31318, -.553693, 6.232833, 2.38061, .342327, -.578724, 5.953834, 2.338525, .371689, -.599706, 5.649698, 2.290256, .401919, -.617615, 5.3479, 2.235157, .432204, -.631632, 5.036417, 2.173932, .463151, -.643082, 4.735976, 2.107298, .493388, -.64997, 4.432044, 2.036121, .524128, -.654188, 4.145472, 1.961595, .55393, -.654671, 3.866877, 1.883602, .583856, -.653051, 3.607848, 1.804521, .611762, -.646994, 3.356237, 1.724047, .639117, -.63886, 3.122531, 1.643016, .666279, -.629093, 2.913178, 1.563932, .692936, -.617862, 2.722675, 1.484614, .716498, -.603279, 2.536926, 1.406734, .742273, -.589878, 2.381054, 1.331469, .764031, -.572744, 2.228312, 1.256796, .786601, -.555933, 2.095451, 1.18529, .807776, -.537992, 1.972866, 1.11594, .8284, -.519596, 1.863394, 1.048371, .847412, -.499847, 1.76063, .982934, .86685, -.47992, 1.670998, .919972, .88634, -.459434, 1.587962, .8581, .906933, -.437767, 1.515505, .796714, .92749, -.414068, 1.448243, .736162, .950217, -.39091, 1.390505, .677613, .971545, -.366964, 1.337865, .620477, .992901, -.342603, 1.291104, .565807, 1.01546, -.318596, 1.251138, .513086, 1.037859, -.294242, 1.214291, .461573, 1.060535, -.269601, 1.182517, .411838, 1.086885, -.245608, 1.1553, .363221, 1.111237, -.220589, 1.129715, .317174, 1.138718, -.196008, 1.108103, .273213, 1.164223, -.170408, 1.08964, .231968, 1.187256, -.144205, 1.074145, .192987, 1.207851, -.116945, 1.061615, .156118, 1.222217, -.088852, 1.047599, .118674, 1.230315, -.059381, 1.030869, .078993, 1.235052, -.029145, 1.014126, .038924, 1.241359, 479e-6, 1.000114, -211e-6, 169e-6, -465e-6, 4.953966, 2.747437, 504e-6, -.001384, 8.54453, 2.74743, .002015, -.005537, 8.545147, 2.747339, .004542, -.012477, 8.557734, 2.747125, .008064, -.022143, 8.530193, 2.747341, .012543, -.034411, 8.465151, 2.747411, .018178, -.049792, 8.543328, 2.746874, .02481, -.067784, 8.547247, 2.746396, .032489, -.088416, 8.537436, 2.74573, .041313, -.11158, 8.526655, 2.744596, .051332, -.137462, 8.517438, 2.743082, .062603, -.16586, 8.502803, 2.74095, .07524, -.196548, 8.481507, 2.738057, .089341, -.22944, 8.454287, 2.734174, .105021, -.264395, 8.420289, 2.729086, .122399, -.30102, 8.373503, 2.72242, .141526, -.338997, 8.309059, 2.713686, .162451, -.377589, 8.221539, 2.702492, .185098, -.416349, 8.100116, 2.687893, .209406, -.454284, 7.941704, 2.669386, .235098, -.49045, 7.733318, 2.64559, .2621, -.524592, 7.48612, 2.615709, .290103, -.555558, 7.193498, 2.579231, .319135, -.583516, 6.874796, 2.534957, .348286, -.606714, 6.516118, 2.483017, .37884, -.62785, 6.163912, 2.424214, .409608, -.644715, 5.801404, 2.357563, .440553, -.657657, 5.435955, 2.285835, .470599, -.665621, 5.063481, 2.20794, .503172, -.673767, 4.743532, 2.12644, .533884, -.676009, 4.413409, 2.040694, .563808, -.674536, 4.092169, 1.953979, .591849, -.668913, 3.787057, 1.865897, .621474, -.663159, 3.520578, 1.777762, .6505, -.655018, 3.275065, 1.689902, .678011, -.643949, 3.043141, 1.603528, .70349, -.63003, 2.827104, 1.519484, .72825, -.61491, 2.63262, 1.436677, .752165, -.598649, 2.45557, 1.355753, .775894, -.581771, 2.295932, 1.278884, .79765, -.563193, 2.152291, 1.202767, .818505, -.54375, 2.022099, 1.130338, .838596, -.524017, 1.903562, 1.060263, .858396, -.504064, 1.797204, .993077, .877088, -.483418, 1.701208, .928606, .896606, -.462786, 1.617736, .866039, .914342, -.440943, 1.539227, .804293, .93355, -.419129, 1.470383, .745206, .955237, -.3961, 1.4091, .685832, .9767, -.371743, 1.35493, .627953, .997681, -.346882, 1.305249, .572127, 1.020784, -.322391, 1.262603, .517941, 1.04384, -.297564, 1.225115, .466188, 1.067224, -.272639, 1.190817, .415499, 1.092358, -.247664, 1.161265, .366782, 1.117573, -.22226, 1.133935, .319377, 1.14573, -.196933, 1.11175, .275293, 1.170822, -.170577, 1.091981, .233306, 1.194559, -.143878, 1.07581, .19395, 1.214819, -.116347, 1.062438, .156724, 1.22983, -.088233, 1.048092, .118984, 1.238185, -.059408, 1.031325, .079385, 1.243527, -.030703, 1.014698, .039893, 1.249724, -.00152, .999819, 76e-5, 164e-6, -489e-6, 5.157359, 2.9763, 505e-6, -.001502, 9.891415, 2.976286, .002016, -.006, 9.85773, 2.976197, .004543, -.013519, 9.870651, 2.975832, .008064, -.023985, 9.85578, 2.97617, .012611, -.037471, 9.850209, 2.975941, .018162, -.053866, 9.827134, 2.974968, .02482, -.07339, 9.849955, 2.97501, .032545, -.095758, 9.842021, 2.974073, .041418, -.120834, 9.829989, 2.9727, .051511, -.148861, 9.817421, 2.970736, .06292, -.179456, 9.797347, 2.968033, .075744, -.212674, 9.771533, 2.964371, .090131, -.248193, 9.735924, 2.959437, .106187, -.285748, 9.687707, 2.952881, .124035, -.325017, 9.622684, 2.944273, .143733, -.365463, 9.531452, 2.933093, .165262, -.406157, 9.401732, 2.918484, .188622, -.446833, 9.232451, 2.899529, .213693, -.486209, 9.013432, 2.875137, .239987, -.522925, 8.725671, 2.844166, .267796, -.557452, 8.400028, 2.805649, .296547, -.588266, 8.023041, 2.75872, .325838, -.614837, 7.606773, 2.702676, .355479, -.63676, 7.16068, 2.638483, .386984, -.65723, 6.736765, 2.566849, .418853, -.673592, 6.313742, 2.488091, .450302, -.684966, 5.884479, 2.402458, .481149, -.691591, 5.455771, 2.311816, .512177, -.695337, 5.055698, 2.21733, .543437, -.69637, 4.681506, 2.121285, .574309, -.694186, 4.334716, 2.02416, .604787, -.689158, 4.008524, 1.927738, .633483, -.68058, 3.703505, 1.830456, .660766, -.669088, 3.418386, 1.734934, .688471, -.656673, 3.168101, 1.642316, .715729, -.64282, 2.941735, 1.550744, .740435, -.626155, 2.73057, 1.463345, .764114, -.608299, 2.537561, 1.378151, .787028, -.589519, 2.364323, 1.29763, .807985, -.569257, 2.20797, 1.21783, .830663, -.550055, 2.076646, 1.142746, .850416, -.528812, 1.948085, 1.070757, .869609, -.507478, 1.834684, 1.001282, .888324, -.486131, 1.734879, .934987, .907482, -.46491, 1.645974, .871203, .924829, -.442742, 1.56355, .80926, .942958, -.420777, 1.491264, .750037, .961999, -.398842, 1.428069, .691715, .981043, -.375967, 1.369668, .635669, 1.002371, -.351469, 1.318588, .578689, 1.025343, -.326601, 1.273628, .524424, 1.048511, -.301395, 1.234572, .471403, 1.072242, -.275835, 1.198354, .41995, 1.096758, -.2502, 1.166392, .370733, 1.122781, -.224474, 1.138991, .322864, 1.150871, -.198592, 1.114313, .277723, 1.177319, -.171805, 1.093534, .23495, 1.201765, -.144291, 1.077462, .195376, 1.222629, -.115949, 1.063288, .157315, 1.237334, -.08714, 1.048366, .118843, 1.246153, -.058094, 1.031224, .079207, 1.25257, -.029194, 1.014695, .039376, 1.25906, -418e-6, .999881, 307e-6, 159e-6, -515e-6, 5.393984, 3.241865, 505e-6, -.001636, 11.548038, 3.241848, .002016, -.006534, 11.50664, 3.241718, .004537, -.014706, 11.51346, 3.241196, .008068, -.026134, 11.510533, 3.241693, .012573, -.040676, 11.428978, 3.24103, .018212, -.058794, 11.510745, 3.240924, .024847, -.079926, 11.497339, 3.240201, .032603, -.10416, 11.484607, 3.238994, .041543, -.131552, 11.470801, 3.237182, .051738, -.162012, 11.453219, 3.234635, .063313, -.19526, 11.427244, 3.231153, .076381, -.231205, 11.388534, 3.226361, .091096, -.269678, 11.340406, 3.219943, .1076, -.31017, 11.270127, 3.211448, .126017, -.352435, 11.178583, 3.200168, .146411, -.395551, 11.046559, 3.185328, .168663, -.438627, 10.858624, 3.165972, .19273, -.48066, 10.606379, 3.140735, .218497, -.520987, 10.288093, 3.108388, .245752, -.558483, 9.90748, 3.067586, .273993, -.59209, 9.453246, 3.016931, .303495, -.622416, 8.966138, 2.956444, .333717, -.648303, 8.443776, 2.885116, .363928, -.66864, 7.894122, 2.805963, .39624, -.687748, 7.385728, 2.718338, .427161, -.699903, 6.838511, 2.622346, .460175, -.71121, 6.356371, 2.522476, .492593, -.717734, 5.878312, 2.417984, .524449, -.719956, 5.423285, 2.310941, .55601, -.719127, 4.997909, 2.201885, .587032, -.715077, 4.600426, 2.09333, .61703, -.707574, 4.235885, 1.986585, .644684, -.695781, 3.881712, 1.881279, .674483, -.685313, 3.59096, 1.777918, .70029, -.669619, 3.303138, 1.678004, .727892, -.654728, 3.057771, 1.581162, .751694, -.635727, 2.826642, 1.487769, .776271, -.617343, 2.622178, 1.399628, .799502, -.597683, 2.441265, 1.313195, .821768, -.57709, 2.276954, 1.232316, .84196, -.555165, 2.125744, 1.153914, .861582, -.532983, 1.991236, 1.079598, .88146, -.510933, 1.874027, 1.008883, .899952, -.488321, 1.766812, .940802, .918954, -.466405, 1.673436, .875653, .93613, -.443623, 1.586986, .81313, .954799, -.421532, 1.513558, .752241, .972435, -.398897, 1.445787, .694711, .990147, -.376302, 1.384382, .63877, 1.009189, -.353623, 1.331934, .583826, 1.029687, -.330635, 1.284478, .530476, 1.052604, -.305698, 1.243632, .477187, 1.076524, -.279917, 1.204997, .425349, 1.101701, -.253951, 1.17175, .375165, 1.127264, -.227541, 1.142519, .326869, 1.156397, -.201265, 1.116817, .280912, 1.18302, -.173943, 1.095289, .237447, 1.208448, -.14586, 1.078296, .196694, 1.230417, -.116901, 1.064416, .158409, 1.248617, -.087507, 1.050504, .119483, 1.25731, -.057353, 1.032796, .079092, 1.263076, -.027785, 1.015128, .038883, 1.26987, .001331, .999935, -557e-6, 154e-6, -549e-6, 5.705205, 3.554136, 506e-6, -.001797, 13.703335, 3.554133, .002014, -.007156, 13.614074, 3.553937, .004544, -.016145, 13.657344, 3.553096, .00807, -.028652, 13.627997, 3.553894, .012584, -.044617, 13.606235, 3.554, .01818, -.064288, 13.581339, 3.549637, .024887, -.087627, 13.608851, 3.552006, .03269, -.114134, 13.599099, 3.550341, .041705, -.144154, 13.579829, 3.547982, .052035, -.1774, 13.552845, 3.544641, .06381, -.213813, 13.515619, 3.539941, .077171, -.252978, 13.46046, 3.533696, .092329, -.294852, 13.393559, 3.524977, .10939, -.338688, 13.292376, 3.513655, .128455, -.384018, 13.147332, 3.498484, .149661, -.42996, 12.945774, 3.478323, .172694, -.475024, 12.658979, 3.451862, .19765, -.518614, 12.289564, 3.417602, .224156, -.559298, 11.828307, 3.372913, .252008, -.59611, 11.285162, 3.317454, .281165, -.629292, 10.684922, 3.251171, .311434, -.658379, 10.052939, 3.172222, .342741, -.683455, 9.405296, 3.082825, .373543, -.701674, 8.716078, 2.983976, .407008, -.719664, 8.108425, 2.876244, .438623, -.729882, 7.461252, 2.763279, .471872, -.738696, 6.880182, 2.64559, .5047, -.743136, 6.324308, 2.52468, .537118, -.743676, 5.808302, 2.402723, .569412, -.741181, 5.332306, 2.281437, .598202, -.732348, 4.857402, 2.161401, .62964, -.724832, 4.465554, 2.043872, .659239, -.713435, 4.093661, 1.930129, .686547, -.698539, 3.752593, 1.817654, .715529, -.684471, 3.457593, 1.712567, .739456, -.664983, 3.17122, 1.610687, .764892, -.646322, 2.929674, 1.512031, .789301, -.626393, 2.710719, 1.419033, .809881, -.603498, 2.506139, 1.330115, .833385, -.582934, 2.336089, 1.245859, .854254, -.560419, 2.17847, 1.165042, .873964, -.537294, 2.040087, 1.086633, .893433, -.514264, 1.911969, 1.015028, .911756, -.490657, 1.79984, .944938, .930894, -.467601, 1.703188, .878743, .948078, -.444043, 1.612092, .815356, .966162, -.421155, 1.534444, .753883, .984166, -.398238, 1.462397, .695534, 1.002184, -.375278, 1.400793, .638806, 1.019669, -.352159, 1.344172, .584549, 1.039571, -.329651, 1.295227, .53166, 1.059989, -.306804, 1.251281, .480529, 1.081116, -.283345, 1.211504, .430071, 1.105742, -.258568, 1.1764, .380277, 1.13308, -.232146, 1.144519, .331076, 1.161888, -.205244, 1.118059, .28404, 1.192408, -.177932, 1.097561, .239958, 1.221043, -.149532, 1.082021, .198751, 1.244141, -.120046, 1.067634, .160114, 1.259465, -.089542, 1.051626, .121101, 1.268124, -.058593, 1.033296, .079898, 1.27433, -.028011, 1.015382, .039038, 1.28159, .00233, 1.000087, -.001259, 149e-6, -587e-6, 6.059834, 3.927143, 507e-6, -.001992, 16.5604, 3.927149, .002014, -.00791, 16.406326, 3.926821, .004549, -.017856, 16.545532, 3.927027, .008064, -.031632, 16.375853, 3.925487, .01245, -.048749, 15.928564, 3.928272, .01803, -.070371, 16.072989, 3.917862, .024964, -.096897, 16.458925, 3.924489, .032807, -.126073, 16.377851, 3.921896, .041917, -.159205, 16.351561, 3.91886, .052416, -.195762, 16.307037, 3.914339, .064464, -.235784, 16.255514, 3.907954, .078225, -.278812, 16.176226, 3.899254, .0939, -.324457, 16.06653, 3.887455, .111657, -.372174, 15.913818, 3.871777, .131478, -.42053, 15.669197, 3.850776, .153574, -.46933, 15.355453, 3.822348, .177505, -.516029, 14.908978, 3.785168, .203383, -.560585, 14.352687, 3.736602, .230569, -.600607, 13.666022, 3.675046, .259188, -.636296, 12.900244, 3.599811, .289272, -.668312, 12.111226, 3.51055, .32049, -.695986, 11.292102, 3.408535, .353031, -.719848, 10.493485, 3.295667, .385228, -.737073, 9.661955, 3.171998, .419219, -.752419, 8.909942, 3.042428, .452096, -.761179, 8.155107, 2.907108, .484909, -.766166, 7.450609, 2.769858, .518306, -.768596, 6.811866, 2.631935, .550067, -.765683, 6.205275, 2.49287, .582562, -.761197, 5.663215, 2.358645, .61445, -.753834, 5.165358, 2.227377, .644563, -.74286, 4.712554, 2.097547, .673658, -.729294, 4.306101, 1.97492, .702857, -.714839, 3.943352, 1.857613, .72935, -.696774, 3.609432, 1.743601, .754958, -.677394, 3.308389, 1.636607, .779575, -.657018, 3.043803, 1.533841, .800491, -.633342, 2.793592, 1.437092, .82503, -.612471, 2.590307, 1.344272, .847535, -.589882, 2.406477, 1.256436, .865979, -.56485, 2.231999, 1.173938, .886254, -.541357, 2.083556, 1.094722, .905566, -.517353, 1.950928, 1.021107, .924607, -.49332, 1.835979, .948941, .943365, -.469366, 1.731417, .88106, .960405, -.444745, 1.635838, .816479, .977893, -.420493, 1.552981, .754604, .996573, -.39715, 1.481595, .694917, 1.014, -.373483, 1.41407, .638445, 1.031807, -.349985, 1.356031, .584035, 1.051877, -.327062, 1.305041, .53001, 1.071701, -.304134, 1.258836, .479439, 1.093109, -.280962, 1.217297, .429763, 1.116681, -.258121, 1.182063, .38105, 1.143886, -.235365, 1.150039, .333395, 1.175163, -.211621, 1.125074, .287477, 1.203675, -.184061, 1.102339, .243301, 1.230477, -.154815, 1.083927, .201826, 1.253134, -.124513, 1.067989, .162271, 1.270092, -.093383, 1.052032, .122855, 1.279576, -.06177, 1.033685, .081639, 1.286472, -.030317, 1.015583, .040411, 1.294476, 964e-6, 1.000206, -454e-6, 144e-6, -63e-5, 6.467978, 4.381146, 504e-6, -.002208, 20.193617, 4.381151, .002017, -.008834, 20.206446, 4.380687, .004536, -.019864, 20.183254, 4.38055, .008174, -.035759, 20.564249, 4.381247, .012608, -.055034, 20.111612, 4.38239, .018198, -.079119, 20.106096, 4.379815, .025057, -.108067, 20.215635, 4.376874, .032962, -.14063, 20.153549, 4.374143, .042199, -.17735, 20.084061, 4.369558, .052928, -.218094, 20.026609, 4.363287, .065327, -.262407, 19.940054, 4.354386, .079568, -.309833, 19.806814, 4.342127, .095961, -.360074, 19.641878, 4.325533, .114516, -.411747, 19.370914, 4.30295, .135349, -.463726, 18.9839, 4.271991, .158293, -.514211, 18.433926, 4.230856, .183348, -.562511, 17.733471, 4.17625, .209959, -.60631, 16.864214, 4.105895, .238736, -.646958, 15.935207, 4.020104, .268543, -.681574, 14.890014, 3.916094, .299996, -.712458, 13.846786, 3.798239, .33193, -.73713, 12.758296, 3.664191, .365222, -.758156, 11.73294, 3.521867, .399061, -.774364, 10.741743, 3.369831, .43348, -.786412, 9.812527, 3.212079, .467002, -.792373, 8.91513, 3.053715, .500754, -.79541, 8.094276, 2.894526, .534023, -.794617, 7.342067, 2.735959, .566988, -.790689, 6.664186, 2.58116, .59996, -.784433, 6.052983, 2.432318, .630599, -.773378, 5.486277, 2.28763, .660807, -.760334, 4.982516, 2.150183, .690103, -.74543, 4.531104, 2.017266, .717315, -.727511, 4.120734, 1.891699, .743819, -.708376, 3.759599, 1.77268, .770147, -.688632, 3.441912, 1.66062, .79351, -.665931, 3.1526, 1.553166, .816535, -.643045, 2.898883, 1.45208, .839163, -.619917, 2.674488, 1.355544, .859066, -.594923, 2.469262, 1.267232, .879489, -.570343, 2.292209, 1.181702, .898525, -.544975, 2.131086, 1.102089, .918359, -.520585, 1.994526, 1.024744, .937502, -.496044, 1.873079, .951712, .955573, -.47101, 1.761232, .883374, .972957, -.445712, 1.661604, .818008, .991248, -.421201, 1.577169, .754446, 1.008997, -.396444, 1.499653, .694518, 1.028127, -.372362, 1.43203, .637259, 1.04571, -.347895, 1.36987, .581515, 1.065977, -.324409, 1.317341, .527713, 1.087469, -.301181, 1.270447, .476281, 1.109943, -.277866, 1.228398, .426403, 1.13444, -.254849, 1.190986, .377822, 1.160986, -.231754, 1.157681, .33074, 1.188458, -.207973, 1.128665, .286014, 1.214405, -.183424, 1.103711, .2436, 1.239504, -.157972, 1.084253, .203686, 1.262961, -.130607, 1.068258, .165214, 1.28034, -.099652, 1.051919, .126067, 1.292129, -.067363, 1.034016, .084791, 1.299876, -.035026, 1.015775, .042786, 1.308328, -.002944, .999963, .001385, 138e-6, -681e-6, 6.943771, 4.946556, 503e-6, -.002486, 25.346689, 4.946532, .002016, -.009973, 25.49432, 4.946311, .004539, -.02244, 25.484949, 4.945823, .008069, -.039836, 25.420902, 4.945311, .012628, -.062172, 25.394403, 4.945041, .018294, -.089609, 25.440279, 4.943295, .025079, -.121584, 25.399988, 4.939368, .033142, -.158595, 25.356537, 4.9362, .042596, -.199971, 25.295067, 4.929842, .053628, -.245624, 25.196465, 4.920586, .066496, -.29524, 25.055311, 4.9077, .081434, -.348006, 24.84617, 4.889647, .09864, -.403167, 24.527803, 4.86468, .118231, -.459106, 24.051735, 4.830574, .140139, -.513907, 23.352467, 4.78353, .164198, -.565953, 22.418245, 4.72053, .190502, -.614858, 21.324049, 4.638075, .21853, -.658304, 20.038671, 4.535464, .248094, -.696133, 18.639786, 4.411646, .279435, -.729388, 17.234526, 4.268872, .312002, -.757534, 15.830426, 4.109603, .346173, -.781866, 14.495901, 3.938782, .379435, -.797579, 13.136444, 3.756138, .414945, -.812334, 11.946491, 3.571258, .449991, -.821119, 10.811908, 3.384217, .484636, -.825066, 9.763482, 3.198076, .518675, -.824728, 8.796811, 3.015808, .552559, -.82171, 7.932528, 2.836886, .587272, -.817478, 7.185156, 2.664995, .61696, -.804441, 6.445302, 2.502223, .648054, -.792063, 5.818812, 2.345851, .678575, -.777793, 5.264731, 2.19715, .707287, -.760476, 4.766033, 2.056042, .735851, -.742541, 4.335871, 1.922805, .760594, -.720503, 3.928021, 1.798585, .784534, -.697719, 3.579153, 1.680605, .811029, -.677036, 3.285307, 1.568942, .831809, -.651479, 3.001423, 1.465496, .854364, -.627376, 2.760672, 1.367849, .872639, -.600496, 2.540697, 1.275644, .894296, -.576297, 2.355273, 1.188638, .913123, -.550377, 2.188563, 1.105652, .932025, -.52464, 2.040739, 1.028614, .949876, -.498402, 1.910315, .954421, .968933, -.47322, 1.79575, .884061, .985366, -.447086, 1.690336, .817765, 1.00494, -.422394, 1.599626, .753295, 1.022217, -.396726, 1.519055, .69338, 1.04149, -.371854, 1.448745, .635747, 1.05992, -.346769, 1.384292, .579508, 1.080408, -.322343, 1.328798, .525045, 1.101632, -.297979, 1.279898, .473773, 1.124812, -.274059, 1.234005, .422949, 1.148503, -.249954, 1.195373, .374609, 1.174554, -.225988, 1.160362, .32735, 1.202931, -.201932, 1.131307, .283494, 1.229335, -.176886, 1.105885, .241092, 1.254254, -.151225, 1.085802, .201514, 1.275743, -.124282, 1.068524, .162866, 1.292929, -.097122, 1.051493, .124991, 1.305805, -.068939, 1.03389, .085521, 1.314991, -.040082, 1.015927, .045247, 1.324033, -.009923, .999893, .004738, 131e-6, -745e-6, 7.562414, 5.671075, 473e-6, -.002681, 27.216688, 5.670949, .002021, -.011462, 32.962402, 5.670177, .00454, -.025728, 33.183949, 5.670197, .008087, -.045746, 33.185688, 5.667313, .012673, -.071427, 33.170441, 5.668396, .018358, -.102673, 33.145138, 5.665252, .025299, -.13978, 33.303326, 5.653404, .033469, -.181718, 33.107243, 5.652829, .043139, -.228698, 32.859524, 5.645676, .054622, -.280648, 32.694893, 5.631547, .068115, -.336524, 32.422569, 5.611561, .083957, -.395671, 32.035511, 5.583449, .102259, -.456164, 31.415047, 5.543651, .123021, -.515765, 30.47044, 5.488278, .146127, -.572309, 29.186451, 5.413118, .171749, -.62571, 27.653852, 5.312369, .199549, -.673853, 25.902435, 5.185774, .229188, -.715905, 23.978609, 5.030582, .260421, -.751533, 21.999035, 4.853484, .293421, -.782309, 20.087366, 4.656137, .327077, -.806332, 18.186535, 4.443975, .361892, -.825818, 16.418409, 4.223844, .397146, -.840019, 14.774344, 3.998959, .434169, -.852434, 13.321097, 3.775443, .469288, -.856632, 11.929448, 3.552818, .504319, -.85713, 10.675201, 3.338825, .540067, -.855903, 9.5919, 3.130547, .575404, -.851565, 8.607655, 2.93293, .606782, -.839818, 7.69056, 2.743876, .63866, -.827508, 6.900781, 2.565115, .670577, -.814154, 6.216821, 2.395215, .696718, -.793162, 5.551886, 2.238233, .72599, -.775291, 5.015406, 2.090264, .75414, -.755758, 4.546843, 1.950834, .775992, -.729824, 4.094254, 1.820582, .80299, -.708909, 3.732984, 1.699191, .828291, -.686483, 3.413194, 1.583805, .847406, -.659162, 3.103861, 1.478093, .864951, -.631051, 2.832976, 1.378496, .887154, -.60659, 2.616645, 1.282127, .906337, -.580124, 2.413988, 1.194643, .927184, -.554835, 2.24438, 1.110354, .94381, -.527583, 2.081964, 1.031996, .96363, -.502243, 1.948979, .956718, .979691, -.475006, 1.822701, .886957, .99769, -.448815, 1.715714, .819006, 1.01646, -.423044, 1.621868, .754892, 1.035485, -.397637, 1.539537, .693707, 1.053165, -.371775, 1.462285, .634867, 1.072394, -.346372, 1.396193, .578574, 1.093397, -.321291, 1.338344, .524341, 1.115194, -.296102, 1.287594, .472059, 1.137943, -.271023, 1.240495, .421674, 1.164163, -.246367, 1.201224, .371963, 1.191457, -.221414, 1.164472, .32504, 1.220253, -.196228, 1.134325, .280343, 1.245456, -.169991, 1.108214, .238098, 1.270647, -.143314, 1.087277, .197886, 1.292124, -.115881, 1.069397, .15956, 1.309091, -.087816, 1.051426, .120547, 1.32113, -.059301, 1.032904, .080834, 1.332484, -.030912, 1.015767, .040933, 1.342834, -.002172, .999591, .001185, 125e-6, -83e-5, 8.392562, 6.634228, 443e-6, -.002936, 29.687805, 6.634032, .002016, -.013374, 45.025234, 6.633008, .00454, -.030089, 45.020294, 6.633056, .008092, -.053499, 45.066029, 6.626466, .01271, -.08361, 44.810101, 6.63033, .018485, -.12026, 45.216747, 6.614516, .025134, -.161031, 44.674168, 6.600349, .033897, -.212161, 44.819195, 6.610186, .043978, -.266661, 44.450245, 6.593605, .056094, -.326582, 44.134544, 6.570142, .070528, -.390342, 43.591648, 6.536712, .087498, -.456162, 42.70816, 6.488329, .107138, -.521609, 41.365093, 6.420198, .129461, -.584225, 39.525822, 6.323702, .154245, -.641931, 37.186111, 6.193606, .181228, -.692829, 34.47847, 6.026897, .210711, -.73844, 31.680904, 5.825769, .242181, -.777397, 28.828054, 5.595428, .275337, -.80998, 26.042755, 5.342321, .309698, -.83599, 23.376804, 5.073076, .345702, -.858077, 20.965754, 4.794572, .382135, -.874122, 18.710079, 4.516676, .419871, -.887133, 16.713011, 4.241767, .455609, -.891199, 14.819674, 3.972124, .492617, -.894082, 13.187921, 3.717271, .528186, -.89127, 11.708584, 3.471719, .563462, -.885719, 10.422834, 3.23776, .596013, -.874241, 9.237741, 3.01906, .629455, -.862814, 8.248549, 2.813572, .66111, -.848126, 7.358398, 2.621046, .690314, -.829798, 6.569392, 2.441627, .720589, -.812314, 5.905934, 2.274629, .745631, -.788704, 5.2768, 2.119423, .771488, -.766133, 4.752773, 1.97438, .798704, -.744726, 4.306095, 1.839482, .820172, -.718062, 3.889792, 1.713244, .844368, -.693972, 3.545456, 1.594809, .863128, -.665748, 3.212762, 1.487512, .880094, -.637003, 2.926572, 1.386724, .904252, -.613728, 2.70426, 1.288131, .920506, -.585217, 2.483164, 1.199845, .940919, -.559603, 2.300348, 1.114958, .957044, -.531597, 2.130516, 1.034754, .972648, -.503583, 1.979313, .960912, .994318, -.478813, 1.859664, .889786, 1.008754, -.450943, 1.742705, .820833, 1.028667, -.425516, 1.64522, .756332, 1.046145, -.398977, 1.557184, .693921, 1.067212, -.373657, 1.480814, .635955, 1.084111, -.346657, 1.408762, .578832, 1.106749, -.321392, 1.350468, .523561, 1.12844, -.295773, 1.294865, .471146, 1.151073, -.270028, 1.246118, .420298, 1.178601, -.244816, 1.204226, .370575, 1.206845, -.219027, 1.166896, .323716, 1.235963, -.192622, 1.135756, .278058, 1.26303, -.165331, 1.10924, .235743, 1.288937, -.137489, 1.088379, .19539, 1.310681, -.108685, 1.068987, .156439, 1.334352, -.07971, 1.054273, .117096, 1.344847, -.049947, 1.034598, .076554, 1.354943, -.020272, 1.016079, .035585, 1.365515, .00917, .999969, -.004771, 117e-6, -935e-6, 9.424866, 7.979243, 41e-5, -.003275, 33.013195, 7.979422, .002009, -.016024, 64.370331, 7.977156, .004541, -.036176, 64.655952, 7.976128, .008109, -.064384, 64.864494, 7.964988, .012694, -.099984, 64.487198, 7.971348, .018554, -.143991, 64.63797, 7.923116, .025303, -.19204, 61.930538, 7.953975, .035297, -.259442, 66.274422, 7.921861, .045226, -.31837, 63.33469, 7.909609, .05837, -.388821, 62.686401, 7.864696, .074083, -.461667, 61.332054, 7.801843, .092537, -.533744, 59.125607, 7.708949, .113781, -.601905, 55.997845, 7.575799, .137786, -.664409, 52.177567, 7.393524, .16477, -.721193, 48.019485, 7.161756, .193894, -.768842, 43.460278, 6.882018, .225586, -.810332, 39.08659, 6.564607, .259311, -.845096, 34.896049, 6.221983, .294517, -.872849, 30.952213, 5.865831, .331163, -.895159, 27.375792, 5.507064, .368964, -.91286, 24.21331, 5.149763, .407255, -.925338, 21.364958, 4.806172, .444704, -.930956, 18.791691, 4.472272, .482041, -.932576, 16.52116, 4.160864, .519572, -.931547, 14.589918, 3.865206, .556236, -.926554, 12.887797, 3.590445, .590431, -.915839, 11.352402, 3.332747, .622723, -.901266, 10.00266, 3.093264, .657029, -.888747, 8.90521, 2.873842, .686164, -.868666, 7.876704, 2.66674, .719168, -.853152, 7.051816, 2.479017, .742294, -.826169, 6.226034, 2.306498, .77032, -.804936, 5.590831, 2.141328, .792337, -.777772, 4.984083, 1.994663, .81905, -.755478, 4.507655, 1.85395, .837684, -.726072, 4.049884, 1.72559, .861324, -.701424, 3.678201, 1.606303, .880741, -.673615, 3.337163, 1.495452, .903335, -.648506, 3.05572, 1.391162, .920311, -.61964, 2.792068, 1.294734, .935769, -.590245, 2.554566, 1.204518, .956592, -.564944, 2.366468, 1.11863, .972424, -.536842, 2.187863, 1.038323, .986269, -.50802, 2.02348, .963803, 1.006122, -.482411, 1.895137, .890986, 1.022504, -.45511, 1.775886, .820936, 1.037905, -.42745, 1.665951, .758556, 1.059281, -.402198, 1.577363, .696126, 1.076613, -.375156, 1.493391, .636676, 1.097828, -.349577, 1.421129, .579947, 1.116671, -.322955, 1.355205, .52514, 1.140514, -.297406, 1.299979, .47146, 1.166473, -.271786, 1.249847, .420473, 1.192591, -.245461, 1.204625, .371118, 1.223349, -.219412, 1.166686, .3226, 1.254833, -.19266, 1.134121, .277572, 1.285808, -.165167, 1.108617, .234417, 1.322015, -.137236, 1.093841, .19464, 1.342172, -.106871, 1.074616, .155001, 1.357238, -.075759, 1.05355, .114648, 1.367725, -.044279, 1.033851, .073254, 1.379461, -.013001, 1.015713, .031895, 1.391625, .018075, 1.000203, -.009397, 109e-6, -.001093, 10.98682, 9.992467, 378e-6, -.003779, 37.989063, 9.992861, .002028, -.020252, 101.850441, 9.988345, .004557, -.045429, 101.10675, 9.983879, .008115, -.080453, 100.646606, 9.953411, .012864, -.125836, 101.366592, 9.943727, .018734, -.17935, 100.786118, 9.908408, .026314, -.24368, 99.779343, 9.821631, .0355, -.313552, 98.608231, 9.78245, .047562, -.394644, 97.689568, 9.845875, .062065, -.476697, 95.177795, 9.755218, .079552, -.557933, 91.095581, 9.615121, .099905, -.632818, 85.110382, 9.408299, .123231, -.699926, 77.948921, 9.120996, .14998, -.760671, 70.491119, 8.764173, .17955, -.812251, 62.821407, 8.341752, .211839, -.855909, 55.51289, 7.876337, .246434, -.892023, 48.744549, 7.386268, .282317, -.9192, 42.462059, 6.886009, .31958, -.940333, 36.901031, 6.400318, .360135, -.962176, 32.353752, 5.937503, .397805, -.969755, 27.996445, 5.489783, .437077, -.976494, 24.359192, 5.072855, .474388, -.975265, 21.1243, 4.684682, .513695, -.975335, 18.476677, 4.326597, .551542, -.970264, 16.167391, 3.999049, .587525, -.960365, 14.143442, 3.696317, .621251, -.945944, 12.374341, 3.414176, .654738, -.930709, 10.877112, 3.160455, .685794, -.911702, 9.580887, 2.921461, .717135, -.892948, 8.481939, 2.707478, .740798, -.865086, 7.435941, 2.510382, .77092, -.845137, 6.650625, 2.329648, .792303, -.815956, 5.879976, 2.163206, .818363, -.792225, 5.274404, 2.008042, .837362, -.762396, 4.70096, 1.867576, .862266, -.738465, 4.254798, 1.735819, .880069, -.70889, 3.828697, 1.61469, .896021, -.678588, 3.451655, 1.503477, .920156, -.654832, 3.168722, 1.3958, .934948, -.62474, 2.879533, 1.299955, .949686, -.595203, 2.628258, 1.208597, .970989, -.570041, 2.433689, 1.12231, .985606, -.541116, 2.241461, 1.042168, 1.000819, -.512835, 2.075567, .966543, 1.012209, -.483024, 1.919932, .895758, 1.03532, -.459125, 1.807884, .825668, 1.052077, -.432333, 1.695689, .760812, 1.070459, -.406131, 1.595491, .699897, 1.088704, -.379721, 1.508512, .640575, 1.103817, -.352104, 1.428159, .583765, 1.131711, -.328122, 1.366565, .52824, 1.156448, -.302568, 1.306843, .473988, 1.181821, -.276487, 1.252861, .422189, 1.211347, -.25054, 1.205265, .372005, 1.243636, -.224264, 1.165943, .324184, 1.283038, -.198289, 1.137772, .278419, 1.316722, -.170179, 1.115057, .235425, 1.342715, -.140095, 1.092994, .195084, 1.363288, -.108794, 1.071875, .155439, 1.380656, -.076774, 1.052475, .114636, 1.394826, -.044509, 1.032525, .07289, 1.40883, -.011968, 1.015459, .031101, 1.42237, .020555, .999808, -.011002, 1e-4, -.001334, 13.377127, 13.342275, 342e-6, -.004563, 45.758434, 13.34271, .002026, -.027004, 179.672058, 13.331846, .004559, -.060563, 179.294235, 13.314877, .008232, -.108154, 181.242035, 13.222856, .013031, -.16759, 179.684509, 13.15386, .019526, -.242041, 181.004608, 12.986094, .026364, -.309289, 159.606293, 13.247752, .03767, -.409755, 179.468521, 12.368877, .051804, -.512051, 167.955582, 12.981333, .068214, -.601994, 156.278793, 12.704532, .088295, -.686849, 143.096878, 12.316531, .111478, -.75867, 127.423111, 11.793048, .138336, -.821348, 111.763031, 11.157992, .168447, -.873616, 96.887924, 10.447472, .201411, -.916322, 83.225327, 9.696606, .237443, -.95309, 71.403137, 8.949244, .274234, -.977751, 60.739277, 8.225874, .314566, -1.003135, 52.115578, 7.547433, .353932, -1.016312, 44.341869, 6.910326, .393858, -1.024848, 37.827263, 6.324401, .433805, -1.02895, 32.380932, 5.790555, .475812, -1.034084, 27.955982, 5.312826, .513254, -1.026743, 23.977417, 4.866118, .549965, -1.01674, 20.628025, 4.468437, .5903, -1.01203, 18.036856, 4.105483, .62642, -.998919, 15.669224, 3.780593, .658897, -.979874, 13.603898, 3.482054, .687252, -.955238, 11.788331, 3.211213, .718941, -.935663, 10.355552, 2.962083, .749877, -.915206, 9.131123, 2.741382, .772094, -.884837, 7.973935, 2.536501, .799495, -.861214, 7.08623, 2.347282, .820136, -.830976, 6.240769, 2.179332, .846715, -.807408, 5.604792, 2.018005, .865176, -.776657, 4.975034, 1.877021, .8811, -.744657, 4.442767, 1.743528, .907637, -.722088, 4.035177, 1.621563, .922239, -.690432, 3.63316, 1.506158, .936558, -.65965, 3.281798, 1.403606, .950047, -.629105, 2.974179, 1.304276, .961959, -.598277, 2.704483, 1.213888, .98741, -.576085, 2.510453, 1.125569, .999996, -.546494, 2.304016, 1.045567, 1.014127, -.518186, 2.127867, .970718, 1.036275, -.494009, 1.985804, .897557, 1.049695, -.465659, 1.845074, .830584, 1.064617, -.438159, 1.72513, .766083, 1.077131, -.409813, 1.613818, .705101, 1.101054, -.385632, 1.528694, .644828, 1.122361, -.360045, 1.447086, .587878, 1.147359, -.335186, 1.377588, .53213, 1.169881, -.30904, 1.313673, .478843, 1.200554, -.28459, 1.257256, .426855, 1.232047, -.259332, 1.208431, .376125, 1.275402, -.235215, 1.174692, .326614, 1.306595, -.207508, 1.141042, .281524, 1.334304, -.17829, 1.111778, .238694, 1.364678, -.14853, 1.090976, .198549, 1.387168, -.117114, 1.069308, .158529, 1.408657, -.084977, 1.050625, .118042, 1.426214, -.052052, 1.031444, .076541, 1.444257, -.018653, 1.014298, .034061, 1.460618, .015206, .999413, -.008132, 1e-4, -.002003, 20.052612, 20.032721, 297e-6, -.005947, 59.540512, 20.033842, .002022, -.040439, 404.848511, 20.032743, .004588, -.090999, 403.741241, 19.910591, .008769, -.169802, 441.471558, 19.572552, .013708, -.253629, 411.667816, 19.145721, .020331, -.349396, 371.322571, 18.591049, .030259, -.468121, 385.816498, 18.331083, .04519, -.611444, 391.924133, 15.807686, .058476, -.676875, 319.638641, 16.947781, .079894, -.781421, 278.80426, 17.512903, .103871, -.855116, 235.999786, 16.290295, .131756, -.915747, 197.168076, 14.956566, .163487, -.966333, 163.452347, 13.60801, .198693, -1.008386, 135.632706, 12.299661, .236157, -1.039862, 111.919281, 11.08879, .274579, -1.059988, 92.136581, 9.983883, .317164, -1.084069, 77.063034, 9.008505, .357624, -1.092124, 63.963051, 8.127298, .399009, -1.09756, 53.483341, 7.347628, .441182, -1.100981, 45.052429, 6.658191, .481606, -1.097318, 37.93264, 6.047333, .524253, -1.09657, 32.395638, 5.505878, .564351, -1.088739, 27.67938, 5.018494, .600843, -1.073396, 23.611519, 4.58077, .635527, -1.055024, 20.207081, 4.194785, .672045, -1.039775, 17.469036, 3.847436, .698372, -1.009545, 14.928226, 3.532546, .729336, -.987168, 12.95317, 3.248834, .761147, -.966299, 11.346271, 2.994166, .78227, -.932841, 9.813129, 2.762244, .811832, -.910431, 8.672224, 2.549933, .832053, -.878369, 7.578633, 2.363132, .849383, -.844673, 6.648379, 2.189266, .86602, -.811703, 5.850784, 2.031716, .893083, -.789181, 5.273372, 1.88448, .909212, -.757541, 4.700618, 1.750298, .923169, -.725157, 4.19664, 1.62759, .937112, -.693769, 3.764841, 1.514906, .961901, -.670828, 3.444598, 1.406839, .975245, -.64024, 3.120745, 1.307873, .989696, -.611032, 2.840732, 1.216417, 1.002057, -.581144, 2.591596, 1.132553, 1.014022, -.55162, 2.37382, 1.051695, 1.025307, -.522268, 2.177992, .9775, 1.05219, -.500826, 2.042511, .904301, 1.064408, -.472355, 1.891934, .837557, 1.077876, -.444815, 1.761054, .773004, 1.088939, -.416531, 1.638939, .713958, 1.118551, -.395057, 1.555724, .652485, 1.134469, -.368289, 1.46549, .59633, 1.162778, -.345095, 1.390977, .539703, 1.185298, -.319527, 1.321225, .48625, 1.208419, -.29359, 1.259318, .434178, 1.261013, -.273471, 1.219767, .382032, 1.297811, -.248226, 1.176422, .33419, 1.326591, -.220354, 1.139881, .289075, 1.357918, -.191937, 1.111418, .246259, 1.38759, -.162282, 1.086511, .205129, 1.415797, -.131515, 1.067072, .165601, 1.440194, -.099555, 1.047799, .125462, 1.4656, -.066957, 1.030406, .084082, 1.487714, -.033496, 1.013889, .041981, 1.509947, 663e-6, .998773, -485e-6, 1e-4, -.004009, 40.102047, 40.087105, 228e-6, -.009141, 91.431366, 40.074432, .001522, -.060544, 605.651733, 39.918827, .004919, -.188871, 1712.9823, 38.873421, .009053, -.320325, 1583.453125, 39.715633, .015375, -.471415, 1486.033691, 39.162876, .029306, -.735111, 1751.70105, 28.0832, .04345, -.859759, 1392.47522, 24.599945, .079075, -1.220033, 1629.972656, 18.507019, .09013, -1.091255, 940.347351, 17.961655, .098008, -.945965, 425.901093, 24.47801, .138246, -1.084105, 416.823944, 20.003433, .174489, -1.133148, 302.730042, 18.550846, .207969, -1.138483, 242.853577, 15.923334, .249132, -1.168197, 191.649445, 13.940813, .291391, -1.187038, 152.910309, 12.263267, .332856, -1.192793, 121.905075, 10.822873, .377473, -1.202846, 99.145561, 9.618412, .422601, -1.208871, 81.343315, 8.591735, .465276, -1.204545, 66.742569, 7.692911, .50471, -1.190839, 54.787876, 6.915612, .544909, -1.178827, 45.507313, 6.242786, .582125, -1.16059, 37.819912, 5.65169, .620694, -1.145481, 31.926588, 5.12366, .659127, -1.130178, 27.14731, 4.669475, .684358, -1.093728, 22.650702, 4.258717, .719453, -1.074591, 19.454103, 3.901225, .751695, -1.051678, 16.735672, 3.57687, .775082, -1.017716, 14.281039, 3.287471, .796233, -.982759, 12.261332, 3.023708, .827404, -.961227, 10.767912, 2.78774, .848149, -.928433, 9.37135, 2.570737, .864891, -.892838, 8.142364, 2.379204, .880979, -.858193, 7.118954, 2.20447, .910434, -.837281, 6.389041, 2.041554, .925396, -.803638, 5.643217, 1.893353, .942463, -.772925, 5.031223, 1.757331, .955217, -.73972, 4.486978, 1.633572, .96857, -.708048, 4.014621, 1.520414, .981672, -.677109, 3.617768, 1.412506, .992829, -.645712, 3.258773, 1.317079, 1.02127, -.625746, 3.00664, 1.222611, 1.031247, -.594628, 2.733073, 1.137911, 1.043581, -.56554, 2.498495, 1.058439, 1.05593, -.536962, 2.289843, .984428, 1.066727, -.508076, 2.108603, .912794, 1.081225, -.481297, 1.951454, .845536, 1.088198, -.451563, 1.801891, .782718, 1.123316, -.433247, 1.704316, .721664, 1.133206, -.404812, 1.586153, .662761, 1.152889, -.379901, 1.490958, .606866, 1.188158, -.359421, 1.41573, .550666, 1.217064, -.336049, 1.344172, .496748, 1.257727, -.314816, 1.283196, .443538, 1.286647, -.28953, 1.225903, .394018, 1.308729, -.262053, 1.173928, .346255, 1.351453, -.237704, 1.139992, .300393, 1.380284, -.209733, 1.105997, .256661, 1.414621, -.181613, 1.082109, .215429, 1.453045, -.152797, 1.063853, .177098, 1.481066, -.121803, 1.043185, .137203, 1.514113, -.09025, 1.027072, .096998, 1.547317, -.057603, 1.012551, .055328, 1.577983, -.023799, .999267, .013094, 108e-6, -.12497, 1249.704346, 1249.703491, 14e-5, -.119585, 1195.855469, 1195.85437, .003995, -.927433, 9274.246094, 232.443573, .012013, -1.13158, 11315.999023, 98.211105, .023892, -1.216018, 12162.739258, 67.2145, .047506, -1.517865, 15186.294922, 42.410069, .082523, -1.812564, 18145.71875, 24.421545, .112452, -1.805072, 11112.966797, 18.450365, .16446, -2.016784, 8086.032715, 14.043465, .19587, -1.898199, 4245.658203, 13.178202, .197797, -1.556158, 1315.561768, 30.760096, .21954, -1.433455, 802.380371, 25.037956, .268696, -1.483235, 579.715515, 20.975695, .265968, -1.261051, 386.583649, 12.017023, .325369, -1.343349, 316.795959, 12.612406, .387968, -1.411606, 232.491623, 13.29694, .435543, -1.411236, 181.515228, 11.646996, .482729, -1.405722, 143.425354, 10.265131, .531742, -1.402782, 114.920082, 9.114828, .559383, -1.346165, 88.589005, 8.089214, .607851, -1.342407, 73.05661, 7.249064, .656928, -1.338238, 60.826897, 6.531094, .681212, -1.285692, 48.727219, 5.868711, .729238, -1.279951, 41.256016, 5.324553, .751172, -1.230045, 33.72826, 4.816513, .773107, -1.184288, 27.913816, 4.377203, .815726, -1.171653, 24.065962, 3.999965, .837886, -1.130636, 20.25486, 3.658493, .857674, -1.089071, 17.138168, 3.34793, .87612, -1.048303, 14.572968, 3.072666, .893935, -1.00904, 12.496377, 2.825165, .927998, -.989064, 11.040731, 2.60552, .928445, -.935017, 9.365102, 2.401481, .945279, -.899993, 8.177711, 2.222282, .959378, -.863854, 7.155303, 2.059342, .971761, -.827684, 6.284632, 1.909314, .987812, -.795878, 5.583837, 1.771094, 1.001958, -.76354, 4.962345, 1.645968, 1.014357, -.730897, 4.435898, 1.527438, 1.025946, -.698675, 3.973241, 1.421337, 1.036435, -.666662, 3.568025, 1.323677, 1.046807, -.635466, 3.218647, 1.232678, 1.052974, -.60266, 2.902273, 1.147675, 1.086089, -.585364, 2.694939, 1.068352, 1.09466, -.554784, 2.454491, .993445, 1.117131, -.5315, 2.270746, .923758, 1.114009, -.496581, 2.063934, .858381, 1.137328, -.473914, 1.91799, .79498, 1.158671, -.450127, 1.786523, .735697, 1.177878, -.425306, 1.662454, .677498, 1.20751, -.403797, 1.559058, .621762, 1.244496, -.383812, 1.466801, .56619, 1.240412, -.35108, 1.366853, .514288, 1.321257, -.3412, 1.309808, .464621, 1.336512, -.31271, 1.241822, .413228, 1.365047, -.286935, 1.186612, .366092, 1.418984, -.265184, 1.15212, .321528, 1.388864, -.22775, 1.089937, .271827, 1.464383, -.207168, 1.077271, .232838, 1.473125, -.17577, 1.041835, .193289, 1.542908, -.150424, 1.036794, .156153, 1.563005, -.118748, 1.013029, .114866, 1.637048, -.089604, 1.013493, .076804, 1.670777, -.056398, .999208, .032691 ];
        var LTC_MAG = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, .999995, .99999, .999971, .999937, .999853, .99967, .999138, .996746, .979578, .979309, .978836, .977972, .976223, .972205, .962466, .953919, .949829, .942492, .92987, .921319, .911112, .896015, .885105, .869971, .855017, .838328, .821241, .802352, .783873, .763309, .743058, .721929, .699755, .677721, .655456, .632681, .609629, .586831, .564287, .541772, .519428, .497353, .475624, .454606, .434099, .414085, .394605, .375698, .357386, .339871, .323085, .306905, 1, 1, 1, 1, 1, 1, 1, 1, .999999, .999999, .999998, .999995, .99999, .99998, .999959, .999923, .999842, .99966, .999119, .996613, .981824, .979298, .978826, .977957, .976184, .972091, .962188, .953875, .949746, .942335, .930166, .921211, .910927, .896979, .88494, .869864, .854835, .8382, .821049, .802552, .783659, .763512, .742927, .721715, .699938, .677775, .655246, .632555, .609805, .586996, .564225, .541606, .519346, .497419, .475863, .454738, .434099, .414003, .394547, .375747, .357564, .340012, .323099, .306861, 1, 1, 1, 1, 1, 1, 1, 1, 1, .999999, .999998, .999995, .999991, .999979, .999959, .999917, .999839, .999648, .999074, .996168, .98377, .979279, .9788, .977905, .976058, .971727, .96212, .953901, .949485, .941859, .930911, .920853, .910394, .8976, .884427, .870101, .854522, .838325, .820754, .802707, .783223, .763605, .742872, .721565, .699935, .677726, .655242, .63258, .609766, .586946, .564275, .541759, .519467, .497478, .475886, .454794, .434233, .414207, .394751, .375892, .357683, .340146, .323287, .307095, 1, 1, 1, 1, 1, 1, 1, .999999, .999999, .999998, .999996, .999992, .999987, .999975, .999953, .999913, .99983, .99963, .998993, .995279, .985142, .979252, .978754, .977821, .975838, .971088, .962563, .954785, .949048, .941052, .93142, .920812, .90975, .897867, .883856, .870091, .854353, .838166, .820661, .802465, .783308, .763346, .742734, .721608, .699747, .677626, .655245, .632547, .609793, .587044, .56434, .541779, .519529, .497633, .476114, .45503, .43443, .414406, .394974, .376154, .357979, .340443, .323572, .307379, 1, 1, 1, 1, 1, 1, 1, 1, .999998, .999998, .999996, .999991, .999984, .99997, .999946, .999905, .999815, .999599, .998856, .993704, .986135, .979212, .97869, .977691, .975504, .970133, .962951, .955649, .948405, .940418, .93166, .920881, .909376, .897785, .883844, .869756, .854326, .837732, .820617, .802053, .783195, .763119, .74261, .721344, .699709, .677624, .655114, .632523, .609812, .587052, .564417, .541966, .519751, .497824, .476309, .455271, .434735, .414736, .395317, .376524, .358364, .340852, .323988, .307786, 1, 1, 1, 1, 1, 1, .999999, .999999, .999997, .999996, .999994, .999989, .99998, .999965, .99994, .999895, .999796, .999559, .998638, .992774, .986878, .980297, .978602, .977514, .975026, .969169, .963214, .956267, .947689, .940054, .931637, .920678, .90899, .897349, .883905, .869139, .854177, .837476, .820295, .801977, .782798, .762978, .742418, .721193, .69956, .677402, .655108, .632543, .609804, .587158, .564557, .542096, .519908, .498088, .476632, .455623, .435104, .415161, .395783, .377005, .358843, .341345, .324529, .308355, 1, 1, 1, 1, 1, .999999, .999999, .999998, .999997, .999992, .999991, .999985, .999977, .999959, .999935, .999878, .999773, .999505, .998284, .992353, .987457, .981665, .978492, .977277, .97436, .968716, .963373, .956629, .947397, .939657, .931339, .920588, .908975, .896712, .883763, .86889, .853731, .837333, .819702, .801738, .782454, .762712, .742024, .721037, .699325, .677359, .65503, .632439, .609869, .587221, .564663, .542328, .52022, .4984, .476997, .456053, .435593, .415658, .3963, .377577, .359473, .342004, .32517, .308997, 1, 1, 1, 1, 1, .999999, .999998, .999998, .999996, .999993, .999988, .999981, .999971, .999951, .999921, .999863, .999748, .999433, .997681, .99212, .98792, .982864, .978353, .976961, .973451, .968396, .9634, .95668, .947529, .939151, .930747, .920511, .908867, .896142, .883335, .868764, .853025, .837015, .819452, .801249, .782176, .762345, .741843, .720721, .699135, .677194, .654889, .632487, .609902, .587328, .564891, .542567, .520501, .498793, .477442, .456528, .436131, .416273, .39698, .378276, .360176, .342738, .32595, .309803, 1, 1, 1, 1, .999999, .999998, .999999, .999997, .999995, .999991, .999985, .999978, .999963, .999942, .999907, .999844, .999715, .999332, .996612, .991974, .988297, .983843, .978349, .97654, .972351, .968109, .96328, .956464, .947779, .938754, .929952, .920253, .90853, .895785, .882679, .868456, .852669, .836406, .819138, .800708, .781803, .761855, .741534, .720405, .698959, .676964, .654827, .632411, .609922, .587477, .565051, .542829, .520889, .499225, .477951, .457148, .436792, .416963, .397723, .379068, .361025, .343608, .326842, .310718, 1, 1, 1, 1, 1, .999999, .999998, .999995, .999994, .99999, .999983, .999971, .999954, .999932, .999892, .99982, .999675, .99919, .995492, .991911, .98861, .984662, .979221, .975975, .971671, .967788, .963002, .955938, .947965, .938692, .929309, .919781, .908268, .895518, .882022, .867884, .852346, .835746, .818607, .800261, .781335, .761539, .741063, .720116, .698617, .676815, .6547, .632389, .610037, .587591, .565328, .543205, .521293, .499745, .478562, .457776, .437515, .417776, .398586, .379963, .361984, .344616, .327857, .311751, 1, 1, 1, 1, 1, .999999, .999997, .999996, .999992, .999986, .999977, .999965, .999947, .999916, .999873, .999794, .999628, .998966, .994914, .991849, .988873, .985288, .98017, .975207, .971156, .967476, .962538, .955601, .947978, .938542, .928618, .919056, .90789, .895098, .881352, .867263, .851806, .835168, .818003, .799785, .780633, .76108, .740618, .719795, .698332, .676629, .654544, .632411, .610042, .587805, .565593, .543549, .521793, .500309, .479195, .458546, .438353, .418669, .399557, .381012, .363049, .34571, .329006, .312948, 1, 1, 1, 1, 1, .999999, .999997, .999993, .99999, .999984, .999972, .99996, .999939, .999906, .999853, .999765, .999567, .998603, .994519, .991794, .989089, .985781, .980956, .974161, .970688, .967064, .96189, .955292, .947848, .938359, .928226, .918214, .907361, .894702, .880834, .8665, .851209, .834627, .817211, .79925, .780131, .760512, .740218, .719264, .698063, .676325, .65445, .632316, .61017, .587988, .565891, .544013, .522305, .500958, .479971, .459376, .439271, .419699, .40062, .382126, .364246, .346967, .330273, .314236, 1, 1, 1, 1, .999999, .999998, .999996, .999994, .999988, .999979, .999967, .999952, .999924, .999888, .999833, .999733, .99949, .997946, .994192, .991812, .989274, .986224, .981547, .974, .970269, .966545, .961031, .954921, .947416, .938226, .928003, .91739, .906553, .894191, .880329, .86554, .850476, .834058, .816467, .798509, .779561, .759828, .739738, .718878, .697718, .676138, .654342, .632317, .610292, .588207, .566289, .544443, .522927, .501674, .480765, .460314, .440304, .420782, .401824, .38341, .365538, .348312, .331692, .315688, 1, 1, 1, 1, .999999, .999998, .999996, .999993, .999985, .999976, .999961, .999943, .999913, .999872, .999807, .999691, .99939, .996859, .994003, .991808, .989423, .986523, .981783, .974511, .969791, .965933, .960377, .954434, .946803, .938026, .92762, .916545, .905639, .893489, .87982, .864852, .849513, .833311, .815878, .797621, .778938, .759253, .739142, .718479, .697274, .675902, .654135, .632357, .610364, .588497, .566631, .545012, .523579, .502429, .48168, .461304, .441425, .422039, .403135, .384779, .366976, .349796, .333231, .317277, 1, 1, 1, 1, .999999, .999998, .999996, .999991, .999983, .999974, .999956, .999932, .999901, .999852, .99978, .999646, .999248, .996193, .993784, .991782, .989539, .986694, .981765, .975135, .969309, .965128, .959788, .953831, .946255, .937664, .927351, .916044, .904715, .892528, .879111, .864256, .848452, .832434, .815129, .796806, .778118, .758668, .738466, .718024, .696958, .675642, .654067, .632325, .610546, .588786, .567123, .545617, .524312, .503348, .482637, .462418, .442657, .423338, .404564, .386277, .368545, .351448, .334906, .318961, 1, 1, 1, .999999, .999999, .999998, .999994, .999989, .999979, .999968, .999949, .999921, .999886, .999833, .999747, .999596, .999029, .995749, .993677, .991724, .98962, .986723, .981515, .975767, .969056, .964124, .959142, .953036, .94565, .937022, .926971, .915515, .903584, .891603, .878212, .863472, .847652, .831398, .814299, .796105, .777231, .757977, .737895, .717415, .696595, .675317, .65398, .632343, .610735, .589076, .56762, .546251, .525165, .504255, .483759, .463666, .443987, .424783, .406042, .387891, .370293, .353221, .336715, .320806, 1, 1, 1, .999999, .999998, .999998, .999993, .999987, .999977, .999964, .999943, .999911, .999867, .999807, .999714, .999531, .998645, .995399, .993512, .991717, .989661, .986652, .981559, .976183, .969411, .963317, .958457, .952091, .944951, .936307, .926454, .915043, .902668, .890462, .877245, .862672, .846823, .830201, .813293, .795306, .776393, .757199, .737324, .716808, .696187, .675094, .653814, .632453, .610885, .589483, .568099, .546975, .525953, .505268, .484936, .464988, .445458, .426314, .40775, .38967, .372098, .355105, .338682, .322825, 1, 1, 1, 1, .999999, .999996, .999992, .999983, .999976, .999959, .999933, .999898, .999849, .99978, .999676, .999454, .997884, .995166, .993394, .991723, .989654, .986389, .981632, .976607, .969701, .962555, .957605, .951232, .944099, .935556, .925699, .914492, .902027, .889116, .876093, .861649, .845956, .829238, .81222, .79442, .775657, .756265, .736673, .716372, .695669, .674886, .653728, .632568, .611217, .589929, .568783, .547752, .526931, .506425, .486238, .466425, .446945, .428026, .409536, .391551, .374087, .357155, .340787, .324974, 1, 1, 1, 1, .999998, .999996, .99999, .999984, .99997, .999952, .999925, .999886, .999831, .999757, .999633, .999356, .997017, .994868, .993337, .99171, .98958, .985848, .98164, .976711, .969755, .962166, .956609, .950365, .943026, .934693, .92488, .913729, .90135, .887966, .874726, .860474, .844905, .828269, .810905, .793364, .774812, .755478, .735886, .715847, .695231, .674537, .653667, .632527, .611475, .590363, .569462, .548571, .527976, .507634, .487632, .467901, .44868, .429833, .411467, .393568, .376197, .359374, .343034, .327273, 1, 1, 1, .999999, .999998, .999993, .999989, .99998, .999965, .999945, .999913, .999869, .99981, .999723, .999583, .999213, .99654, .99474, .993244, .991671, .989411, .985533, .981616, .976847, .969968, .962315, .955468, .94942, .942016, .933617, .923949, .912899, .900495, .887022, .873283, .859153, .84383, .827325, .809888, .792172, .773832, .754686, .735035, .715297, .694955, .674242, .65366, .632752, .611804, .590993, .570154, .549539, .529087, .508974, .48903, .469599, .450466, .431761, .413508, .395761, .37848, .361679, .345465, .329752, 1, 1, 1, 1, .999997, .999994, .999987, .999978, .999961, .999936, .999903, .999855, .999786, .999689, .999527, .998988, .996137, .994527, .993108, .991599, .989084, .985308, .981527, .976677, .970079, .962535, .95449, .948271, .940942, .932422, .922836, .911896, .899632, .886118, .871864, .857719, .842536, .826163, .808849, .79086, .772802, .75386, .734335, .714582, .694543, .674071, .653544, .632922, .612153, .591573, .570951, .55052, .530352, .510311, .490707, .471359, .452396, .433837, .415736, .398052, .380874, .364232, .348023, .332368, 1, 1, 1, .999999, .999998, .999994, .999988, .999976, .999957, .999928, .999891, .999837, .999759, .99965, .999463, .998551, .995879, .994366, .992964, .991479, .988521, .985101, .981482, .976168, .970242, .962585, .95395, .946973, .939686, .931248, .921614, .910765, .898617, .885183, .870772, .856138, .84112, .824962, .807732, .789813, .771638, .753008, .733686, .713927, .694082, .673967, .653549, .633135, .612702, .5922, .571904, .551679, .531678, .511898, .492437, .473239, .454451, .436067, .418054, .400542, .383486, .366848, .350781, .335182, 1, 1, 1, .999999, .999997, .999993, .999985, .999972, .999951, .999919, .999877, .999817, .999733, .999608, .99938, .997685, .995603, .994264, .992911, .991287, .987923, .984871, .981239, .975933, .970149, .962511, .953824, .945699, .938285, .929907, .920343, .909537, .897435, .884056, .869626, .85449, .839459, .823511, .806511, .788752, .77044, .751995, .732962, .713424, .693525, .673798, .653622, .633301, .613224, .592938, .572833, .552904, .53303, .513556, .494215, .475279, .456673, .438411, .420583, .403178, .386178, .369728, .353688, .338147, 1, 1, 1, .999999, .999997, .999991, .999984, .999967, .999944, .999912, .999863, .999796, .999703, .999563, .999279, .997104, .995394, .994111, .992825, .990979, .987529, .984661, .980774, .975758, .969866, .962465, .953678, .944489, .936886, .928356, .91882, .908073, .896092, .882833, .868463, .853212, .837744, .822048, .805333, .787643, .769414, .75083, .732178, .712972, .693227, .673569, .653744, .633739, .613735, .593822, .573916, .554158, .534652, .515248, .496233, .477436, .459009, .440929, .423259, .405951, .389136, .37269, .356789, .341329, 1, 1, 1, .999999, .999996, .999991, .999981, .999966, .999939, .999903, .999847, .999771, .999666, .99951, .999131, .99669, .995147, .993882, .992696, .990474, .987227, .984334, .980153, .975438, .969406, .962238, .953598, .943868, .935356, .926721, .917122, .90643, .89455, .881354, .867131, .851954, .835972, .820331, .803911, .786452, .76842, .749821, .731298, .712393, .692979, .673418, .653859, .634232, .614327, .594732, .575131, .555584, .536346, .517175, .498323, .479744, .461485, .443645, .426061, .408969, .392155, .375921, .36006, .344677, 1, 1, 1, .999999, .999997, .999991, .999979, .99996, .999931, .999891, .999832, .999748, .999629, .999449, .99888, .996305, .995024, .993812, .992508, .989721, .986936, .983936, .979629, .974979, .968928, .96197, .953291, .943458, .933644, .925007, .915388, .904755, .892932, .879831, .865794, .850672, .834591, .818398, .802304, .785151, .76745, .748987, .730325, .711758, .692761, .673417, .653908, .634686, .615168, .595707, .576393, .557198, .538018, .519253, .500555, .48222, .464197, .446414, .429106, .412035, .395508, .379284, .363538, .34822, 1, 1, 1, .999999, .999995, .999989, .999977, .999955, .999924, .999879, .999813, .999722, .99959, .999381, .998335, .996088, .994814, .993709, .99222, .989209, .986575, .983383, .979084, .974272, .968359, .961275, .953025, .943098, .932434, .923101, .913477, .902861, .891059, .878072, .864118, .849188, .833281, .816808, .800596, .783745, .766331, .748123, .729686, .711078, .692527, .673491, .654296, .635113, .616048, .596847, .57772, .558879, .540028, .521371, .502996, .484858, .466997, .449477, .432217, .415426, .398924, .38289, .367206, .351955, 1, 1, 1, .999998, .999996, .999988, .999974, .999953, .999918, .999865, .999791, .99969, .999542, .999293, .997535, .99579, .994609, .993557, .991766, .988767, .986255, .982544, .978541, .973528, .9677, .960596, .952299, .942684, .931653, .921211, .911489, .900818, .889018, .876245, .862406, .847517, .831852, .815367, .798719, .782224, .765167, .747304, .729133, .710485, .692196, .673589, .65477, .635717, .616986, .598119, .579298, .56056, .542163, .523669, .505564, .487642, .469991, .452658, .43562, .418937, .402612, .386633, .371091, .355949, 1, 1, .999999, .999998, .999995, .999986, .999973, .999948, .999909, .999852, .999769, .999656, .99949, .999186, .997059, .995624, .99451, .993327, .99102, .988379, .985771, .981971, .978051, .972892, .96702, .959965, .951625, .941902, .930951, .91937, .909285, .898562, .886809, .874251, .860597, .845808, .830365, .813972, .79726, .780597, .763854, .746401, .728519, .710203, .691882, .673687, .655275, .636621, .617909, .599473, .581032, .56256, .544295, .526228, .508293, .490652, .473242, .456004, .439212, .422663, .406476, .390647, .375204, .360129, 1, 1, 1, .999999, .999994, .999984, .999969, .99994, .999898, .999837, .999746, .999617, .999438, .999016, .996703, .995302, .994356, .992993, .99039, .988072, .985152, .981447, .977273, .972234, .966113, .959033, .950869, .941217, .930175, .918279, .906941, .896201, .884509, .87192, .85842, .843906, .82873, .812524, .795978, .778979, .76245, .745459, .727966, .710046, .691808, .673739, .655756, .637574, .619153, .600887, .582796, .564748, .546636, .528904, .511252, .493791, .476563, .459695, .442942, .426632, .410558, .394895, .379517, .36456, 1, 1, 1, .999998, .999994, .999984, .999966, .999934, .999887, .999819, .99972, .999578, .999367, .998696, .996353, .995201, .994115, .992665, .989948, .987633, .984331, .980827, .97639, .971327, .965201, .957977, .949712, .940128, .929187, .917237, .904645, .893711, .882112, .869516, .856236, .841929, .826924, .810991, .794686, .777761, .76098, .744384, .727314, .709877, .691988, .674098, .656243, .638603, .620606, .602574, .584694, .567018, .549311, .531673, .514403, .497148, .480177, .463439, .446998, .430743, .414943, .399304, .384121, .369251, 1, 1, 1, .999997, .999992, .999981, .999962, .999927, .999874, .999798, .999691, .999533, .999291, .997909, .996117, .995029, .99388, .992142, .989576, .987185, .983587, .980055, .975487, .970172, .963998, .956738, .948637, .939083, .928169, .916144, .903147, .890916, .879389, .866895, .853826, .839729, .824957, .809472, .793341, .776743, .759808, .743277, .726643, .709685, .692249, .674639, .657008, .639576, .622114, .604471, .586851, .56934, .552135, .534806, .517599, .500765, .484035, .46744, .451212, .43524, .419399, .404083, .388944, .374182, 1, 1, 1, .999998, .999993, .999979, .999958, .999919, .999861, .999774, .999656, .999482, .999195, .997307, .995837, .994722, .993707, .991391, .989169, .986461, .982904, .979062, .974536, .969035, .962653, .955486, .947243, .937747, .926861, .914936, .901835, .888472, .876571, .864223, .851252, .837374, .822985, .807788, .791927, .775702, .758928, .742347, .725914, .709495, .692569, .675363, .658085, .640639, .623698, .606505, .589267, .572008, .554939, .538132, .521211, .504487, .488048, .471807, .455651, .439858, .424332, .408983, .394071, .379402, 1, 1, 1, .999997, .999992, .999978, .999954, .999913, .999844, .999753, .999618, .999424, .999067, .996875, .995659, .994603, .99342, .990874, .988713, .985585, .982193, .978145, .973416, .967801, .961483, .954069, .945704, .936138, .925374, .913395, .900339, .886675, .873512, .861326, .848513, .834956, .82082, .805943, .790574, .774677, .758279, .741807, .725271, .709231, .692874, .676189, .659352, .642296, .62525, .6087, .591823, .575012, .558143, .541491, .525075, .508558, .492277, .47627, .460459, .44474, .4294, .414309, .399421, .384907, 1, 1, 1, .999997, .99999, .999977, .999947, .999902, .999832, .99973, .999577, .999359, .998845, .996554, .995328, .994442, .992919, .990393, .98817, .984855, .981312, .977149, .972137, .966207, .959967, .952454, .943873, .934434, .923813, .911942, .898928, .88512, .871043, .858248, .845666, .832346, .818482, .804029, .788982, .773571, .7577, .741484, .725186, .708915, .693244, .677028, .660656, .644079, .627377, .610804, .594542, .578112, .56165, .545163, .528962, .512926, .496893, .481007, .465397, .450042, .43474, .419831, .405156, .390692, 1, 1, .999999, .999997, .999989, .999973, .999942, .999891, .999813, .999698, .999532, .999285, .998286, .996295, .995215, .994182, .992032, .989855, .987415, .984047, .98005, .976017, .970845, .964767, .958269, .9506, .942033, .932501, .921807, .910017, .897149, .883414, .869182, .855055, .842687, .829548, .816162, .802072, .787436, .772533, .757043, .741263, .72533, .709262, .693497, .678038, .662128, .646068, .629824, .613437, .597334, .581401, .565372, .549288, .533182, .517405, .501765, .486143, .470675, .455465, .440532, .42563, .411113, .396887, 1, 1, .999999, .999996, .999989, .99997, .999934, .999879, .999793, .999665, .999481, .999192, .997506, .995926, .995009, .993736, .991298, .989326, .986371, .983199, .979032, .974596, .969364, .963198, .956385, .948509, .939993, .930421, .91959, .90814, .895349, .881699, .867456, .852784, .8395, .826629, .813602, .799983, .785873, .77134, .75648, .74119, .725687, .709997, .694192, .678975, .663673, .648135, .632442, .616477, .600565, .584772, .569202, .553595, .537881, .522193, .506784, .491554, .476349, .461278, .446419, .431913, .417443, .403271, 1, 1, .999999, .999995, .999986, .999966, .999927, .999867, .999772, .999629, .999423, .999075, .997024, .995773, .994651, .993353, .990822, .988569, .985596, .982182, .977871, .97314, .967584, .961408, .954294, .946398, .937603, .927937, .917305, .905833, .893138, .87977, .86572, .851023, .836801, .823784, .810909, .797886, .784177, .770243, .755925, .741144, .726214, .710971, .695563, .680212, .665304, .650297, .635168, .619796, .604217, .588692, .573254, .557998, .542839, .52747, .512162, .497115, .482296, .467477, .452812, .43831, .424184, .410163, 1, 1, .999999, .999996, .999984, .999962, .99992, .999852, .999745, .999586, .999354, .998894, .996686, .995485, .994493, .992573, .990323, .987772, .984692, .980887, .976446, .971625, .965717, .959421, .951975, .944086, .935066, .925403, .914814, .903208, .890958, .877817, .863828, .849289, .834872, .820889, .808183, .79566, .782556, .769066, .755386, .741229, .726726, .71217, .697209, .68217, .667203, .652689, .637938, .623262, .60819, .593002, .577817, .562737, .547836, .533036, .518052, .503135, .488422, .473986, .459552, .445282, .431149, .417407, 1, 1, .999999, .999994, .999983, .999957, .999914, .999835, .999718, .999538, .999275, .998454, .996341, .995246, .994222, .991844, .989829, .986688, .983562, .979638, .974932, .969827, .963621, .957146, .949365, .941398, .932245, .922556, .911949, .900627, .88844, .875544, .862005, .84781, .833372, .819134, .805508, .793339, .780916, .767837, .754858, .741307, .727496, .713386, .699131, .684542, .669878, .655261, .641035, .626685, .612377, .597625, .582805, .56803, .553204, .538684, .524269, .509662, .495119, .480735, .466634, .452593, .438748, .424915, 1, 1, .999998, .999994, .999982, .999956, .999901, .999818, .999683, .999487, .999185, .997584, .996004, .99505, .993715, .991212, .989057, .985879, .982243, .978206, .973119, .967919, .961343, .954603, .946712, .938378, .929266, .919443, .908911, .897725, .885589, .873254, .859889, .846123, .832094, .817898, .803866, .791061, .779235, .766885, .754292, .741565, .728331, .714861, .701179, .687166, .673012, .658716, .644442, .630472, .616519, .602514, .588172, .573689, .559281, .544768, .530543, .516485, .502303, .4881, .474095, .460245, .446598, .433169, 1, 1, .999997, .999993, .99998, .999947, .999891, .999794, .999647, .999425, .999062, .997049, .995778, .994652, .992778, .990482, .988004, .984893, .980881, .976605, .971199, .96561, .958925, .951746, .943791, .9352, .926018, .916028, .905724, .894528, .882914, .87074, .857802, .844552, .830857, .816921, .803102, .789625, .77748, .765891, .753908, .741795, .72939, .71644, .703411, .690068, .676438, .662586, .648697, .634732, .620997, .607451, .593765, .579748, .565661, .551594, .537396, .523433, .509708, .495972, .482082, .468427, .45489, .441623, 1, 1, .999999, .999991, .999977, .99994, .999875, .999769, .999605, .999352, .998882, .996665, .995459, .99438, .992014, .989912, .986796, .983537, .979326, .974792, .96914, .96316, .956222, .948807, .940518, .931755, .922452, .912319, .902227, .891142, .879838, .868047, .855745, .842718, .829827, .816398, .802786, .789396, .776581, .764901, .75371, .742102, .730448, .718337, .705768, .693172, .680153, .666882, .653401, .639837, .626152, .612676, .599435, .586109, .572473, .558715, .544964, .531112, .517416, .503992, .490653, .477162, .463832, .450645, 1, 1, .999999, .999992, .999973, .999933, .999861, .999741, .999554, .999267, .998411, .996303, .995191, .993945, .991406, .989019, .98572, .982057, .977501, .972605, .966697, .96034, .953031, .945347, .936866, .927917, .918562, .908598, .898486, .887794, .876545, .865379, .853428, .841167, .828649, .815967, .802957, .789865, .777077, .764695, .753544, .742694, .731571, .720304, .70849, .696351, .684134, .67147, .658541, .645376, .632209, .618776, .605511, .592527, .579546, .56631, .55286, .539492, .526005, .512564, .49934, .48636, .473357, .460306, 1, 1, .999998, .999991, .99997, .999926, .999842, .99971, .999498, .999164, .997464, .99587, .994917, .992911, .990682, .987816, .98441, .980551, .975693, .970263, .963946, .957248, .949765, .941571, .932941, .923873, .914332, .90456, .894394, .884127, .873294, .862503, .851335, .839566, .827776, .815708, .80337, .790821, .778386, .766121, .754193, .74342, .732975, .722326, .711376, .699992, .68818, .676354, .664004, .651449, .6386, .625776, .61266, .599603, .586719, .574078, .561273, .548129, .535155, .522015, .508851, .495837, .48319, .470624, 1, 1, .999998, .999988, .999965, .999916, .999823, .999669, .999425, .999025, .996874, .99567, .994415, .991991, .989766, .986646, .982812, .978356, .973317, .967612, .96082, .953603, .945969, .937323, .928661, .919507, .909833, .900245, .89039, .880252, .87, .859518, .849163, .838101, .82696, .815688, .804126, .792234, .780356, .768474, .756678, .745159, .734601, .724624, .714339, .703751, .692766, .681267, .669799, .657871, .645577, .633102, .62056, .607737, .59489, .582143, .569779, .55736, .544651, .531942, .519228, .506467, .49371, .481143, 1, 1, .999998, .999988, .999961, .999902, .999798, .999622, .999341, .998801, .996397, .995225, .993927, .991338, .9885, .985327, .981195, .976383, .970726, .964471, .957386, .949813, .941694, .932681, .923974, .914755, .905026, .895649, .886178, .876277, .866629, .85689, .846934, .836887, .826373, .815885, .805169, .794133, .782812, .771547, .760175, .748896, .737687, .727152, .717601, .70767, .697425, .686788, .675664, .664513, .652962, .640965, .628851, .616551, .604168, .591559, .579009, .566648, .554597, .542382, .529999, .517655, .505254, .492894, 1, 1, .999997, .999986, .999956, .999889, .999766, .999562, .99924, .997952, .996094, .994979, .992773, .990536, .987214, .983322, .978938, .973714, .967681, .960981, .953144, .945475, .936909, .927734, .918826, .90959, .900085, .890867, .881801, .872565, .863236, .854239, .84506, .835686, .826251, .816284, .806586, .796419, .785914, .77521, .764461, .753599, .742805, .731872, .72137, .711898, .702337, .692383, .682137, .671365, .660479, .649314, .637685, .625899, .613898, .601865, .589582, .577285, .565013, .553106, .54128, .529367, .51732, .505411, 1, 1, .999997, .999983, .999948, .999869, .999732, .999499, .999111, .997167, .99572, .994349, .991727, .989197, .985883, .981483, .976618, .970597, .964122, .956994, .948639, .9405, .931606, .922385, .913291, .904205, .894938, .88589, .877334, .868754, .860053, .851683, .843447, .834889, .826304, .817441, .808285, .799141, .78957, .7796, .76951, .759155, .748882, .738346, .727629, .717273, .707467, .698283, .688609, .678748, .668371, .657739, .646951, .635765, .624254, .612647, .6009, .589061, .576998, .564991, .553102, .541517, .530027, .518495, 1, 1, .999997, .999983, .999939, .999851, .999684, .999412, .998925, .996597, .995207, .993603, .990903, .987594, .983814, .979016, .973647, .967048, .960109, .952123, .94356, .9349, .925747, .916566, .907305, .898441, .889629, .881042, .872874, .865064, .857225, .849446, .842063, .834561, .826814, .818875, .810748, .802316, .793699, .784704, .775198, .765643, .755735, .745873, .735526, .725229, .714892, .704807, .695502, .686241, .676633, .666688, .656384, .645871, .635174, .624113, .612788, .601426, .589925, .578399, .566612, .554931, .543383, .532065, 1, 1, .999996, .999977, .999928, .999824, .999633, .999306, .998429, .996133, .99489, .992316, .989752, .986095, .981564, .976234, .970081, .962779, .955232, .946702, .937716, .928604, .919281, .910167, .901046, .892446, .884183, .876253, .868619, .861545, .854673, .847885, .841074, .83461, .827984, .820945, .813648, .806232, .798444, .790232, .781853, .772897, .763648, .754227, .744542, .734689, .724526, .714204, .704152, .694222, .685143, .67586, .666319, .656415, .646273, .635902, .625399, .614563, .60349, .592413, .581217, .57, .558608, .547242, 1, .999999, .999995, .999972, .999915, .99979, .999562, .999168, .997237, .995672, .994074, .99122, .987792, .983822, .978599, .972804, .965718, .958053, .94946, .940503, .931011, .921608, .912409, .903378, .894606, .886369, .878756, .871573, .864862, .858421, .852541, .846802, .841027, .835206, .829628, .82373, .817415, .810655, .803873, .796659, .788887, .78094, .772537, .763507, .754487, .745163, .735572, .725687, .715611, .705398, .695418, .685592, .676518, .667304, .657875, .648182, .638235, .628062, .617813, .607283, .596552, .58577, .575033, .564153, 1, 1, .999995, .99997, .999898, .999748, .999472, .998969, .996528, .995102, .992701, .989963, .985981, .981194, .975183, .968501, .960502, .952012, .942861, .933376, .923506, .914042, .904921, .896282, .887987, .880341, .873536, .867293, .861556, .856148, .850987, .846352, .841684, .83688, .832036, .827091, .8219, .816206, .810042, .803629, .796918, .789653, .781915, .774014, .76553, .756526, .747669, .738342, .72877, .718942, .708942, .698855, .688933, .679131, .669855, .660811, .651549, .642127, .632454, .622651, .612709, .602606, .592344, .581877, 1, .999999, .999993, .999963, .999874, .999691, .99935, .998431, .995873, .994456, .991327, .987798, .983232, .9775, .970828, .962815, .954228, .944752, .935126, .925179, .915102, .905763, .897087, .888933, .881452, .874687, .868716, .863585, .858931, .854662, .850569, .846719, .843151, .839426, .835588, .831443, .827004, .822395, .817254, .81163, .805464, .799124, .792382, .785091, .777315, .76936, .760908, .751957, .743128, .733917, .72434, .714713, .704721, .694835, .684862, .675099, .66557, .656644, .647651, .638581, .629337, .619926, .610358, .600707, 1, 1, .99999, .999953, .999843, .999613, .999186, .997025, .995317, .99285, .98976, .98527, .979807, .973049, .965228, .956248, .946394, .936324, .926124, .915808, .905942, .89706, .889001, .881755, .875351, .869688, .864736, .860745, .857305, .85419, .851261, .848484, .845642, .842948, .84006, .836901, .833379, .829393, .825103, .820431, .815288, .809575, .803326, .796949, .790174, .782873, .775048, .767139, .758772, .750019, .74112, .732127, .722743, .713225, .703637, .693768, .684016, .674277, .664703, .655328, .64655, .637812, .629036, .620129, 1, 1, .999988, .999933, .9998, .999508, .998917, .996236, .994617, .991176, .987089, .98188, .974966, .967156, .957914, .947585, .936937, .926318, .915662, .905567, .896223, .888166, .881117, .875079, .869981, .865675, .862091, .859183, .856981, .855065, .853273, .851572, .849782, .847768, .845668, .843345, .840703, .837646, .834094, .83003, .825631, .820873, .815619, .809856, .803578, .797096, .790359, .783152, .775507, .767504, .759411, .750982, .742208, .733383, .724445, .71519, .705827, .69644, .686773, .677242, .667735, .658471, .649236, .640305, 1, .999999, .999984, .999918, .999737, .99935, .997576, .995476, .992614, .988817, .983601, .97688, .968694, .959092, .948297, .936831, .925592, .914494, .904159, .894643, .886417, .87962, .874023, .869533, .865967, .863238, .861113, .859527, .858367, .857594, .856882, .856172, .855316, .854197, .852818, .851062, .849046, .846747, .844043, .840842, .837164, .832985, .828344, .823544, .818276, .812543, .806374, .799838, .79317, .786246, .778956, .771297, .763278, .755252, .746984, .738445, .729688, .721045, .712189, .703099, .694045, .68493, .675601, .66648, 1, .999999, .999978, .999888, .999639, .999093, .99631, .994405, .990527, .985186, .978518, .969748, .959597, .948104, .935724, .923704, .912023, .901356, .89185, .883847, .87728, .872289, .868583, .865913, .864098, .862993, .862356, .862125, .862107, .862168, .862359, .86249, .86243, .862063, .861431, .860386, .85895, .85709, .854848, .852381, .849503, .846167, .842399, .838194, .833566, .828579, .823464, .817951, .812079, .805873, .79932, .792533, .785715, .778636, .77126, .763618, .755719, .747815, .739825, .731602, .723212, .714845, .706465, .697933, 1, .999998, .999969, .999836, .999475, .997943, .995219, .99176, .986663, .979592, .970218, .959155, .946575, .933047, .920022, .907749, .896801, .887506, .880077, .874322, .870126, .867481, .865949, .865293, .865287, .865746, .866502, .867439, .868442, .869382, .870161, .870782, .871303, .871511, .871427, .870978, .870136, .868892, .867248, .865209, .862775, .859944, .857004, .853671, .849984, .845927, .841518, .836774, .83175, .826407, .821001, .815333, .809412, .803238, .796802, .790204, .783457, .776713, .769749, .762596, .755239, .74769, .740127, .732595, 1, .999997, .99995, .999744, .999162, .996124, .992844, .987757, .980062, .969642, .957087, .942735, .927747, .913622, .900889, .890115, .881584, .875288, .870926, .868307, .867033, .866972, .867692, .86895, .870549, .87232, .874144, .875947, .877674, .879192, .880478, .881539, .882307, .882739, .882902, .882847, .882461, .881725, .880636, .879197, .877422, .875296, .872849, .870076, .866988, .863637, .860159, .856475, .852525, .848328, .843883, .839198, .834322, .829221, .823907, .818461, .812972, .807316, .801474, .795459, .789276, .783025, .776615, .770223, .999999, .999994, .999909, .999536, .997195, .994123, .988168, .979344, .967003, .951763, .934724, .917948, .902918, .890432, .880902, .874401, .870394, .868503, .868209, .869062, .870725, .873006, .875558, .87823, .880893, .883445, .885832, .888059, .890058, .891782, .893247, .89446, .895397, .896023, .89638, .896433, .896198, .895673, .894865, .893908, .8927, .891224, .889501, .887539, .885336, .882903, .880244, .877373, .874296, .871019, .867549, .863933, .860153, .856355, .852395, .848277, .844006, .839587, .835045, .830378, .825579, .820649, .815592, .810432, .999998, .999988, .999795, .998892, .994635, .98729, .975397, .958508, .938352, .917733, .8998, .885878, .876516, .8712, .869099, .869317, .871112, .87387, .87716, .880682, .884228, .887737, .891076, .894161, .896981, .899543, .901847, .903882, .905672, .907188, .908451, .90948, .910289, .910878, .911259, .91143, .911396, .911154, .910712, .910081, .909266, .908264, .907094, .905752, .904244, .902577, .900799, .898931, .896923, .894782, .892513, .890117, .8876, .884968, .882222, .879369, .876408, .873345, .870183, .866926, .863575, .86016, .856672, .853098, .999991, .999947, .999158, .992842, .980107, .95723, .928231, .901539, .882688, .872588, .869394, .870671, .874458, .879378, .884639, .88977, .894601, .898972, .90293, .906456, .909568, .912329, .91475, .916893, .918774, .920429, .921868, .92311, .924185, .925089, .925842, .926457, .926934, .927285, .927522, .927639, .92765, .927553, .927356, .927061, .926671, .926187, .925617, .924962, .924224, .923409, .922519, .921555, .920521, .919419, .918252, .917021, .915729, .914377, .912967, .911503, .909984, .908414, .906791, .905122, .903401, .901637, .899826, .897972, .987461, .940121, .871507, .898572, .916705, .926425, .931922, .935265, .937431, .938899, .93995, .940717, .941301, .941754, .942111, .942397, .942631, .942823, .942983, .943117, .943231, .943329, .943412, .943484, .943545, .943599, .943644, .943682, .943716, .943744, .943766, .943785, .943799, .943808, .943815, .943818, .943818, .943814, .943807, .943797, .943784, .943769, .943751, .94373, .943707, .943681, .943652, .943623, .943589, .943554, .943518, .943479, .943438, .943396, .943351, .943305, .943257, .943207, .943156, .943104, .943049, .942993, .942936, .942877 ];
        var LTC_MAT_TEXTURE = new DataTexture(new Float32Array(LTC_MAT), 64, 64, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1);
        var LTC_MAG_TEXTURE = new DataTexture(new Float32Array(LTC_MAG), 64, 64, AlphaFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, NearestFilter, 1);
        LTC_MAT_TEXTURE.onUpdate = function(texture) {
            texture.needsUpdate = true;
        };
        LTC_MAG_TEXTURE.onUpdate = function(texture) {
            texture.needsUpdate = true;
        };
        LTC_MAT_TEXTURE.needsUpdate = true;
        LTC_MAG_TEXTURE.needsUpdate = true;
        UniformsLib.ltc_brdf = {
            ltcMat: {
                value: LTC_MAT_TEXTURE
            },
            ltcMag: {
                value: LTC_MAG_TEXTURE
            }
        };
    })();
    var ShaderLib = {
        basic: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog ]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                }
            } ]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, UniformsLib.ltc_brdf, {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            } ]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, UniformsLib.ltc_brdf, {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: UniformsUtils.merge([ UniformsLib.points, UniformsLib.fog ]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            } ]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.displacementmap ]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                },
                tFlip: {
                    value: -1
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: {
                lightPos: {
                    value: new Vector3()
                }
            },
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        }
    };
    ShaderLib.physical = {
        uniforms: UniformsUtils.merge([ ShaderLib.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        } ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    };
    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();
    function UniformContainer() {
        this.seq = [];
        this.map = {};
    }
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0) return array;
        var n = nBlocks * blockSize, r = arrayCacheF32[n];
        if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                offset += blockSize;
                array[i].toArray(r, offset);
            }
        }
        return r;
    }
    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }
        for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();
        return r;
    }
    function setValue1f(gl, v) {
        gl.uniform1f(this.addr, v);
    }
    function setValue1i(gl, v) {
        gl.uniform1i(this.addr, v);
    }
    function setValue2fv(gl, v) {
        if (v.x === undefined) gl.uniform2fv(this.addr, v); else gl.uniform2f(this.addr, v.x, v.y);
    }
    function setValue3fv(gl, v) {
        if (v.x !== undefined) gl.uniform3f(this.addr, v.x, v.y, v.z); else if (v.r !== undefined) gl.uniform3f(this.addr, v.r, v.g, v.b); else gl.uniform3fv(this.addr, v);
    }
    function setValue4fv(gl, v) {
        if (v.x === undefined) gl.uniform4fv(this.addr, v); else gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
    }
    function setValue2fm(gl, v) {
        gl.uniformMatrix2fv(this.addr, false, v.elements || v);
    }
    function setValue3fm(gl, v) {
        gl.uniformMatrix3fv(this.addr, false, v.elements || v);
    }
    function setValue4fm(gl, v) {
        gl.uniformMatrix4fv(this.addr, false, v.elements || v);
    }
    function setValueT1(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTexture2D(v || emptyTexture, unit);
    }
    function setValueT6(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTextureCube(v || emptyCubeTexture, unit);
    }
    function setValue2iv(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValue3iv(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValue4iv(gl, v) {
        gl.uniform4iv(this.addr, v);
    }
    function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValue1f;

          case 35664:
            return setValue2fv;

          case 35665:
            return setValue3fv;

          case 35666:
            return setValue4fv;

          case 35674:
            return setValue2fm;

          case 35675:
            return setValue3fm;

          case 35676:
            return setValue4fm;

          case 35678:
            return setValueT1;

          case 35680:
            return setValueT6;

          case 5124:
          case 35670:
            return setValue1i;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    function setValueV2a(gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }
    function setValueV3a(gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }
    function setValueV4a(gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }
    function setValueM2a(gl, v) {
        gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
    }
    function setValueM3a(gl, v) {
        gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
    }
    function setValueM4a(gl, v) {
        gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
    }
    function setValueT1a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
        }
    }
    function setValueT6a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    }
    function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValue1fv;

          case 35664:
            return setValueV2a;

          case 35665:
            return setValueV3a;

          case 35666:
            return setValueV4a;

          case 35674:
            return setValueM2a;

          case 35675:
            return setValueM3a;

          case 35676:
            return setValueM4a;

          case 35678:
            return setValueT1a;

          case 35680:
            return setValueT6a;

          case 5124:
          case 35670:
            return setValue1iv;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
    }
    function StructuredUniform(id) {
        this.id = id;
        UniformContainer.call(this);
    }
    StructuredUniform.prototype.setValue = function(gl, value) {
        var seq = this.seq;
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length;
        RePathPart.lastIndex = 0;
        for (;;) {
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
            if (idIsIndex) id = id | 0;
            if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
                addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            } else {
                var map = container.map, next = map[id];
                if (next === undefined) {
                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }
                container = next;
            }
        }
    }
    function WebGLUniforms(gl, program, renderer) {
        UniformContainer.call(this);
        this.renderer = renderer;
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; ++i) {
            var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
            parseUniform(info, addr, this);
        }
    }
    WebGLUniforms.prototype.setValue = function(gl, name, value) {
        var u = this.map[name];
        if (u !== undefined) u.setValue(gl, value, this.renderer);
    };
    WebGLUniforms.prototype.set = function(gl, object, name) {
        var u = this.map[name];
        if (u !== undefined) u.setValue(gl, object[name], this.renderer);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        var v = object[name];
        if (v !== undefined) this.setValue(gl, name, v);
    };
    WebGLUniforms.upload = function(gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i], v = values[u.id];
            if (v.needsUpdate !== false) {
                u.setValue(gl, v.value, renderer);
            }
        }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
        var r = [];
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            if (u.id in values) r.push(u);
        }
        return r;
    };
    function LensFlarePlugin(renderer, flares) {
        var gl = renderer.context;
        var state = renderer.state;
        var vertexBuffer, elementBuffer;
        var shader, program, attributes, uniforms;
        var tempTexture, occlusionTexture;
        function init() {
            var vertices = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]);
            var faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            tempTexture = gl.createTexture();
            occlusionTexture = gl.createTexture();
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            shader = {
                vertexShader: [ "uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}" ].join("\n")
            };
            program = createProgram(shader);
            attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            };
            uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
            };
        }
        this.render = function(scene, camera, viewport) {
            if (flares.length === 0) return;
            var tempPosition = new Vector3();
            var invAspect = viewport.w / viewport.z, halfViewportWidth = viewport.z * .5, halfViewportHeight = viewport.w * .5;
            var size = 16 / viewport.w, scale = new Vector2(size * invAspect, size);
            var screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1);
            var validArea = new Box2();
            validArea.min.set(viewport.x, viewport.y);
            validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
            if (program === undefined) {
                init();
            }
            gl.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.vertex);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            gl.uniform1i(uniforms.occlusionMap, 0);
            gl.uniform1i(uniforms.map, 1);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            state.disable(gl.CULL_FACE);
            state.setDepthWrite(false);
            for (var i = 0, l = flares.length; i < l; i++) {
                size = 16 / viewport.w;
                scale.set(size * invAspect, size);
                var flare = flares[i];
                tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
                tempPosition.applyMatrix4(camera.matrixWorldInverse);
                tempPosition.applyMatrix4(camera.projectionMatrix);
                screenPosition.copy(tempPosition);
                screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8;
                if (validArea.containsPoint(screenPositionPixels) === true) {
                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, null);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, tempTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                    gl.uniform1i(uniforms.renderType, 0);
                    gl.uniform2f(uniforms.scale, scale.x, scale.y);
                    gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                    state.disable(gl.BLEND);
                    state.enable(gl.DEPTH_TEST);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                    gl.uniform1i(uniforms.renderType, 1);
                    state.disable(gl.DEPTH_TEST);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, tempTexture);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    flare.positionScreen.copy(screenPosition);
                    if (flare.customUpdateCallback) {
                        flare.customUpdateCallback(flare);
                    } else {
                        flare.updateLensFlares();
                    }
                    gl.uniform1i(uniforms.renderType, 2);
                    state.enable(gl.BLEND);
                    for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                        var sprite = flare.lensFlares[j];
                        if (sprite.opacity > .001 && sprite.scale > .001) {
                            screenPosition.x = sprite.x;
                            screenPosition.y = sprite.y;
                            screenPosition.z = sprite.z;
                            size = sprite.size * sprite.scale / viewport.w;
                            scale.x = size * invAspect;
                            scale.y = size;
                            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                            gl.uniform2f(uniforms.scale, scale.x, scale.y);
                            gl.uniform1f(uniforms.rotation, sprite.rotation);
                            gl.uniform1f(uniforms.opacity, sprite.opacity);
                            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                            renderer.setTexture2D(sprite.texture, 1);
                            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                        }
                    }
                }
            }
            state.enable(gl.CULL_FACE);
            state.enable(gl.DEPTH_TEST);
            state.setDepthWrite(true);
            renderer.resetGLState();
        };
        function createProgram(shader) {
            var program = gl.createProgram();
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var prefix = "precision " + renderer.getPrecision() + " float;\n";
            gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
            gl.shaderSource(vertexShader, prefix + shader.vertexShader);
            gl.compileShader(fragmentShader);
            gl.compileShader(vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.linkProgram(program);
            return program;
        }
    }
    function SpritePlugin(renderer, sprites) {
        var gl = renderer.context;
        var state = renderer.state;
        var vertexBuffer, elementBuffer;
        var program, attributes, uniforms;
        var texture;
        var spritePosition = new Vector3();
        var spriteRotation = new Quaternion();
        var spriteScale = new Vector3();
        function init() {
            var vertices = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]);
            var faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            program = createProgram();
            attributes = {
                position: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            };
            uniforms = {
                uvOffset: gl.getUniformLocation(program, "uvOffset"),
                uvScale: gl.getUniformLocation(program, "uvScale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                scale: gl.getUniformLocation(program, "scale"),
                color: gl.getUniformLocation(program, "color"),
                map: gl.getUniformLocation(program, "map"),
                opacity: gl.getUniformLocation(program, "opacity"),
                modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                fogType: gl.getUniformLocation(program, "fogType"),
                fogDensity: gl.getUniformLocation(program, "fogDensity"),
                fogNear: gl.getUniformLocation(program, "fogNear"),
                fogFar: gl.getUniformLocation(program, "fogFar"),
                fogColor: gl.getUniformLocation(program, "fogColor"),
                alphaTest: gl.getUniformLocation(program, "alphaTest")
            };
            var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            canvas.width = 8;
            canvas.height = 8;
            var context = canvas.getContext("2d");
            context.fillStyle = "white";
            context.fillRect(0, 0, 8, 8);
            texture = new Texture(canvas);
            texture.needsUpdate = true;
        }
        this.render = function(scene, camera) {
            if (sprites.length === 0) return;
            if (program === undefined) {
                init();
            }
            gl.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.position);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            state.disable(gl.CULL_FACE);
            state.enable(gl.BLEND);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
            state.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniforms.map, 0);
            var oldFogType = 0;
            var sceneFogType = 0;
            var fog = scene.fog;
            if (fog) {
                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                if (fog.isFog) {
                    gl.uniform1f(uniforms.fogNear, fog.near);
                    gl.uniform1f(uniforms.fogFar, fog.far);
                    gl.uniform1i(uniforms.fogType, 1);
                    oldFogType = 1;
                    sceneFogType = 1;
                } else if (fog.isFogExp2) {
                    gl.uniform1f(uniforms.fogDensity, fog.density);
                    gl.uniform1i(uniforms.fogType, 2);
                    oldFogType = 2;
                    sceneFogType = 2;
                }
            } else {
                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
            }
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
            }
            sprites.sort(painterSortStable);
            var scale = [];
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                var material = sprite.material;
                if (material.visible === false) continue;
                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
                scale[0] = spriteScale.x;
                scale[1] = spriteScale.y;
                var fogType = 0;
                if (scene.fog && material.fog) {
                    fogType = sceneFogType;
                }
                if (oldFogType !== fogType) {
                    gl.uniform1i(uniforms.fogType, fogType);
                    oldFogType = fogType;
                }
                if (material.map !== null) {
                    gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                } else {
                    gl.uniform2f(uniforms.uvOffset, 0, 0);
                    gl.uniform2f(uniforms.uvScale, 1, 1);
                }
                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.scale, scale);
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
                state.setDepthTest(material.depthTest);
                state.setDepthWrite(material.depthWrite);
                if (material.map) {
                    renderer.setTexture2D(material.map, 0);
                } else {
                    renderer.setTexture2D(texture, 0);
                }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }
            state.enable(gl.CULL_FACE);
            renderer.resetGLState();
        };
        function createProgram() {
            var program = gl.createProgram();
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, [ "precision " + renderer.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}" ].join("\n"));
            gl.shaderSource(fragmentShader, [ "precision " + renderer.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}" ].join("\n"));
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }
        function painterSortStable(a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {
                return b.z - a.z;
            } else {
                return b.id - a.id;
            }
        }
    }
    function WebGLRenderTarget(width, height, options) {
        this.uuid = _Math.generateUUID();
        this.width = width;
        this.height = height;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        options = options || {};
        if (options.minFilter === undefined) options.minFilter = LinearFilter;
        this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    WebGLRenderTarget.prototype = {
        constructor: WebGLRenderTarget,
        isWebGLRenderTarget: true,
        setSize: function(width, height) {
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.width = source.width;
            this.height = source.height;
            this.viewport.copy(source.viewport);
            this.texture = source.texture.clone();
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype);
    var materialId = 0;
    function Material() {
        Object.defineProperty(this, "id", {
            value: materialId++
        });
        this.uuid = _Math.generateUUID();
        this.name = "";
        this.type = "Material";
        this.fog = true;
        this.lights = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.shading = SmoothShading;
        this.vertexColors = NoColors;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.overdraw = 0;
        this.visible = true;
        this._needsUpdate = true;
    }
    Material.prototype = {
        constructor: Material,
        isMaterial: true,
        get needsUpdate() {
            return this._needsUpdate;
        },
        set needsUpdate(value) {
            if (value === true) this.update();
            this._needsUpdate = value;
        },
        setValues: function(values) {
            if (values === undefined) return;
            for (var key in values) {
                var newValue = values[key];
                if (newValue === undefined) {
                    console.warn("SZX3D.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                var currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("SZX3D." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue && currentValue.isColor) {
                    currentValue.set(newValue);
                } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
                    currentValue.copy(newValue);
                } else if (key === "overdraw") {
                    this[key] = Number(newValue);
                } else {
                    this[key] = newValue;
                }
            }
        },
        toJSON: function(meta) {
            var isRoot = meta === undefined;
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {}
                };
            }
            var data = {
                metadata: {
                    version: 4.4,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== "") data.name = this.name;
            if (this.color && this.color.isColor) data.color = this.color.getHex();
            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;
            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
            if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;
            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
            }
            if (this.gradientMap && this.gradientMap.isTexture) {
                data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            }
            if (this.size !== undefined) data.size = this.size;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.shading !== SmoothShading) data.shading = this.shading;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = this.transparent;
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true) data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
            data.skinning = this.skinning;
            data.morphTargets = this.morphTargets;
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name;
            this.fog = source.fog;
            this.lights = source.lights;
            this.blending = source.blending;
            this.side = source.side;
            this.shading = source.shading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.overdraw = source.overdraw;
            this.visible = source.visible;
            this.clipShadows = source.clipShadows;
            this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes, dstPlanes = null;
            if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
            }
            this.clippingPlanes = dstPlanes;
            return this;
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            });
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    };
    Object.assign(Material.prototype, EventDispatcher.prototype);
    function ShaderMaterial(parameters) {
        Material.call(this);
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
            color: [ 1, 1, 1 ],
            uv: [ 0, 0 ],
            uv2: [ 0, 0 ]
        };
        this.index0AttributeName = undefined;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) {
                console.error("SZX3D.ShaderMaterial: attributes should now be defined in SZX3D.BufferGeometry instead.");
            }
            this.setValues(parameters);
        }
    }
    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    ShaderMaterial.prototype.isShaderMaterial = true;
    ShaderMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = UniformsUtils.clone(source.uniforms);
        this.defines = source.defines;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = source.extensions;
        return this;
    };
    ShaderMaterial.prototype.toJSON = function(meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        data.uniforms = this.uniforms;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        return data;
    };
    function MeshDepthMaterial(parameters) {
        Material.call(this);
        this.type = "MeshDepthMaterial";
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };
    function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
        var _gl = _renderer.context, _state = _renderer.state, _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _lightShadows = _lights.shadows, _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _renderList = [], _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
        var cubeDirections = [ new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0) ];
        var cubeUps = [ new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1) ];
        var cube2DViewPorts = [ new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4() ];
        var depthMaterialTemplate = new MeshDepthMaterial();
        depthMaterialTemplate.depthPacking = RGBADepthPacking;
        depthMaterialTemplate.clipping = true;
        var distanceShader = ShaderLib["distanceRGBA"];
        var distanceUniforms = UniformsUtils.clone(distanceShader.uniforms);
        for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
            var useMorphing = (i & _MorphingFlag) !== 0;
            var useSkinning = (i & _SkinningFlag) !== 0;
            var depthMaterial = depthMaterialTemplate.clone();
            depthMaterial.morphTargets = useMorphing;
            depthMaterial.skinning = useSkinning;
            _depthMaterials[i] = depthMaterial;
            var distanceMaterial = new ShaderMaterial({
                defines: {
                    USE_SHADOWMAP: ""
                },
                uniforms: distanceUniforms,
                vertexShader: distanceShader.vertexShader,
                fragmentShader: distanceShader.fragmentShader,
                morphTargets: useMorphing,
                skinning: useSkinning,
                clipping: true
            });
            _distanceMaterials[i] = distanceMaterial;
        }
        var scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.renderReverseSided = true;
        this.renderSingleSided = true;
        this.render = function(scene, camera) {
            if (scope.enabled === false) return;
            if (scope.autoUpdate === false && scope.needsUpdate === false) return;
            if (_lightShadows.length === 0) return;
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.disable(_gl.BLEND);
            _state.setDepthTest(true);
            _state.setScissorTest(false);
            var faceCount, isPointLight;
            for (var i = 0, il = _lightShadows.length; i < il; i++) {
                var light = _lightShadows[i];
                var shadow = light.shadow;
                if (shadow === undefined) {
                    console.warn("SZX3D.WebGLShadowMap:", light, "has no shadow.");
                    continue;
                }
                var shadowCamera = shadow.camera;
                _shadowMapSize.copy(shadow.mapSize);
                _shadowMapSize.min(_maxShadowMapSize);
                if (light && light.isPointLight) {
                    faceCount = 6;
                    isPointLight = true;
                    var vpWidth = _shadowMapSize.x;
                    var vpHeight = _shadowMapSize.y;
                    cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                    cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                    _shadowMapSize.x *= 4;
                    _shadowMapSize.y *= 2;
                } else {
                    faceCount = 1;
                    isPointLight = false;
                }
                if (shadow.map === null) {
                    var pars = {
                        minFilter: NearestFilter,
                        magFilter: NearestFilter,
                        format: RGBAFormat
                    };
                    shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadowCamera.updateProjectionMatrix();
                }
                if (shadow.isSpotLightShadow) {
                    shadow.update(light);
                }
                if (shadow && shadow.isRectAreaLightShadow) {
                    shadow.update(light);
                }
                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;
                _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(_lightPositionWorld);
                _renderer.setRenderTarget(shadowMap);
                _renderer.clear();
                for (var face = 0; face < faceCount; face++) {
                    if (isPointLight) {
                        _lookTarget.copy(shadowCamera.position);
                        _lookTarget.add(cubeDirections[face]);
                        shadowCamera.up.copy(cubeUps[face]);
                        shadowCamera.lookAt(_lookTarget);
                        var vpDimensions = cube2DViewPorts[face];
                        _state.viewport(vpDimensions);
                    } else {
                        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                        shadowCamera.lookAt(_lookTarget);
                    }
                    shadowCamera.updateMatrixWorld();
                    shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
                    shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    _frustum.setFromMatrix(_projScreenMatrix);
                    _renderList.length = 0;
                    projectObject(scene, camera, shadowCamera);
                    for (var j = 0, jl = _renderList.length; j < jl; j++) {
                        var object = _renderList[j];
                        var geometry = _objects.update(object);
                        var material = object.material;
                        if (material && material.isMultiMaterial) {
                            var groups = geometry.groups;
                            var materials = material.materials;
                            for (var k = 0, kl = groups.length; k < kl; k++) {
                                var group = groups[k];
                                var groupMaterial = materials[group.materialIndex];
                                if (groupMaterial.visible === true) {
                                    var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                                }
                            }
                        } else {
                            var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                        }
                    }
                }
            }
            var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
            _renderer.setClearColor(clearColor, clearAlpha);
            scope.needsUpdate = false;
        };
        function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
            var geometry = object.geometry;
            var result = null;
            var materialVariants = _depthMaterials;
            var customMaterial = object.customDepthMaterial;
            if (isPointLight) {
                materialVariants = _distanceMaterials;
                customMaterial = object.customDistanceMaterial;
            }
            if (!customMaterial) {
                var useMorphing = false;
                if (material.morphTargets) {
                    if (geometry && geometry.isBufferGeometry) {
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    } else if (geometry && geometry.isGeometry) {
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }
                var useSkinning = object.isSkinnedMesh && material.skinning;
                var variantIndex = 0;
                if (useMorphing) variantIndex |= _MorphingFlag;
                if (useSkinning) variantIndex |= _SkinningFlag;
                result = materialVariants[variantIndex];
            } else {
                result = customMaterial;
            }
            if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                var keyA = result.uuid, keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {};
                    _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            var side = material.side;
            if (scope.renderSingleSided && side == DoubleSide) {
                side = FrontSide;
            }
            if (scope.renderReverseSided) {
                if (side === FrontSide) side = BackSide; else if (side === BackSide) side = FrontSide;
            }
            result.side = side;
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (isPointLight && result.uniforms.lightPos !== undefined) {
                result.uniforms.lightPos.value.copy(lightPositionWorld);
            }
            return result;
        }
        function projectObject(object, camera, shadowCamera) {
            if (object.visible === false) return;
            var visible = (object.layers.mask & camera.layers.mask) !== 0;
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
                    var material = object.material;
                    if (material.visible === true) {
                        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                        _renderList.push(object);
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                projectObject(children[i], camera, shadowCamera);
            }
        }
    }
    function MeshBasicMaterial(parameters) {
        Material.call(this);
        this.type = "MeshBasicMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.skinning = false;
        this.morphTargets = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    };
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.type = "Mesh";
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial({
            color: Math.random() * 16777215
        });
        this.drawMode = TrianglesDrawMode;
        this.updateMorphTargets();
    }
    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: true,
        setDrawMode: function(value) {
            this.drawMode = value;
        },
        copy: function(source) {
            Object3D.prototype.copy.call(this, source);
            this.drawMode = source.drawMode;
            return this;
        },
        updateMorphTargets: function() {
            var morphTargets = this.geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for (var m = 0, ml = morphTargets.length; m < ml; m++) {
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[morphTargets[m].name] = m;
                }
            }
        },
        raycast: function() {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            var vA = new Vector3();
            var vB = new Vector3();
            var vC = new Vector3();
            var tempA = new Vector3();
            var tempB = new Vector3();
            var tempC = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            var barycoord = new Vector3();
            var intersectionPoint = new Vector3();
            var intersectionPointWorld = new Vector3();
            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
                uv1.multiplyScalar(barycoord.x);
                uv2.multiplyScalar(barycoord.y);
                uv3.multiplyScalar(barycoord.z);
                uv1.add(uv2).add(uv3);
                return uv1.clone();
            }
            function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
                var intersect;
                var material = object.material;
                if (material.side === BackSide) {
                    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
                } else {
                    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
                }
                if (intersect === null) return null;
                intersectionPointWorld.copy(point);
                intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                if (distance < raycaster.near || distance > raycaster.far) return null;
                return {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }
            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                vA.fromBufferAttribute(position, a);
                vB.fromBufferAttribute(position, b);
                vC.fromBufferAttribute(position, c);
                var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
                if (intersection) {
                    if (uv) {
                        uvA.fromBufferAttribute(uv, a);
                        uvB.fromBufferAttribute(uv, b);
                        uvC.fromBufferAttribute(uv, c);
                        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                    }
                    intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                    intersection.faceIndex = a;
                }
                return intersection;
            }
            return function raycast(raycaster, intersects) {
                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;
                if (material === undefined) return;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false) return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                if (geometry.boundingBox !== null) {
                    if (ray.intersectsBox(geometry.boundingBox) === false) return;
                }
                var intersection;
                if (geometry.isBufferGeometry) {
                    var a, b, c;
                    var index = geometry.index;
                    var position = geometry.attributes.position;
                    var uv = geometry.attributes.uv;
                    var i, l;
                    if (index !== null) {
                        for (i = 0, l = index.count; i < l; i += 3) {
                            a = index.getX(i);
                            b = index.getX(i + 1);
                            c = index.getX(i + 2);
                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(i / 3);
                                intersects.push(intersection);
                            }
                        }
                    } else {
                        for (i = 0, l = position.count; i < l; i += 3) {
                            a = i;
                            b = i + 1;
                            c = i + 2;
                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.index = a;
                                intersects.push(intersection);
                            }
                        }
                    }
                } else if (geometry.isGeometry) {
                    var fvA, fvB, fvC;
                    var isFaceMaterial = material && material.isMultiMaterial;
                    var materials = isFaceMaterial === true ? material.materials : null;
                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var uvs;
                    var faceVertexUvs = geometry.faceVertexUvs[0];
                    if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
                    for (var f = 0, fl = faces.length; f < fl; f++) {
                        var face = faces[f];
                        var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
                        if (faceMaterial === undefined) continue;
                        fvA = vertices[face.a];
                        fvB = vertices[face.b];
                        fvC = vertices[face.c];
                        if (faceMaterial.morphTargets === true) {
                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = this.morphTargetInfluences;
                            vA.set(0, 0, 0);
                            vB.set(0, 0, 0);
                            vC.set(0, 0, 0);
                            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                var influence = morphInfluences[t];
                                if (influence === 0) continue;
                                var targets = morphTargets[t].vertices;
                                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                            }
                            vA.add(fvA);
                            vB.add(fvB);
                            vC.add(fvC);
                            fvA = vA;
                            fvB = vB;
                            fvC = vC;
                        }
                        intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                        if (intersection) {
                            if (uvs) {
                                var uvs_f = uvs[f];
                                uvA.copy(uvs_f[0]);
                                uvB.copy(uvs_f[1]);
                                uvC.copy(uvs_f[2]);
                                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                            }
                            intersection.face = face;
                            intersection.faceIndex = f;
                            intersects.push(intersection);
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function Camera() {
        Object3D.call(this);
        this.type = "Camera";
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
    }
    Camera.prototype = Object.create(Object3D.prototype);
    Camera.prototype.constructor = Camera;
    Camera.prototype.isCamera = true;
    Camera.prototype.getWorldDirection = function() {
        var quaternion = new Quaternion();
        return function getWorldDirection(optionalTarget) {
            var result = optionalTarget || new Vector3();
            this.getWorldQuaternion(quaternion);
            return result.set(0, 0, -1).applyQuaternion(quaternion);
        };
    }();
    Camera.prototype.lookAt = function() {
        var m1 = new Matrix4();
        return function lookAt(vector) {
            m1.lookAt(this.position, vector, this.up);
            this.quaternion.setFromRotationMatrix(m1);
        };
    }();
    Camera.prototype.clone = function() {
        return new this.constructor().copy(this);
    };
    Camera.prototype.copy = function(source) {
        Object3D.prototype.copy.call(this, source);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        return this;
    };
    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this);
        this.type = "PerspectiveCamera";
        this.fov = fov !== undefined ? fov : 50;
        this.zoom = 1;
        this.near = near !== undefined ? near : .1;
        this.far = far !== undefined ? far : 2e3;
        this.focus = 10;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
    }
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: true,
        copy: function(source) {
            Camera.prototype.copy.call(this, source);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        },
        setFocalLength: function(focalLength) {
            var vExtentSlope = .5 * this.getFilmHeight() / focalLength;
            this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        },
        getFocalLength: function() {
            var vExtentSlope = Math.tan(_Math.DEG2RAD * .5 * this.fov);
            return .5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function() {
            return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * .5 * this.fov) / this.zoom);
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            };
            this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            this.view = null;
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var near = this.near, top = near * Math.tan(_Math.DEG2RAD * .5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -.5 * width, view = this.view;
            if (view !== null) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0) left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null) data.object.view = Object.assign({}, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        }
    });
    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this);
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near !== undefined ? near : .1;
        this.far = far !== undefined ? far : 2e3;
        this.updateProjectionMatrix();
    }
    OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: true,
        copy: function(source) {
            Camera.prototype.copy.call(this, source);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            return this;
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            };
            this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            this.view = null;
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if (this.view !== null) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null) data.object.view = Object.assign({}, this.view);
            return data;
        }
    });
    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
        var mode;
        function setMode(value) {
            mode = value;
        }
        var type, size;
        function setIndex(index) {
            if (index.array instanceof Uint32Array && extensions.get("OES_element_index_uint")) {
                type = gl.UNSIGNED_INT;
                size = 4;
            } else if (index.array instanceof Uint16Array) {
                type = gl.UNSIGNED_SHORT;
                size = 2;
            } else {
                type = gl.UNSIGNED_BYTE;
                size = 1;
            }
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * size);
            infoRender.calls++;
            infoRender.vertices += count;
            if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (extension === null) {
                console.error("SZX3D.WebGLBufferRenderer: using SZX3D.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
            extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);
            infoRender.calls++;
            infoRender.vertices += count * geometry.maxInstancedCount;
            if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
        }
        return {
            setMode: setMode,
            setIndex: setIndex,
            render: render,
            renderInstances: renderInstances
        };
    }
    function WebGLBufferRenderer(gl, extensions, infoRender) {
        var mode;
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count);
            infoRender.calls++;
            infoRender.vertices += count;
            if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
        }
        function renderInstances(geometry) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (extension === null) {
                console.error("SZX3D.WebGLBufferRenderer: using SZX3D.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
            var position = geometry.attributes.position;
            var count = 0;
            if (position.isInterleavedBufferAttribute) {
                count = position.data.count;
                extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
            } else {
                count = position.count;
                extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
            }
            infoRender.calls++;
            infoRender.vertices += count * geometry.maxInstancedCount;
            if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
        }
        return {
            setMode: setMode,
            render: render,
            renderInstances: renderInstances
        };
    }
    function WebGLLights() {
        var lights = {};
        return {
            get: function(light) {
                if (lights[light.id] !== undefined) {
                    return lights[light.id];
                }
                var uniforms;
                switch (light.type) {
                  case "DirectionalLight":
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color(),
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "SpotLight":
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "PointLight":
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "HemisphereLight":
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;

                  case "RectAreaLight":
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                    break;
                }
                lights[light.id] = uniforms;
                return uniforms;
            }
        };
    }
    function addLineNumbers(string) {
        var lines = string.split("\n");
        for (var i = 0; i < lines.length; i++) {
            lines[i] = i + 1 + ": " + lines[i];
        }
        return lines.join("\n");
    }
    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            console.error("SZX3D.WebGLShader: Shader couldn't compile.");
        }
        if (gl.getShaderInfoLog(shader) !== "") {
            console.warn("SZX3D.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
    }
    var programIdCount = 0;
    function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return [ "Linear", "( value )" ];

          case sRGBEncoding:
            return [ "sRGB", "( value )" ];

          case RGBEEncoding:
            return [ "RGBE", "( value )" ];

          case RGBM7Encoding:
            return [ "RGBM", "( value, 7.0 )" ];

          case RGBM16Encoding:
            return [ "RGBM", "( value, 16.0 )" ];

          case RGBDEncoding:
            return [ "RGBD", "( value, 256.0 )" ];

          case GammaEncoding:
            return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

          default:
            throw new Error("unsupported encoding: " + encoding);
        }
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;

          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;

          case Uncharted2ToneMapping:
            toneMappingName = "Uncharted2";
            break;

          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;

          default:
            throw new Error("unsupported toneMapping: " + toneMapping);
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
        extensions = extensions || {};
        var chunks = [ extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "" ];
        return chunks.filter(filterEmptyLine).join("\n");
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            if (value === false) continue;
            chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
    }
    function fetchAttributeLocations(gl, program, identifiers) {
        var attributes = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i);
            var name = info.name;
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return string !== "";
    }
    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }
    function parseIncludes(string) {
        var pattern = /#include +<([\w\d.]+)>/g;
        function replace(match, include) {
            var replace = ShaderChunk[include];
            if (replace === undefined) {
                throw new Error("Can not resolve #include <" + include + ">");
            }
            return parseIncludes(replace);
        }
        return string.replace(pattern, replace);
    }
    function unrollLoops(string) {
        var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function replace(match, start, end, snippet) {
            var unroll = "";
            for (var i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
            }
            return unroll;
        }
        return string.replace(pattern, replace);
    }
    function WebGLProgram(renderer, code, material, parameters) {
        var gl = renderer.context;
        var extensions = material.extensions;
        var defines = material.defines;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        if (parameters.shadowMapType === PCFShadowMap) {
            shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {
            shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
        }
        var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
        var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
              case CubeReflectionMapping:
              case CubeRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;

              case CubeUVReflectionMapping:
              case CubeUVRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                break;

              case EquirectangularReflectionMapping:
              case EquirectangularRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                break;

              case SphericalReflectionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
                break;
            }
            switch (material.envMap.mapping) {
              case CubeRefractionMapping:
              case EquirectangularRefractionMapping:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                break;
            }
            switch (material.combine) {
              case MultiplyOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case MixOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;

              case AddOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                break;
            }
        }
        var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
        var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex, prefixFragment;
        if (material.isRawShaderMaterial) {
            prefixVertex = [ customDefines, "\n" ].filter(filterEmptyLine).join("\n");
            prefixFragment = [ customExtensions, customDefines, "\n" ].filter(filterEmptyLine).join("\n");
        } else {
            prefixVertex = [ "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n" ].filter(filterEmptyLine).join("\n");
            prefixFragment = [ customExtensions, "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + material.__webglShader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (parameters.numClippingPlanes - parameters.numClipIntersection), parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", parameters.envMap && renderer.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "", "\n" ].filter(filterEmptyLine).join("\n");
        }
        vertexShader = parseIncludes(vertexShader, parameters);
        vertexShader = replaceLightNums(vertexShader, parameters);
        fragmentShader = parseIncludes(fragmentShader, parameters);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        if (!material.isShaderMaterial) {
            vertexShader = unrollLoops(vertexShader);
            fragmentShader = unrollLoops(fragmentShader);
        }
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (material.index0AttributeName !== undefined) {
            gl.bindAttribLocation(program, 0, material.index0AttributeName);
        } else if (parameters.morphTargets === true) {
            gl.bindAttribLocation(program, 0, "position");
        }
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program);
        var vertexLog = gl.getShaderInfoLog(glVertexShader);
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            console.error("SZX3D.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
        } else if (programLog !== "") {
            console.warn("SZX3D.WebGLProgram: gl.getProgramInfoLog()", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
            haveDiagnostics = false;
        }
        if (haveDiagnostics) {
            this.diagnostics = {
                runnable: runnable,
                material: material,
                programLog: programLog,
                vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                },
                fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                }
            };
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
            if (cachedUniforms === undefined) {
                cachedUniforms = new WebGLUniforms(gl, program, renderer);
            }
            return cachedUniforms;
        };
        var cachedAttributes;
        this.getAttributes = function() {
            if (cachedAttributes === undefined) {
                cachedAttributes = fetchAttributeLocations(gl, program);
            }
            return cachedAttributes;
        };
        this.destroy = function() {
            gl.deleteProgram(program);
            this.program = undefined;
        };
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    console.warn("SZX3D.WebGLProgram: .uniforms is now .getUniforms().");
                    return this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    console.warn("SZX3D.WebGLProgram: .attributes is now .getAttributes().");
                    return this.getAttributes();
                }
            }
        });
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
    }
    function WebGLPrograms(renderer, capabilities) {
        var programs = [];
        var shaderIDs = {
            MeshDepthMaterial: "depth",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points"
        };
        var parameterNames = [ "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking" ];
        function allocateBones(object) {
            if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
                return 1024;
            } else {
                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = nVertexMatrices;
                if (object !== undefined && (object && object.isSkinnedMesh)) {
                    maxBones = Math.min(object.skeleton.bones.length, maxBones);
                    if (maxBones < object.skeleton.bones.length) {
                        console.warn("WebGLRenderer: too many bones - " + object.skeleton.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)");
                    }
                }
                return maxBones;
            }
        }
        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            if (!map) {
                encoding = LinearEncoding;
            } else if (map.isTexture) {
                encoding = map.encoding;
            } else if (map.isWebGLRenderTarget) {
                console.warn("SZX3D.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            if (encoding === LinearEncoding && gammaOverrideLinear) {
                encoding = GammaEncoding;
            }
            return encoding;
        }
        this.getParameters = function(material, lights, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = shaderIDs[material.type];
            var maxBones = allocateBones(object);
            var precision = renderer.getPrecision();
            if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                    console.warn("SZX3D.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
                }
            }
            var currentRenderTarget = renderer.getCurrentRenderTarget();
            var parameters = {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: fog && fog.isFogExp2,
                flatShading: material.shading === FlatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
            };
            return parameters;
        };
        this.getProgramCode = function(material, parameters) {
            var array = [];
            if (parameters.shaderID) {
                array.push(parameters.shaderID);
            } else {
                array.push(material.fragmentShader);
                array.push(material.vertexShader);
            }
            if (material.defines !== undefined) {
                for (var name in material.defines) {
                    array.push(name);
                    array.push(material.defines[name]);
                }
            }
            for (var i = 0; i < parameterNames.length; i++) {
                array.push(parameters[parameterNames[i]]);
            }
            return array.join();
        };
        this.acquireProgram = function(material, parameters, code) {
            var program;
            for (var p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new WebGLProgram(renderer, code, material, parameters);
                programs.push(program);
            }
            return program;
        };
        this.releaseProgram = function(program) {
            if (--program.usedTimes === 0) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();
                program.destroy();
            }
        };
        this.programs = programs;
    }
    function WebGLGeometries(gl, properties, info) {
        var geometries = {};
        function onGeometryDispose(event) {
            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry.index !== null) {
                deleteAttribute(buffergeometry.index);
            }
            deleteAttributes(buffergeometry.attributes);
            geometry.removeEventListener("dispose", onGeometryDispose);
            delete geometries[geometry.id];
            var property = properties.get(geometry);
            if (property.wireframe) {
                deleteAttribute(property.wireframe);
            }
            properties.delete(geometry);
            var bufferproperty = properties.get(buffergeometry);
            if (bufferproperty.wireframe) {
                deleteAttribute(bufferproperty.wireframe);
            }
            properties.delete(buffergeometry);
            info.memory.geometries--;
        }
        function getAttributeBuffer(attribute) {
            if (attribute.isInterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
            }
            return properties.get(attribute).__webglBuffer;
        }
        function deleteAttribute(attribute) {
            var buffer = getAttributeBuffer(attribute);
            if (buffer !== undefined) {
                gl.deleteBuffer(buffer);
                removeAttributeBuffer(attribute);
            }
        }
        function deleteAttributes(attributes) {
            for (var name in attributes) {
                deleteAttribute(attributes[name]);
            }
        }
        function removeAttributeBuffer(attribute) {
            if (attribute.isInterleavedBufferAttribute) {
                properties.delete(attribute.data);
            } else {
                properties.delete(attribute);
            }
        }
        return {
            get: function(object) {
                var geometry = object.geometry;
                if (geometries[geometry.id] !== undefined) {
                    return geometries[geometry.id];
                }
                geometry.addEventListener("dispose", onGeometryDispose);
                var buffergeometry;
                if (geometry.isBufferGeometry) {
                    buffergeometry = geometry;
                } else if (geometry.isGeometry) {
                    if (geometry._bufferGeometry === undefined) {
                        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                    }
                    buffergeometry = geometry._bufferGeometry;
                }
                geometries[geometry.id] = buffergeometry;
                info.memory.geometries++;
                return buffergeometry;
            }
        };
    }
    function WebGLObjects(gl, properties, info) {
        var geometries = new WebGLGeometries(gl, properties, info);
        function update(object) {
            var geometry = geometries.get(object);
            if (object.geometry.isGeometry) {
                geometry.updateFromObject(object);
            }
            var index = geometry.index;
            var attributes = geometry.attributes;
            if (index !== null) {
                updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
            }
            for (var name in attributes) {
                updateAttribute(attributes[name], gl.ARRAY_BUFFER);
            }
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                    updateAttribute(array[i], gl.ARRAY_BUFFER);
                }
            }
            return geometry;
        }
        function updateAttribute(attribute, bufferType) {
            var data = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
            var attributeProperties = properties.get(data);
            if (attributeProperties.__webglBuffer === undefined) {
                createBuffer(attributeProperties, data, bufferType);
            } else if (attributeProperties.version !== data.version) {
                updateBuffer(attributeProperties, data, bufferType);
            }
        }
        function createBuffer(attributeProperties, data, bufferType) {
            attributeProperties.__webglBuffer = gl.createBuffer();
            gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
            var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            gl.bufferData(bufferType, data.array, usage);
            var type = gl.FLOAT;
            var array = data.array;
            if (array instanceof Float32Array) {
                type = gl.FLOAT;
            } else if (array instanceof Float64Array) {
                console.warn("Unsupported data buffer format: Float64Array");
            } else if (array instanceof Uint16Array) {
                type = gl.UNSIGNED_SHORT;
            } else if (array instanceof Int16Array) {
                type = gl.SHORT;
            } else if (array instanceof Uint32Array) {
                type = gl.UNSIGNED_INT;
            } else if (array instanceof Int32Array) {
                type = gl.INT;
            } else if (array instanceof Int8Array) {
                type = gl.BYTE;
            } else if (array instanceof Uint8Array) {
                type = gl.UNSIGNED_BYTE;
            }
            attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;
            attributeProperties.type = type;
            attributeProperties.version = data.version;
            data.onUploadCallback();
        }
        function updateBuffer(attributeProperties, data, bufferType) {
            gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
            if (data.dynamic === false) {
                gl.bufferData(bufferType, data.array, gl.STATIC_DRAW);
            } else if (data.updateRange.count === -1) {
                gl.bufferSubData(bufferType, 0, data.array);
            } else if (data.updateRange.count === 0) {
                console.error("SZX3D.WebGLObjects.updateBuffer: dynamic SZX3D.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
            } else {
                gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
                data.updateRange.count = 0;
            }
            attributeProperties.version = data.version;
        }
        function getAttributeBuffer(attribute) {
            if (attribute.isInterleavedBufferAttribute) {
                return properties.get(attribute.data).__webglBuffer;
            }
            return properties.get(attribute).__webglBuffer;
        }
        function getAttributeProperties(attribute) {
            if (attribute.isInterleavedBufferAttribute) {
                return properties.get(attribute.data);
            }
            return properties.get(attribute);
        }
        function getWireframeAttribute(geometry) {
            var property = properties.get(geometry);
            if (property.wireframe !== undefined) {
                return property.wireframe;
            }
            var indices = [];
            var index = geometry.index;
            var attributes = geometry.attributes;
            if (index !== null) {
                var array = index.array;
                for (var i = 0, l = array.length; i < l; i += 3) {
                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];
                    indices.push(a, b, b, c, c, a);
                }
            } else {
                var array = attributes.position.array;
                for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
                    indices.push(a, b, b, c, c, a);
                }
            }
            var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
            updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
            property.wireframe = attribute;
            return attribute;
        }
        return {
            getAttributeBuffer: getAttributeBuffer,
            getAttributeProperties: getAttributeProperties,
            getWireframeAttribute: getWireframeAttribute,
            update: update
        };
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
        var _infoMemory = info.memory;
        var _isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && _gl instanceof WebGL2RenderingContext;
        function clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / Math.max(image.width, image.height);
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = Math.floor(image.width * scale);
                canvas.height = Math.floor(image.height * scale);
                var context = canvas.getContext("2d");
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                console.warn("SZX3D.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
                return canvas;
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }
        function makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = _Math.nearestPowerOfTwo(image.width);
                canvas.height = _Math.nearestPowerOfTwo(image.height);
                var context = canvas.getContext("2d");
                context.drawImage(image, 0, 0, canvas.width, canvas.height);
                console.warn("SZX3D.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image);
                return canvas;
            }
            return image;
        }
        function textureNeedsPowerOfTwo(texture) {
            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function filterFallback(f) {
            if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
                return _gl.NEAREST;
            }
            return _gl.LINEAR;
        }
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener("dispose", onTextureDispose);
            deallocateTexture(texture);
            _infoMemory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener("dispose", onRenderTargetDispose);
            deallocateRenderTarget(renderTarget);
            _infoMemory.textures--;
        }
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) {
                _gl.deleteTexture(textureProperties.__image__webglTextureCube);
            } else {
                if (textureProperties.__webglInit === undefined) return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties.delete(texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            if (!renderTarget) return;
            if (textureProperties.__webglTexture !== undefined) {
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
            }
            if (renderTarget.isWebGLRenderTargetCube) {
                for (var i = 0; i < 6; i++) {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            } else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            properties.delete(renderTarget.texture);
            properties.delete(renderTarget);
        }
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) {
                    console.warn("SZX3D.WebGLRenderer: Texture marked for update but image is undefined", texture);
                } else if (image.complete === false) {
                    console.warn("SZX3D.WebGLRenderer: Texture marked for update but image is incomplete", texture);
                } else {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.image.length === 6) {
                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    if (!textureProperties.__image__webglTextureCube) {
                        texture.addEventListener("dispose", onTextureDispose);
                        textureProperties.__image__webglTextureCube = _gl.createTexture();
                        _infoMemory.textures++;
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                    var isCompressed = texture && texture.isCompressedTexture;
                    var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
                    var cubeImage = [];
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed && !isDataTexture) {
                            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                        } else {
                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }
                    var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed) {
                            if (isDataTexture) {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            } else {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            }
                        } else {
                            var mipmap, mipmaps = cubeImage[i].mipmaps;
                            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                                mipmap = mipmaps[j];
                                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    } else {
                                        console.warn("SZX3D.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                                    }
                                } else {
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }
                    }
                    if (texture.generateMipmaps && isPowerOfTwoImage) {
                        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                    }
                    textureProperties.__version = texture.version;
                    if (texture.onUpdate) texture.onUpdate(texture);
                } else {
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
            }
        }
        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }
        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
            } else {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                    console.warn("SZX3D.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to SZX3D.ClampToEdgeWrapping.", texture);
                }
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                    console.warn("SZX3D.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to SZX3D.NearestFilter or SZX3D.LinearFilter.", texture);
                }
            }
            extension = extensions.get("EXT_texture_filter_anisotropic");
            if (extension) {
                if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null) return;
                if (texture.type === HalfFloatType && extensions.get("OES_texture_half_float_linear") === null) return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener("dispose", onTextureDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                _infoMemory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
            if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
                image = makePowerOfTwo(image);
            }
            var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                    if (!_isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (_isWebGL2) {
                    internalFormat = _gl.DEPTH_COMPONENT16;
                }
                if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {
                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                        console.warn("SZX3D.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                        texture.type = UnsignedShortType;
                        glType = paramThreeToGL(texture.type);
                    }
                }
                if (texture.format === DepthStencilFormat) {
                    internalFormat = _gl.DEPTH_STENCIL;
                    if (texture.type !== UnsignedInt248Type) {
                        console.warn("SZX3D.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                        texture.type = UnsignedInt248Type;
                        glType = paramThreeToGL(texture.type);
                    }
                }
                state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                }
            } else if (texture.isCompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        } else {
                            console.warn("SZX3D.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        }
                    } else {
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
            } else {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                }
            }
            if (texture.generateMipmaps && isPowerOfTwoImage) _gl.generateMipmap(_gl.TEXTURE_2D);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = paramThreeToGL(renderTarget.texture.format);
            var glType = paramThreeToGL(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
            }
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            if (isCube) throw new Error("Depth Texture with cube render targets is not supported!");
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                throw new Error("renderTarget.depthTexture must be an instance of SZX3D.DepthTexture");
            }
            if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else {
                throw new Error("Unknown depthTexture format");
            }
        }
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = renderTarget.isWebGLRenderTargetCube === true;
            if (renderTarget.depthTexture) {
                if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else {
                if (isCube) {
                    renderTargetProperties.__webglDepthbuffer = [];
                    for (var i = 0; i < 6; i++) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                } else {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener("dispose", onRenderTargetDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            _infoMemory.textures++;
            var isCube = renderTarget.isWebGLRenderTargetCube === true;
            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
            } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            }
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }
                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else {
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);
                state.bindTexture(_gl.TEXTURE_2D, null);
            }
            if (renderTarget.depthBuffer) {
                setupDepthRenderbuffer(renderTarget);
            }
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                var target = renderTarget && renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                _gl.generateMipmap(target);
                state.bindTexture(target, null);
            }
        }
        this.setTexture2D = setTexture2D;
        this.setTextureCube = setTextureCube;
        this.setTextureCubeDynamic = setTextureCubeDynamic;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    }
    function WebGLProperties() {
        var properties = {};
        return {
            get: function(object) {
                var uuid = object.uuid;
                var map = properties[uuid];
                if (map === undefined) {
                    map = {};
                    properties[uuid] = map;
                }
                return map;
            },
            delete: function(object) {
                delete properties[object.uuid];
            },
            clear: function() {
                properties = {};
            }
        };
    }
    function WebGLState(gl, extensions, paramThreeToGL) {
        function ColorBuffer() {
            var locked = false;
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4();
            return {
                setMask: function(colorMask) {
                    if (currentColorMask !== colorMask && !locked) {
                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                        currentColorMask = colorMask;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(r, g, b, a, premultipliedAlpha) {
                    if (premultipliedAlpha === true) {
                        r *= a;
                        g *= a;
                        b *= a;
                    }
                    color.set(r, g, b, a);
                    if (currentColorClear.equals(color) === false) {
                        gl.clearColor(r, g, b, a);
                        currentColorClear.copy(color);
                    }
                },
                reset: function() {
                    locked = false;
                    currentColorMask = null;
                    currentColorClear.set(0, 0, 0, 1);
                }
            };
        }
        function DepthBuffer() {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
                setTest: function(depthTest) {
                    if (depthTest) {
                        enable(gl.DEPTH_TEST);
                    } else {
                        disable(gl.DEPTH_TEST);
                    }
                },
                setMask: function(depthMask) {
                    if (currentDepthMask !== depthMask && !locked) {
                        gl.depthMask(depthMask);
                        currentDepthMask = depthMask;
                    }
                },
                setFunc: function(depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) {
                            switch (depthFunc) {
                              case NeverDepth:
                                gl.depthFunc(gl.NEVER);
                                break;

                              case AlwaysDepth:
                                gl.depthFunc(gl.ALWAYS);
                                break;

                              case LessDepth:
                                gl.depthFunc(gl.LESS);
                                break;

                              case LessEqualDepth:
                                gl.depthFunc(gl.LEQUAL);
                                break;

                              case EqualDepth:
                                gl.depthFunc(gl.EQUAL);
                                break;

                              case GreaterEqualDepth:
                                gl.depthFunc(gl.GEQUAL);
                                break;

                              case GreaterDepth:
                                gl.depthFunc(gl.GREATER);
                                break;

                              case NotEqualDepth:
                                gl.depthFunc(gl.NOTEQUAL);
                                break;

                              default:
                                gl.depthFunc(gl.LEQUAL);
                            }
                        } else {
                            gl.depthFunc(gl.LEQUAL);
                        }
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(depth) {
                    if (currentDepthClear !== depth) {
                        gl.clearDepth(depth);
                        currentDepthClear = depth;
                    }
                },
                reset: function() {
                    locked = false;
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
                setTest: function(stencilTest) {
                    if (stencilTest) {
                        enable(gl.STENCIL_TEST);
                    } else {
                        disable(gl.STENCIL_TEST);
                    }
                },
                setMask: function(stencilMask) {
                    if (currentStencilMask !== stencilMask && !locked) {
                        gl.stencilMask(stencilMask);
                        currentStencilMask = stencilMask;
                    }
                },
                setFunc: function(stencilFunc, stencilRef, stencilMask) {
                    if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },
                setOp: function(stencilFail, stencilZFail, stencilZPass) {
                    if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(stencil) {
                    if (currentStencilClear !== stencil) {
                        gl.clearStencil(stencil);
                        currentStencilClear = stencil;
                    }
                },
                reset: function() {
                    locked = false;
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }
            };
        }
        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();
        var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var newAttributes = new Uint8Array(maxVertexAttributes);
        var enabledAttributes = new Uint8Array(maxVertexAttributes);
        var attributeDivisors = new Uint8Array(maxVertexAttributes);
        var capabilities = {};
        var compressedTextureFormats = null;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
        var currentFlipSided = null;
        var currentCullFace = null;
        var currentLineWidth = null;
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
        var currentScissorTest = null;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
        var lineWidthAvailable = parseFloat(version) >= 1;
        var currentTextureSlot = null;
        var currentBoundTextures = {};
        var currentScissor = new Vector4();
        var currentViewport = new Vector4();
        function createTexture(type, target, count) {
            var data = new Uint8Array(4);
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            return texture;
        }
        var emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        function init() {
            colorBuffer.setClear(0, 0, 0, 1);
            depthBuffer.setClear(1);
            stencilBuffer.setClear(0);
            enable(gl.DEPTH_TEST);
            setDepthFunc(LessEqualDepth);
            setFlipSided(false);
            setCullFace(CullFaceBack);
            enable(gl.CULL_FACE);
            enable(gl.BLEND);
            setBlending(NormalBlending);
        }
        function initAttributes() {
            for (var i = 0, l = newAttributes.length; i < l; i++) {
                newAttributes[i] = 0;
            }
        }
        function enableAttribute(attribute) {
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== 0) {
                var extension = extensions.get("ANGLE_instanced_arrays");
                extension.vertexAttribDivisorANGLE(attribute, 0);
                attributeDivisors[attribute] = 0;
            }
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute, extension) {
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== meshPerAttribute) {
                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                if (enabledAttributes[i] !== newAttributes[i]) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }
        function enable(id) {
            if (capabilities[id] !== true) {
                gl.enable(id);
                capabilities[id] = true;
            }
        }
        function disable(id) {
            if (capabilities[id] !== false) {
                gl.disable(id);
                capabilities[id] = false;
            }
        }
        function getCompressedTextureFormats() {
            if (compressedTextureFormats === null) {
                compressedTextureFormats = [];
                if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1")) {
                    var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                    for (var i = 0; i < formats.length; i++) {
                        compressedTextureFormats.push(formats[i]);
                    }
                }
            }
            return compressedTextureFormats;
        }
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending !== NoBlending) {
                enable(gl.BLEND);
            } else {
                disable(gl.BLEND);
            }
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (blending === AdditiveBlending) {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                    } else {
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                    }
                } else if (blending === SubtractiveBlending) {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    } else {
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                    }
                } else if (blending === MultiplyBlending) {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                    } else {
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    }
                } else {
                    if (premultipliedAlpha) {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    } else {
                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    }
                }
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            if (blending === CustomBlending) {
                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;
                if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                    gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
                    currentBlendEquation = blendEquation;
                    currentBlendEquationAlpha = blendEquationAlpha;
                }
                if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                    gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
                    currentBlendSrc = blendSrc;
                    currentBlendDst = blendDst;
                    currentBlendSrcAlpha = blendSrcAlpha;
                    currentBlendDstAlpha = blendDstAlpha;
                }
            } else {
                currentBlendEquation = null;
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendEquationAlpha = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
            }
        }
        function setColorWrite(colorWrite) {
            colorBuffer.setMask(colorWrite);
        }
        function setDepthTest(depthTest) {
            depthBuffer.setTest(depthTest);
        }
        function setDepthWrite(depthWrite) {
            depthBuffer.setMask(depthWrite);
        }
        function setDepthFunc(depthFunc) {
            depthBuffer.setFunc(depthFunc);
        }
        function setStencilTest(stencilTest) {
            stencilBuffer.setTest(stencilTest);
        }
        function setStencilWrite(stencilWrite) {
            stencilBuffer.setMask(stencilWrite);
        }
        function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
            stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
        }
        function setStencilOp(stencilFail, stencilZFail, stencilZPass) {
            stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
        }
        function setFlipSided(flipSided) {
            if (currentFlipSided !== flipSided) {
                if (flipSided) {
                    gl.frontFace(gl.CW);
                } else {
                    gl.frontFace(gl.CCW);
                }
                currentFlipSided = flipSided;
            }
        }
        function setCullFace(cullFace) {
            if (cullFace !== CullFaceNone) {
                enable(gl.CULL_FACE);
                if (cullFace !== currentCullFace) {
                    if (cullFace === CullFaceBack) {
                        gl.cullFace(gl.BACK);
                    } else if (cullFace === CullFaceFront) {
                        gl.cullFace(gl.FRONT);
                    } else {
                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            } else {
                disable(gl.CULL_FACE);
            }
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            if (width !== currentLineWidth) {
                if (lineWidthAvailable) gl.lineWidth(width);
                currentLineWidth = width;
            }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
                enable(gl.POLYGON_OFFSET_FILL);
                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            } else {
                disable(gl.POLYGON_OFFSET_FILL);
            }
        }
        function getScissorTest() {
            return currentScissorTest;
        }
        function setScissorTest(scissorTest) {
            currentScissorTest = scissorTest;
            if (scissorTest) {
                enable(gl.SCISSOR_TEST);
            } else {
                disable(gl.SCISSOR_TEST);
            }
        }
        function activeTexture(webglSlot) {
            if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
            }
        }
        function bindTexture(webglType, webglTexture) {
            if (currentTextureSlot === null) {
                activeTexture();
            }
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = {
                    type: undefined,
                    texture: undefined
                };
                currentBoundTextures[currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error(error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error(error);
            }
        }
        function scissor(scissor) {
            if (currentScissor.equals(scissor) === false) {
                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                currentScissor.copy(scissor);
            }
        }
        function viewport(viewport) {
            if (currentViewport.equals(viewport) === false) {
                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                currentViewport.copy(viewport);
            }
        }
        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) {
                if (enabledAttributes[i] === 1) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
            capabilities = {};
            compressedTextureFormats = null;
            currentTextureSlot = null;
            currentBoundTextures = {};
            currentBlending = null;
            currentFlipSided = null;
            currentCullFace = null;
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
        }
        return {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            init: init,
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,
            setBlending: setBlending,
            setColorWrite: setColorWrite,
            setDepthTest: setDepthTest,
            setDepthWrite: setDepthWrite,
            setDepthFunc: setDepthFunc,
            setStencilTest: setStencilTest,
            setStencilWrite: setStencilWrite,
            setStencilFunc: setStencilFunc,
            setStencilOp: setStencilOp,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            getScissorTest: getScissorTest,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    function WebGLCapabilities(gl, extensions, parameters) {
        var maxAnisotropy;
        function getMaxAnisotropy() {
            if (maxAnisotropy !== undefined) return maxAnisotropy;
            var extension = extensions.get("EXT_texture_filter_anisotropic");
            if (extension !== null) {
                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
                maxAnisotropy = 0;
            }
            return maxAnisotropy;
        }
        function getMaxPrecision(precision) {
            if (precision === "highp") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    return "highp";
                }
                precision = "mediump";
            }
            if (precision === "mediump") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    return "mediump";
                }
            }
            return "lowp";
        }
        var precision = parameters.precision !== undefined ? parameters.precision : "highp";
        var maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
            console.warn("SZX3D.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
            precision = maxPrecision;
        }
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get("EXT_frag_depth");
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = !!extensions.get("OES_texture_float");
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
        return {
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures
        };
    }
    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function(name) {
                if (extensions[name] !== undefined) {
                    return extensions[name];
                }
                var extension;
                switch (name) {
                  case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;

                  case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;

                  case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;

                  case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;

                  case "WEBGL_compressed_texture_etc1":
                    extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                    break;

                  default:
                    extension = gl.getExtension(name);
                }
                if (extension === null) {
                    console.warn("SZX3D.WebGLRenderer: " + name + " extension not supported.");
                }
                extensions[name] = extension;
                return extension;
            }
        };
    }
    function WebGLClipping() {
        var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
            value: null,
            needsUpdate: false
        };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            globalState = projectPlanes(planes, camera, 0);
            numGlobalPlanes = planes.length;
            return enabled;
        };
        this.beginShadows = function() {
            renderingShadows = true;
            projectPlanes(null);
        };
        this.endShadows = function() {
            renderingShadows = false;
            resetGlobalState();
        };
        this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                if (renderingShadows) {
                    projectPlanes(null);
                } else {
                    resetGlobalState();
                }
            } else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
                uniform.value = dstArray;
                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                    dstArray[i] = globalState[i];
                }
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        };
        function resetGlobalState() {
            if (uniform.value !== globalState) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
            if (nPlanes !== 0) {
                dstArray = uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) {
                        dstArray = new Float32Array(flatSize);
                    }
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                        plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                        plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = plane.constant;
                    }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            return dstArray;
        }
    }
    function WebGLRenderer(parameters) {
        console.log("SZX3D.WebGLRenderer", REVISION);
        parameters = parameters || {};
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
        var lights = [];
        var opaqueObjects = [];
        var opaqueObjectsLastIndex = -1;
        var transparentObjects = [];
        var transparentObjectsLastIndex = -1;
        var morphInfluences = new Float32Array(8);
        var sprites = [];
        var lensFlares = [];
        this.domElement = _canvas;
        this.context = null;
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.gammaFactor = 2;
        this.gammaInput = false;
        this.gammaOutput = false;
        this.physicallyCorrectLights = false;
        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1;
        this.toneMappingWhitePoint = 1;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        var _this = this, _currentProgram = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _currentScissor = new Vector4(), _currentScissorTest = null, _currentViewport = new Vector4(), _usedTextureUnits = 0, _clearColor = new Color(0), _clearAlpha = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _viewport = new Vector4(0, 0, _width, _height), _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _sphere = new Sphere(), _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _matrix4 = new Matrix4(), _matrix42 = new Matrix4(), _lights = {
            hash: "",
            ambient: [ 0, 0, 0 ],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: []
        }, _infoRender = {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        };
        this.info = {
            render: _infoRender,
            memory: {
                geometries: 0,
                textures: 0
            },
            programs: null
        };
        var _gl;
        try {
            var attributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };
            _gl = _context || _canvas.getContext("webgl", attributes) || _canvas.getContext("experimental-webgl", attributes);
            if (_gl === null) {
                if (_canvas.getContext("webgl") !== null) {
                    throw "Error creating WebGL context with your selected attributes.";
                } else {
                    throw "Error creating WebGL context.";
                }
            }
            if (_gl.getShaderPrecisionFormat === undefined) {
                _gl.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    };
                };
            }
            _canvas.addEventListener("webglcontextlost", onContextLost, false);
        } catch (error) {
            console.error("SZX3D.WebGLRenderer: " + error);
        }
        var extensions = new WebGLExtensions(_gl);
        extensions.get("WEBGL_depth_texture");
        extensions.get("OES_texture_float");
        extensions.get("OES_texture_float_linear");
        extensions.get("OES_texture_half_float");
        extensions.get("OES_texture_half_float_linear");
        extensions.get("OES_standard_derivatives");
        extensions.get("ANGLE_instanced_arrays");
        if (extensions.get("OES_element_index_uint")) {
            BufferGeometry.MaxIndex = 4294967296;
        }
        var capabilities = new WebGLCapabilities(_gl, extensions, parameters);
        var state = new WebGLState(_gl, extensions, paramThreeToGL);
        var properties = new WebGLProperties();
        var textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, this.info);
        var objects = new WebGLObjects(_gl, properties, this.info);
        var programCache = new WebGLPrograms(this, capabilities);
        var lightCache = new WebGLLights();
        this.info.programs = programCache.programs;
        var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
        var indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
        var backgroundPlaneCamera, backgroundPlaneMesh;
        var backgroundBoxCamera, backgroundBoxMesh;
        function getTargetPixelRatio() {
            return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        function setDefaultGLState() {
            state.init();
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        }
        function resetGLState() {
            _currentProgram = null;
            _currentCamera = null;
            _currentGeometryProgram = "";
            _currentMaterialId = -1;
            state.reset();
        }
        setDefaultGLState();
        this.context = _gl;
        this.capabilities = capabilities;
        this.extensions = extensions;
        this.properties = properties;
        this.state = state;
        var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);
        this.shadowMap = shadowMap;
        var spritePlugin = new SpritePlugin(this, sprites);
        var lensFlarePlugin = new LensFlarePlugin(this, lensFlares);
        this.getContext = function() {
            return _gl;
        };
        this.getContextAttributes = function() {
            return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
            extensions.get("WEBGL_lose_context").loseContext();
        };
        this.getMaxAnisotropy = function() {
            return capabilities.getMaxAnisotropy();
        };
        this.getPrecision = function() {
            return capabilities.precision;
        };
        this.getPixelRatio = function() {
            return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
            if (value === undefined) return;
            _pixelRatio = value;
            this.setSize(_viewport.z, _viewport.w, false);
        };
        this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        };
        this.setSize = function(width, height, updateStyle) {
            _width = width;
            _height = height;
            _canvas.width = width * _pixelRatio;
            _canvas.height = height * _pixelRatio;
            if (updateStyle !== false) {
                _canvas.style.width = width + "px";
                _canvas.style.height = height + "px";
            }
            this.setViewport(0, 0, width, height);
        };
        this.setViewport = function(x, y, width, height) {
            state.viewport(_viewport.set(x, y, width, height));
        };
        this.setScissor = function(x, y, width, height) {
            state.scissor(_scissor.set(x, y, width, height));
        };
        this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
        };
        this.getClearColor = function() {
            return _clearColor;
        };
        this.setClearColor = function(color, alpha) {
            _clearColor.set(color);
            _clearAlpha = alpha !== undefined ? alpha : 1;
            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        };
        this.getClearAlpha = function() {
            return _clearAlpha;
        };
        this.setClearAlpha = function(alpha) {
            _clearAlpha = alpha;
            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        };
        this.clear = function(color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
            _gl.clear(bits);
        };
        this.clearColor = function() {
            this.clear(true, false, false);
        };
        this.clearDepth = function() {
            this.clear(false, true, false);
        };
        this.clearStencil = function() {
            this.clear(false, false, true);
        };
        this.clearTarget = function(renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        };
        this.resetGLState = resetGLState;
        this.dispose = function() {
            transparentObjects = [];
            transparentObjectsLastIndex = -1;
            opaqueObjects = [];
            opaqueObjectsLastIndex = -1;
            _canvas.removeEventListener("webglcontextlost", onContextLost, false);
        };
        function onContextLost(event) {
            event.preventDefault();
            resetGLState();
            setDefaultGLState();
            properties.clear();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener("dispose", onMaterialDispose);
            deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material);
            properties.delete(material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = undefined;
            if (programInfo !== undefined) {
                programCache.releaseProgram(programInfo);
            }
        }
        this.renderBufferImmediate = function(object, program, material) {
            state.initAttributes();
            var buffers = properties.get(object);
            if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
            var attributes = program.getAttributes();
            if (object.hasPositions) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.position);
                _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
                if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.shading === FlatShading) {
                    for (var i = 0, l = object.count * 3; i < l; i += 9) {
                        var array = object.normalArray;
                        var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                        var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                        var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                        array[i + 0] = nx;
                        array[i + 1] = ny;
                        array[i + 2] = nz;
                        array[i + 3] = nx;
                        array[i + 4] = ny;
                        array[i + 5] = nz;
                        array[i + 6] = nx;
                        array[i + 7] = ny;
                        array[i + 8] = nz;
                    }
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.normal);
                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasUvs && material.map) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.uv);
                _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasColors && material.vertexColors !== NoColors) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(attributes.color);
                _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
            }
            state.disableUnusedAttributes();
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
            object.count = 0;
        };
        this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
            setMaterial(material);
            var program = setProgram(camera, fog, material, object);
            var updateBuffers = false;
            var geometryProgram = geometry.id + "_" + program.id + "_" + material.wireframe;
            if (geometryProgram !== _currentGeometryProgram) {
                _currentGeometryProgram = geometryProgram;
                updateBuffers = true;
            }
            var morphTargetInfluences = object.morphTargetInfluences;
            if (morphTargetInfluences !== undefined) {
                var activeInfluences = [];
                for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {
                    var influence = morphTargetInfluences[i];
                    activeInfluences.push([ influence, i ]);
                }
                activeInfluences.sort(absNumericalSort);
                if (activeInfluences.length > 8) {
                    activeInfluences.length = 8;
                }
                var morphAttributes = geometry.morphAttributes;
                for (var i = 0, l = activeInfluences.length; i < l; i++) {
                    var influence = activeInfluences[i];
                    morphInfluences[i] = influence[0];
                    if (influence[0] !== 0) {
                        var index = influence[1];
                        if (material.morphTargets === true && morphAttributes.position) geometry.addAttribute("morphTarget" + i, morphAttributes.position[index]);
                        if (material.morphNormals === true && morphAttributes.normal) geometry.addAttribute("morphNormal" + i, morphAttributes.normal[index]);
                    } else {
                        if (material.morphTargets === true) geometry.removeAttribute("morphTarget" + i);
                        if (material.morphNormals === true) geometry.removeAttribute("morphNormal" + i);
                    }
                }
                for (var i = activeInfluences.length, il = morphInfluences.length; i < il; i++) {
                    morphInfluences[i] = 0;
                }
                program.getUniforms().setValue(_gl, "morphTargetInfluences", morphInfluences);
                updateBuffers = true;
            }
            var index = geometry.index;
            var position = geometry.attributes.position;
            var rangeFactor = 1;
            if (material.wireframe === true) {
                index = objects.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }
            var renderer;
            if (index !== null) {
                renderer = indexedBufferRenderer;
                renderer.setIndex(index);
            } else {
                renderer = bufferRenderer;
            }
            if (updateBuffers) {
                setupVertexAttributes(material, program, geometry);
                if (index !== null) {
                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
                }
            }
            var dataCount = 0;
            if (index !== null) {
                dataCount = index.count;
            } else if (position !== undefined) {
                dataCount = position.count;
            }
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
            var drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (drawCount === 0) return;
            if (object.isMesh) {
                if (material.wireframe === true) {
                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(_gl.LINES);
                } else {
                    switch (object.drawMode) {
                      case TrianglesDrawMode:
                        renderer.setMode(_gl.TRIANGLES);
                        break;

                      case TriangleStripDrawMode:
                        renderer.setMode(_gl.TRIANGLE_STRIP);
                        break;

                      case TriangleFanDrawMode:
                        renderer.setMode(_gl.TRIANGLE_FAN);
                        break;
                    }
                }
            } else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined) lineWidth = 1;
                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) {
                    renderer.setMode(_gl.LINES);
                } else {
                    renderer.setMode(_gl.LINE_STRIP);
                }
            } else if (object.isPoints) {
                renderer.setMode(_gl.POINTS);
            }
            if (geometry && geometry.isInstancedBufferGeometry) {
                if (geometry.maxInstancedCount > 0) {
                    renderer.renderInstances(geometry, drawStart, drawCount);
                }
            } else {
                renderer.render(drawStart, drawCount);
            }
        };
        function setupVertexAttributes(material, program, geometry, startIndex) {
            var extension;
            if (geometry && geometry.isInstancedBufferGeometry) {
                extension = extensions.get("ANGLE_instanced_arrays");
                if (extension === null) {
                    console.error("SZX3D.WebGLRenderer.setupVertexAttributes: using SZX3D.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return;
                }
            }
            if (startIndex === undefined) startIndex = 0;
            state.initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        var attributeProperties = objects.getAttributeProperties(geometryAttribute);
                        var buffer = attributeProperties.__webglBuffer;
                        var type = attributeProperties.type;
                        var bytesPerElement = attributeProperties.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data && data.isInstancedInterleavedBuffer) {
                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            } else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
                        } else {
                            if (geometryAttribute.isInstancedBufferAttribute) {
                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            } else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);
                        }
                    } else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) {
                            switch (value.length) {
                              case 2:
                                _gl.vertexAttrib2fv(programAttribute, value);
                                break;

                              case 3:
                                _gl.vertexAttrib3fv(programAttribute, value);
                                break;

                              case 4:
                                _gl.vertexAttrib4fv(programAttribute, value);
                                break;

                              default:
                                _gl.vertexAttrib1fv(programAttribute, value);
                            }
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        function absNumericalSort(a, b) {
            return Math.abs(b[0]) - Math.abs(a[0]);
        }
        function painterSortStable(a, b) {
            if (a.object.renderOrder !== b.object.renderOrder) {
                return a.object.renderOrder - b.object.renderOrder;
            } else if (a.material.program && b.material.program && a.material.program !== b.material.program) {
                return a.material.program.id - b.material.program.id;
            } else if (a.material.id !== b.material.id) {
                return a.material.id - b.material.id;
            } else if (a.z !== b.z) {
                return a.z - b.z;
            } else {
                return a.id - b.id;
            }
        }
        function reversePainterSortStable(a, b) {
            if (a.object.renderOrder !== b.object.renderOrder) {
                return a.object.renderOrder - b.object.renderOrder;
            }
            if (a.z !== b.z) {
                return b.z - a.z;
            } else {
                return a.id - b.id;
            }
        }
        this.render = function(scene, camera, renderTarget, forceClear) {
            if (camera !== undefined && camera.isCamera !== true) {
                console.error("SZX3D.WebGLRenderer.render: camera is not an instance of SZX3D.Camera.");
                return;
            }
            _currentGeometryProgram = "";
            _currentMaterialId = -1;
            _currentCamera = null;
            if (scene.autoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null) camera.updateMatrixWorld();
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);
            lights.length = 0;
            opaqueObjectsLastIndex = -1;
            transparentObjectsLastIndex = -1;
            sprites.length = 0;
            lensFlares.length = 0;
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
            projectObject(scene, camera);
            opaqueObjects.length = opaqueObjectsLastIndex + 1;
            transparentObjects.length = transparentObjectsLastIndex + 1;
            if (_this.sortObjects === true) {
                opaqueObjects.sort(painterSortStable);
                transparentObjects.sort(reversePainterSortStable);
            }
            if (_clippingEnabled) _clipping.beginShadows();
            setupShadows(lights);
            shadowMap.render(scene, camera);
            setupLights(lights, camera);
            if (_clippingEnabled) _clipping.endShadows();
            _infoRender.calls = 0;
            _infoRender.vertices = 0;
            _infoRender.faces = 0;
            _infoRender.points = 0;
            if (renderTarget === undefined) {
                renderTarget = null;
            }
            this.setRenderTarget(renderTarget);
            var background = scene.background;
            if (background === null) {
                state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
            } else if (background && background.isColor) {
                state.buffers.color.setClear(background.r, background.g, background.b, 1, _premultipliedAlpha);
                forceClear = true;
            }
            if (this.autoClear || forceClear) {
                this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            }
            if (background && background.isCubeTexture) {
                if (backgroundBoxCamera === undefined) {
                    backgroundBoxCamera = new PerspectiveCamera();
                    backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
                        uniforms: ShaderLib.cube.uniforms,
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                }
                backgroundBoxCamera.projectionMatrix.copy(camera.projectionMatrix);
                backgroundBoxCamera.matrixWorld.extractRotation(camera.matrixWorld);
                backgroundBoxCamera.matrixWorldInverse.getInverse(backgroundBoxCamera.matrixWorld);
                backgroundBoxMesh.material.uniforms["tCube"].value = background;
                backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld);
                objects.update(backgroundBoxMesh);
                _this.renderBufferDirect(backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null);
            } else if (background && background.isTexture) {
                if (backgroundPlaneCamera === undefined) {
                    backgroundPlaneCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                }
                backgroundPlaneMesh.material.map = background;
                objects.update(backgroundPlaneMesh);
                _this.renderBufferDirect(backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null);
            }
            if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                renderObjects(transparentObjects, scene, camera, overrideMaterial);
            } else {
                state.setBlending(NoBlending);
                renderObjects(opaqueObjects, scene, camera);
                renderObjects(transparentObjects, scene, camera);
            }
            spritePlugin.render(scene, camera);
            lensFlarePlugin.render(scene, camera, _currentViewport);
            if (renderTarget) {
                textures.updateRenderTargetMipmap(renderTarget);
            }
            state.setDepthTest(true);
            state.setDepthWrite(true);
            state.setColorWrite(true);
        };
        function pushRenderItem(object, geometry, material, z, group) {
            var array, index;
            if (material.transparent) {
                array = transparentObjects;
                index = ++transparentObjectsLastIndex;
            } else {
                array = opaqueObjects;
                index = ++opaqueObjectsLastIndex;
            }
            var renderItem = array[index];
            if (renderItem !== undefined) {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.z = _vector3.z;
                renderItem.group = group;
            } else {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    z: _vector3.z,
                    group: group
                };
                array.push(renderItem);
            }
        }
        function isObjectViewable(object) {
            var geometry = object.geometry;
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
            return isSphereViewable(_sphere);
        }
        function isSpriteViewable(sprite) {
            _sphere.center.set(0, 0, 0);
            _sphere.radius = .7071067811865476;
            _sphere.applyMatrix4(sprite.matrixWorld);
            return isSphereViewable(_sphere);
        }
        function isSphereViewable(sphere) {
            if (!_frustum.intersectsSphere(sphere)) return false;
            var numPlanes = _clipping.numPlanes;
            if (numPlanes === 0) return true;
            var planes = _this.clippingPlanes, center = sphere.center, negRad = -sphere.radius, i = 0;
            do {
                if (planes[i].distanceToPoint(center) < negRad) return false;
            } while (++i !== numPlanes);
            return true;
        }
        function projectObject(object, camera) {
            if (object.visible === false) return;
            var visible = (object.layers.mask & camera.layers.mask) !== 0;
            if (visible) {
                if (object.isLight) {
                    lights.push(object);
                } else if (object.isSprite) {
                    if (object.frustumCulled === false || isSpriteViewable(object) === true) {
                        sprites.push(object);
                    }
                } else if (object.isLensFlare) {
                    lensFlares.push(object);
                } else if (object.isImmediateRenderObject) {
                    if (_this.sortObjects === true) {
                        _vector3.setFromMatrixPosition(object.matrixWorld);
                        _vector3.applyMatrix4(_projScreenMatrix);
                    }
                    pushRenderItem(object, null, object.material, _vector3.z, null);
                } else if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isSkinnedMesh) {
                        object.skeleton.update();
                    }
                    if (object.frustumCulled === false || isObjectViewable(object) === true) {
                        var material = object.material;
                        if (material.visible === true) {
                            if (_this.sortObjects === true) {
                                _vector3.setFromMatrixPosition(object.matrixWorld);
                                _vector3.applyMatrix4(_projScreenMatrix);
                            }
                            var geometry = objects.update(object);
                            if (material.isMultiMaterial) {
                                var groups = geometry.groups;
                                var materials = material.materials;
                                for (var i = 0, l = groups.length; i < l; i++) {
                                    var group = groups[i];
                                    var groupMaterial = materials[group.materialIndex];
                                    if (groupMaterial.visible === true) {
                                        pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                                    }
                                }
                            } else {
                                pushRenderItem(object, geometry, material, _vector3.z, null);
                            }
                        }
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                projectObject(children[i], camera);
            }
        }
        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
                object.onBeforeRender(_this, scene, camera, geometry, material, group);
                if (object.isImmediateRenderObject) {
                    setMaterial(material);
                    var program = setProgram(camera, scene.fog, material, object);
                    _currentGeometryProgram = "";
                    object.render(function(object) {
                        _this.renderBufferImmediate(object, program, material);
                    });
                } else {
                    _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
                }
                object.onAfterRender(_this, scene, camera, geometry, material, group);
            }
        }
        function initMaterial(material, fog, object) {
            var materialProperties = properties.get(material);
            var parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object);
            var code = programCache.getProgramCode(material, parameters);
            var program = materialProperties.program;
            var programChange = true;
            if (program === undefined) {
                material.addEventListener("dispose", onMaterialDispose);
            } else if (program.code !== code) {
                releaseMaterialProgramReference(material);
            } else if (parameters.shaderID !== undefined) {
                return;
            } else {
                programChange = false;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = ShaderLib[parameters.shaderID];
                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else {
                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }
                material.__webglShader = materialProperties.__webglShader;
                program = programCache.acquireProgram(material, parameters, code);
                materialProperties.program = program;
                material.program = program;
            }
            var attributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) {
                    if (attributes["morphTarget" + i] >= 0) {
                        material.numSupportedMorphTargets++;
                    }
                }
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) {
                    if (attributes["morphNormal" + i] >= 0) {
                        material.numSupportedMorphNormals++;
                    }
                }
            }
            var uniforms = materialProperties.__webglShader.uniforms;
            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
            }
            materialProperties.fog = fog;
            materialProperties.lightsHash = _lights.hash;
            if (material.lights) {
                uniforms.ambientLightColor.value = _lights.ambient;
                uniforms.directionalLights.value = _lights.directional;
                uniforms.spotLights.value = _lights.spot;
                uniforms.rectAreaLights.value = _lights.rectArea;
                uniforms.pointLights.value = _lights.point;
                uniforms.hemisphereLights.value = _lights.hemi;
                uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
                uniforms.spotShadowMap.value = _lights.spotShadowMap;
                uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
                uniforms.pointShadowMap.value = _lights.pointShadowMap;
                uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
            }
            var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setMaterial(material) {
            material.side === DoubleSide ? state.disable(_gl.CULL_FACE) : state.enable(_gl.CULL_FACE);
            state.setFlipSided(material.side === BackSide);
            material.transparent === true ? state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : state.setBlending(NoBlending);
            state.setDepthFunc(material.depthFunc);
            state.setDepthTest(material.depthTest);
            state.setDepthWrite(material.depthWrite);
            state.setColorWrite(material.colorWrite);
            state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        function setProgram(camera, fog, material, object) {
            _usedTextureUnits = 0;
            var materialProperties = properties.get(material);
            if (_clippingEnabled) {
                if (_localClippingEnabled || camera !== _currentCamera) {
                    var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                    _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                }
            }
            if (material.needsUpdate === false) {
                if (materialProperties.program === undefined) {
                    material.needsUpdate = true;
                } else if (material.fog && materialProperties.fog !== fog) {
                    material.needsUpdate = true;
                } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {
                    material.needsUpdate = true;
                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
                    material.needsUpdate = true;
                }
            }
            if (material.needsUpdate) {
                initMaterial(material, fog, object);
                material.needsUpdate = false;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.__webglShader.uniforms;
            if (program.id !== _currentProgram) {
                _gl.useProgram(program.program);
                _currentProgram = program.id;
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || camera !== _currentCamera) {
                p_uniforms.set(_gl, camera, "projectionMatrix");
                if (capabilities.logarithmicDepthBuffer) {
                    p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
                }
                if (camera !== _currentCamera) {
                    _currentCamera = camera;
                    refreshMaterial = true;
                    refreshLights = true;
                }
                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) {
                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }
                if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                    p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
                }
                p_uniforms.set(_gl, _this, "toneMappingExposure");
                p_uniforms.set(_gl, _this, "toneMappingWhitePoint");
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, "bindMatrix");
                p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                var skeleton = object.skeleton;
                if (skeleton) {
                    if (capabilities.floatVertexTextures && skeleton.useVertexTexture) {
                        p_uniforms.set(_gl, skeleton, "boneTexture");
                        p_uniforms.set(_gl, skeleton, "boneTextureWidth");
                        p_uniforms.set(_gl, skeleton, "boneTextureHeight");
                    } else {
                        p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
                    }
                }
            }
            if (refreshMaterial) {
                if (material.lights) {
                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                if (fog && material.fog) {
                    refreshUniformsFog(m_uniforms, fog);
                }
                if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshNormalMaterial || material.isMeshDepthMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                }
                if (material.isLineBasicMaterial) {
                    refreshUniformsLine(m_uniforms, material);
                } else if (material.isLineDashedMaterial) {
                    refreshUniformsLine(m_uniforms, material);
                    refreshUniformsDash(m_uniforms, material);
                } else if (material.isPointsMaterial) {
                    refreshUniformsPoints(m_uniforms, material);
                } else if (material.isMeshLambertMaterial) {
                    refreshUniformsLambert(m_uniforms, material);
                } else if (material.isMeshToonMaterial) {
                    refreshUniformsToon(m_uniforms, material);
                } else if (material.isMeshPhongMaterial) {
                    refreshUniformsPhong(m_uniforms, material);
                } else if (material.isMeshPhysicalMaterial) {
                    refreshUniformsPhysical(m_uniforms, material);
                } else if (material.isMeshStandardMaterial) {
                    refreshUniformsStandard(m_uniforms, material);
                } else if (material.isMeshDepthMaterial) {
                    if (material.displacementMap) {
                        m_uniforms.displacementMap.value = material.displacementMap;
                        m_uniforms.displacementScale.value = material.displacementScale;
                        m_uniforms.displacementBias.value = material.displacementBias;
                    }
                } else if (material.isMeshNormalMaterial) {
                    refreshUniformsNormal(m_uniforms, material);
                }
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
            }
            p_uniforms.set(_gl, object, "modelViewMatrix");
            p_uniforms.set(_gl, object, "normalMatrix");
            p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
            return program;
        }
        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity;
            uniforms.diffuse.value = material.color;
            if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            uniforms.map.value = material.map;
            uniforms.specularMap.value = material.specularMap;
            uniforms.alphaMap.value = material.alphaMap;
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            } else if (material.specularMap) {
                uvScaleMap = material.specularMap;
            } else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
            } else if (material.normalMap) {
                uvScaleMap = material.normalMap;
            } else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
            } else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
            } else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
            } else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            } else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
            }
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.isWebGLRenderTarget) {
                    uvScaleMap = uvScaleMap.texture;
                }
                var offset = uvScaleMap.offset;
                var repeat = uvScaleMap.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
            uniforms.envMap.value = material.envMap;
            uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * .5;
            uniforms.map.value = material.map;
            if (material.map !== null) {
                var offset = material.map.offset;
                var repeat = material.map.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        }
        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color;
            if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) {
                uniforms.fogDensity.value = fog.density;
            }
        }
        function refreshUniformsLambert(uniforms, material) {
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular;
            uniforms.shininess.value = Math.max(material.shininess, 1e-4);
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsToon(uniforms, material) {
            refreshUniformsPhong(uniforms, material);
            if (material.gradientMap) {
                uniforms.gradientMap.value = material.gradientMap;
            }
        }
        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.envMap) {
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }
        function refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
            refreshUniformsStandard(uniforms, material);
        }
        function refreshUniformsNormal(uniforms, material) {
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }
        function setupShadows(lights) {
            var lightShadowsLength = 0;
            for (var i = 0, l = lights.length; i < l; i++) {
                var light = lights[i];
                if (light.castShadow) {
                    _lights.shadows[lightShadowsLength++] = light;
                }
            }
            _lights.shadows.length = lightShadowsLength;
        }
        function setupLights(lights, camera) {
            var l, ll, light, r = 0, g = 0, b = 0, color, intensity, distance, shadowMap, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, rectAreaLength = 0, hemiLength = 0;
            for (l = 0, ll = lights.length; l < ll; l++) {
                light = lights[l];
                color = light.color;
                intensity = light.intensity;
                distance = light.distance;
                shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                } else if (light.isDirectionalLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        uniforms.shadowBias = light.shadow.bias;
                        uniforms.shadowRadius = light.shadow.radius;
                        uniforms.shadowMapSize = light.shadow.mapSize;
                    }
                    _lights.directionalShadowMap[directionalLength] = shadowMap;
                    _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    _lights.directional[directionalLength++] = uniforms;
                } else if (light.isSpotLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = light.distance === 0 ? 0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        uniforms.shadowBias = light.shadow.bias;
                        uniforms.shadowRadius = light.shadow.radius;
                        uniforms.shadowMapSize = light.shadow.mapSize;
                    }
                    _lights.spotShadowMap[spotLength] = shadowMap;
                    _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    _lights.spot[spotLength++] = uniforms;
                } else if (light.isRectAreaLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    _matrix42.identity();
                    _matrix4.copy(light.matrixWorld);
                    _matrix4.premultiply(viewMatrix);
                    _matrix42.extractRotation(_matrix4);
                    uniforms.halfWidth.set(light.width * .5, 0, 0);
                    uniforms.halfHeight.set(0, light.height * .5, 0);
                    uniforms.halfWidth.applyMatrix4(_matrix42);
                    uniforms.halfHeight.applyMatrix4(_matrix42);
                    _lights.rectArea[rectAreaLength++] = uniforms;
                } else if (light.isPointLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = light.distance === 0 ? 0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        uniforms.shadowBias = light.shadow.bias;
                        uniforms.shadowRadius = light.shadow.radius;
                        uniforms.shadowMapSize = light.shadow.mapSize;
                    }
                    _lights.pointShadowMap[pointLength] = shadowMap;
                    if (_lights.pointShadowMatrix[pointLength] === undefined) {
                        _lights.pointShadowMatrix[pointLength] = new Matrix4();
                    }
                    _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                    _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);
                    _lights.point[pointLength++] = uniforms;
                } else if (light.isHemisphereLight) {
                    var uniforms = lightCache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();
                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    _lights.hemi[hemiLength++] = uniforms;
                }
            }
            _lights.ambient[0] = r;
            _lights.ambient[1] = g;
            _lights.ambient[2] = b;
            _lights.directional.length = directionalLength;
            _lights.spot.length = spotLength;
            _lights.rectArea.length = rectAreaLength;
            _lights.point.length = pointLength;
            _lights.hemi.length = hemiLength;
            _lights.hash = directionalLength + "," + pointLength + "," + spotLength + "," + rectAreaLength + "," + hemiLength + "," + _lights.shadows.length;
        }
        this.setFaceCulling = function(cullFace, frontFaceDirection) {
            state.setCullFace(cullFace);
            state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        };
        function allocTextureUnit() {
            var textureUnit = _usedTextureUnits;
            if (textureUnit >= capabilities.maxTextures) {
                console.warn("WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
            }
            _usedTextureUnits += 1;
            return textureUnit;
        }
        this.allocTextureUnit = allocTextureUnit;
        this.setTexture2D = function() {
            var warned = false;
            return function setTexture2D(texture, slot) {
                if (texture && texture.isWebGLRenderTarget) {
                    if (!warned) {
                        console.warn("SZX3D.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }
                    texture = texture.texture;
                }
                textures.setTexture2D(texture, slot);
            };
        }();
        this.setTexture = function() {
            var warned = false;
            return function setTexture(texture, slot) {
                if (!warned) {
                    console.warn("SZX3D.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                    warned = true;
                }
                textures.setTexture2D(texture, slot);
            };
        }();
        this.setTextureCube = function() {
            var warned = false;
            return function setTextureCube(texture, slot) {
                if (texture && texture.isWebGLRenderTargetCube) {
                    if (!warned) {
                        console.warn("SZX3D.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }
                    texture = texture.texture;
                }
                if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
                    textures.setTextureCube(texture, slot);
                } else {
                    textures.setTextureCubeDynamic(texture, slot);
                }
            };
        }();
        this.getCurrentRenderTarget = function() {
            return _currentRenderTarget;
        };
        this.setRenderTarget = function(renderTarget) {
            _currentRenderTarget = renderTarget;
            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                textures.setupRenderTarget(renderTarget);
            }
            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            var framebuffer;
            if (renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                if (isCube) {
                    framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
                } else {
                    framebuffer = renderTargetProperties.__webglFramebuffer;
                }
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
                _currentViewport.copy(renderTarget.viewport);
            } else {
                framebuffer = null;
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                _currentScissorTest = _scissorTest;
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
            }
            if (_currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _currentFramebuffer = framebuffer;
            }
            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);
            state.viewport(_currentViewport);
            if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        };
        this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
            if ((renderTarget && renderTarget.isWebGLRenderTarget) === false) {
                console.error("SZX3D.WebGLRenderer.readRenderTargetPixels: renderTarget is not SZX3D.WebGLRenderTarget.");
                return;
            }
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = false;
                if (framebuffer !== _currentFramebuffer) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                    restore = true;
                }
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("SZX3D.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return;
                    }
                    if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) {
                        console.error("SZX3D.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return;
                    }
                    if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                        if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
                            _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
                        }
                    } else {
                        console.error("SZX3D.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                    }
                } finally {
                    if (restore) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                    }
                }
            }
        };
        function paramThreeToGL(p) {
            var extension;
            if (p === RepeatWrapping) return _gl.REPEAT;
            if (p === ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;
            if (p === NearestFilter) return _gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;
            if (p === LinearFilter) return _gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;
            if (p === UnsignedByteType) return _gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;
            if (p === ByteType) return _gl.BYTE;
            if (p === ShortType) return _gl.SHORT;
            if (p === UnsignedShortType) return _gl.UNSIGNED_SHORT;
            if (p === IntType) return _gl.INT;
            if (p === UnsignedIntType) return _gl.UNSIGNED_INT;
            if (p === FloatType) return _gl.FLOAT;
            if (p === HalfFloatType) {
                extension = extensions.get("OES_texture_half_float");
                if (extension !== null) return extension.HALF_FLOAT_OES;
            }
            if (p === AlphaFormat) return _gl.ALPHA;
            if (p === RGBFormat) return _gl.RGB;
            if (p === RGBAFormat) return _gl.RGBA;
            if (p === LuminanceFormat) return _gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return _gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return _gl.DEPTH_STENCIL;
            if (p === AddEquation) return _gl.FUNC_ADD;
            if (p === SubtractEquation) return _gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;
            if (p === ZeroFactor) return _gl.ZERO;
            if (p === OneFactor) return _gl.ONE;
            if (p === SrcColorFactor) return _gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return _gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return _gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;
            if (p === DstColorFactor) return _gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;
            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                extension = extensions.get("WEBGL_compressed_texture_s3tc");
                if (extension !== null) {
                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            }
            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get("WEBGL_compressed_texture_pvrtc");
                if (extension !== null) {
                    if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
            }
            if (p === RGB_ETC1_Format) {
                extension = extensions.get("WEBGL_compressed_texture_etc1");
                if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            }
            if (p === MinEquation || p === MaxEquation) {
                extension = extensions.get("EXT_blend_minmax");
                if (extension !== null) {
                    if (p === MinEquation) return extension.MIN_EXT;
                    if (p === MaxEquation) return extension.MAX_EXT;
                }
            }
            if (p === UnsignedInt248Type) {
                extension = extensions.get("WEBGL_depth_texture");
                if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            }
            return 0;
        }
    }
    function WebGLRenderTargetCube(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options);
        this.activeCubeFace = 0;
        this.activeMipMapLevel = 0;
    }
    WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
    function WebGL2Renderer(parameters) {
        console.log("SZX3D.WebGL2Renderer", REVISION);
        parameters = parameters || {};
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
        var gl;
        try {
            var attributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };
            gl = _context || _canvas.getContext("webgl2", attributes);
            if (gl === null) {
                if (_canvas.getContext("webgl2") !== null) {
                    throw "Error creating WebGL2 context with your selected attributes.";
                } else {
                    throw "Error creating WebGL2 context.";
                }
            }
            _canvas.addEventListener("webglcontextlost", onContextLost, false);
        } catch (error) {
            console.error("SZX3D.WebGL2Renderer: " + error);
        }
        var _this = this, _autoClear = true, _autoClearColor = true, _autoClearDepth = true, _autoClearStencil = true, _clearColor = new Color(0), _clearAlpha = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height);
        var extensions = new WebGLExtensions(gl);
        var state = new WebGLState(gl, extensions, function() {});
        function clear(color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color) bits |= gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth) bits |= gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil) bits |= gl.STENCIL_BUFFER_BIT;
            gl.clear(bits);
        }
        function setPixelRatio(value) {
            if (value === undefined) return;
            _pixelRatio = value;
            setSize(_viewport.z, _viewport.w, false);
        }
        function setSize(width, height, updateStyle) {
            _width = width;
            _height = height;
            _canvas.width = width * _pixelRatio;
            _canvas.height = height * _pixelRatio;
            if (updateStyle !== false) {
                _canvas.style.width = width + "px";
                _canvas.style.height = height + "px";
            }
            setViewport(0, 0, width, height);
        }
        function setViewport(x, y, width, height) {
            state.viewport(_viewport.set(x, y, width, height));
        }
        function render(scene, camera) {
            if (camera !== undefined && camera.isCamera !== true) {
                console.error("SZX3D.WebGL2Renderer.render: camera is not an instance of SZX3D.Camera.");
                return;
            }
            var background = scene.background;
            var forceClear = false;
            if (background === null) {
                state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
            } else if (background && background.isColor) {
                state.buffers.color.setClear(background.r, background.g, background.b, 1, _premultipliedAlpha);
                forceClear = true;
            }
            if (_autoClear || forceClear) {
                this.clear(_autoClearColor, _autoClearDepth, _autoClearStencil);
            }
        }
        function onContextLost(event) {
            event.preventDefault();
        }
        return {
            domElement: _canvas,
            clear: clear,
            setPixelRatio: setPixelRatio,
            setSize: setSize,
            render: render
        };
    }
    function PointsMaterial(parameters) {
        Material.call(this);
        this.type = "PointsMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.lights = false;
        this.setValues(parameters);
    }
    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;
    PointsMaterial.prototype.isPointsMaterial = true;
    PointsMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    };
    function LineBasicMaterial(parameters) {
        Material.call(this);
        this.type = "LineBasicMaterial";
        this.color = new Color(16777215);
        this.linewidth = 1;
        this.linecap = "round";
        this.linejoin = "round";
        this.lights = false;
        this.setValues(parameters);
    }
    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    LineBasicMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
    };
    function LineDashedMaterial(parameters) {
        Material.call(this);
        this.type = "LineDashedMaterial";
        this.color = new Color(16777215);
        this.linewidth = 1;
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.lights = false;
        this.setValues(parameters);
    }
    LineDashedMaterial.prototype = Object.create(Material.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    LineDashedMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    };
    function MeshLambertMaterial(parameters) {
        Material.call(this);
        this.type = "MeshLambertMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshNormalMaterial(parameters) {
        Material.call(this, parameters);
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshPhongMaterial(parameters) {
        Material.call(this);
        this.type = "MeshPhongMaterial";
        this.color = new Color(16777215);
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshToonMaterial(parameters) {
        MeshPhongMaterial.call(this);
        this.defines = {
            TOON: ""
        };
        this.type = "MeshToonMaterial";
        this.gradientMap = null;
        this.setValues(parameters);
    }
    MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshToonMaterial.prototype.copy = function(source) {
        MeshPhongMaterial.prototype.copy.call(this, source);
        this.gradientMap = source.gradientMap;
        return this;
    };
    function MeshStandardMaterial(parameters) {
        Material.call(this);
        this.defines = {
            STANDARD: ""
        };
        this.type = "MeshStandardMaterial";
        this.color = new Color(16777215);
        this.roughness = .5;
        this.metalness = .5;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = .98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.defines = {
            STANDARD: ""
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this);
        this.defines = {
            PHYSICAL: ""
        };
        this.type = "MeshPhysicalMaterial";
        this.reflectivity = .5;
        this.clearCoat = 0;
        this.clearCoatRoughness = 0;
        this.setValues(parameters);
    }
    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial.prototype.copy = function(source) {
        MeshStandardMaterial.prototype.copy.call(this, source);
        this.defines = {
            PHYSICAL: ""
        };
        this.reflectivity = source.reflectivity;
        this.clearCoat = source.clearCoat;
        this.clearCoatRoughness = source.clearCoatRoughness;
        return this;
    };
    function SpriteMaterial(parameters) {
        Material.call(this);
        this.type = "SpriteMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.rotation = 0;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.rotation = source.rotation;
        return this;
    };
    function MultiMaterial(materials) {
        this.uuid = _Math.generateUUID();
        this.type = "MultiMaterial";
        this.materials = Array.isArray(materials) ? materials : [];
        this.visible = true;
    }
    MultiMaterial.prototype = {
        constructor: MultiMaterial,
        isMultiMaterial: true,
        toJSON: function(meta) {
            var output = {
                metadata: {
                    version: 4.2,
                    type: "material",
                    generator: "MaterialExporter"
                },
                uuid: this.uuid,
                type: this.type,
                materials: []
            };
            var materials = this.materials;
            for (var i = 0, l = materials.length; i < l; i++) {
                var material = materials[i].toJSON(meta);
                delete material.metadata;
                output.materials.push(material);
            }
            output.visible = this.visible;
            return output;
        },
        clone: function() {
            var material = new this.constructor();
            for (var i = 0; i < this.materials.length; i++) {
                material.materials.push(this.materials[i].clone());
            }
            material.visible = this.visible;
            return material;
        }
    };
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters);
        this.type = "RawShaderMaterial";
    }
    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    function ShadowMaterial() {
        ShaderMaterial.call(this, {
            uniforms: UniformsUtils.merge([ UniformsLib.lights, {
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk["shadow_vert"],
            fragmentShader: ShaderChunk["shadow_frag"]
        });
        this.lights = true;
        this.transparent = true;
        Object.defineProperties(this, {
            opacity: {
                enumerable: true,
                get: function() {
                    return this.uniforms.opacity.value;
                },
                set: function(value) {
                    this.uniforms.opacity.value = value;
                }
            }
        });
    }
    ShadowMaterial.prototype = Object.create(ShaderMaterial.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    ShadowMaterial.prototype.isShadowMaterial = true;
    var Materials = Object.freeze({
        Material: Material,
        PointsMaterial: PointsMaterial,
        LineBasicMaterial: LineBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        SpriteMaterial: SpriteMaterial,
        MultiMaterial: MultiMaterial,
        ShaderMaterial: ShaderMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShadowMaterial: ShadowMaterial
    });
    function Group() {
        Object3D.call(this);
        this.type = "Group";
    }
    Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group
    });
    function Points(geometry, material) {
        Object3D.call(this);
        this.type = "Points";
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointsMaterial({
            color: Math.random() * 16777215
        });
    }
    Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: true,
        raycast: function() {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            return function raycast(raycaster, intersects) {
                var object = this;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false) return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                var localThresholdSq = localThreshold * localThreshold;
                var position = new Vector3();
                function testPoint(point, index) {
                    var rayPointDistanceSq = ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        var intersectPoint = ray.closestPointToPoint(point);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    if (index !== null) {
                        var indices = index.array;
                        for (var i = 0, il = indices.length; i < il; i++) {
                            var a = indices[i];
                            position.fromArray(positions, a * 3);
                            testPoint(position, a);
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3; i < l; i++) {
                            position.fromArray(positions, i * 3);
                            testPoint(position, i);
                        }
                    }
                } else {
                    var vertices = geometry.vertices;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        testPoint(vertices[i], i);
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function Line(geometry, material, mode) {
        if (mode === 1) {
            console.warn("SZX3D.Line: parameter SZX3D.LinePieces no longer supported. Created SZX3D.LineSegments instead.");
            return new LineSegments(geometry, material);
        }
        Object3D.call(this);
        this.type = "Line";
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial({
            color: Math.random() * 16777215
        });
    }
    Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: true,
        raycast: function() {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            return function raycast(raycaster, intersects) {
                var precision = raycaster.linePrecision;
                var precisionSq = precision * precision;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false) return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var vStart = new Vector3();
                var vEnd = new Vector3();
                var interSegment = new Vector3();
                var interRay = new Vector3();
                var step = this && this.isLineSegments ? 2 : 1;
                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    if (index !== null) {
                        var indices = index.array;
                        for (var i = 0, l = indices.length - 1; i < l; i += step) {
                            var a = indices[i];
                            var b = indices[i + 1];
                            vStart.fromArray(positions, a * 3);
                            vEnd.fromArray(positions, b * 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (distSq > precisionSq) continue;
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far) continue;
                            intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                            vStart.fromArray(positions, 3 * i);
                            vEnd.fromArray(positions, 3 * i + 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (distSq > precisionSq) continue;
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far) continue;
                            intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                } else if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    var nbVertices = vertices.length;
                    for (var i = 0; i < nbVertices - 1; i += step) {
                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                        if (distSq > precisionSq) continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far) continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material);
        this.type = "LineSegments";
    }
    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: true
    });
    function Bone() {
        Object3D.call(this);
        this.type = "Bone";
    }
    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: true
    });
    function Skeleton(bones, boneInverses, useVertexTexture) {
        this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
        this.identityMatrix = new Matrix4();
        bones = bones || [];
        this.bones = bones.slice(0);
        if (this.useVertexTexture) {
            var size = Math.sqrt(this.bones.length * 4);
            size = _Math.nextPowerOfTwo(Math.ceil(size));
            size = Math.max(size, 4);
            this.boneTextureWidth = size;
            this.boneTextureHeight = size;
            this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
            this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType);
        } else {
            this.boneMatrices = new Float32Array(16 * this.bones.length);
        }
        if (boneInverses === undefined) {
            this.calculateInverses();
        } else {
            if (this.bones.length === boneInverses.length) {
                this.boneInverses = boneInverses.slice(0);
            } else {
                console.warn("SZX3D.Skeleton bonInverses is the wrong length.");
                this.boneInverses = [];
                for (var b = 0, bl = this.bones.length; b < bl; b++) {
                    this.boneInverses.push(new Matrix4());
                }
            }
        }
    }
    Object.assign(Skeleton.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                var inverse = new Matrix4();
                if (this.bones[b]) {
                    inverse.getInverse(this.bones[b].matrixWorld);
                }
                this.boneInverses.push(inverse);
            }
        },
        pose: function() {
            var bone;
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                bone = this.bones[b];
                if (bone) {
                    bone.matrixWorld.getInverse(this.boneInverses[b]);
                }
            }
            for (var b = 0, bl = this.bones.length; b < bl; b++) {
                bone = this.bones[b];
                if (bone) {
                    if (bone.parent && bone.parent.isBone) {
                        bone.matrix.getInverse(bone.parent.matrixWorld);
                        bone.matrix.multiply(bone.matrixWorld);
                    } else {
                        bone.matrix.copy(bone.matrixWorld);
                    }
                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        },
        update: function() {
            var offsetMatrix = new Matrix4();
            return function update() {
                for (var b = 0, bl = this.bones.length; b < bl; b++) {
                    var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                    offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
                    offsetMatrix.toArray(this.boneMatrices, b * 16);
                }
                if (this.useVertexTexture) {
                    this.boneTexture.needsUpdate = true;
                }
            };
        }(),
        clone: function() {
            return new Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
        }
    });
    function SkinnedMesh(geometry, material, useVertexTexture) {
        Mesh.call(this, geometry, material);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
        var bones = [];
        if (this.geometry && this.geometry.bones !== undefined) {
            var bone, gbone;
            for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
                gbone = this.geometry.bones[b];
                bone = new Bone();
                bones.push(bone);
                bone.name = gbone.name;
                bone.position.fromArray(gbone.pos);
                bone.quaternion.fromArray(gbone.rotq);
                if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);
            }
            for (var b = 0, bl = this.geometry.bones.length; b < bl; ++b) {
                gbone = this.geometry.bones[b];
                if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {
                    bones[gbone.parent].add(bones[b]);
                } else {
                    this.add(bones[b]);
                }
            }
        }
        this.normalizeSkinWeights();
        this.updateMatrixWorld(true);
        this.bind(new Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
    }
    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: true,
        bind: function(skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.getInverse(bindMatrix);
        },
        pose: function() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function() {
            if (this.geometry && this.geometry.isGeometry) {
                for (var i = 0; i < this.geometry.skinWeights.length; i++) {
                    var sw = this.geometry.skinWeights[i];
                    var scale = 1 / sw.lengthManhattan();
                    if (scale !== Infinity) {
                        sw.multiplyScalar(scale);
                    } else {
                        sw.set(1, 0, 0, 0);
                    }
                }
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new Vector4();
                var skinWeight = this.geometry.attributes.skinWeight;
                for (var i = 0; i < skinWeight.count; i++) {
                    vec.x = skinWeight.getX(i);
                    vec.y = skinWeight.getY(i);
                    vec.z = skinWeight.getZ(i);
                    vec.w = skinWeight.getW(i);
                    var scale = 1 / vec.lengthManhattan();
                    if (scale !== Infinity) {
                        vec.multiplyScalar(scale);
                    } else {
                        vec.set(1, 0, 0, 0);
                    }
                    skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
            }
        },
        updateMatrixWorld: function(force) {
            Mesh.prototype.updateMatrixWorld.call(this, true);
            if (this.bindMode === "attached") {
                this.bindMatrixInverse.getInverse(this.matrixWorld);
            } else if (this.bindMode === "detached") {
                this.bindMatrixInverse.getInverse(this.bindMatrix);
            } else {
                console.warn("SZX3D.SkinnedMesh unrecognized bindMode: " + this.bindMode);
            }
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
        }
    });
    function LOD() {
        Object3D.call(this);
        this.type = "LOD";
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        });
    }
    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source, false);
            var levels = source.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        },
        addLevel: function(object, distance) {
            if (distance === undefined) distance = 0;
            distance = Math.abs(distance);
            var levels = this.levels;
            for (var l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                    break;
                }
            }
            levels.splice(l, 0, {
                distance: distance,
                object: object
            });
            this.add(object);
        },
        getObjectForDistance: function(distance) {
            var levels = this.levels;
            for (var i = 1, l = levels.length; i < l; i++) {
                if (distance < levels[i].distance) {
                    break;
                }
            }
            return levels[i - 1].object;
        },
        raycast: function() {
            var matrixPosition = new Vector3();
            return function raycast(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            };
        }(),
        update: function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function update(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                    v1.setFromMatrixPosition(camera.matrixWorld);
                    v2.setFromMatrixPosition(this.matrixWorld);
                    var distance = v1.distanceTo(v2);
                    levels[0].object.visible = true;
                    for (var i = 1, l = levels.length; i < l; i++) {
                        if (distance >= levels[i].distance) {
                            levels[i - 1].object.visible = false;
                            levels[i].object.visible = true;
                        } else {
                            break;
                        }
                    }
                    for (;i < l; i++) {
                        levels[i].object.visible = false;
                    }
                }
            };
        }(),
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            var levels = this.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    });
    function Sprite(material) {
        Object3D.call(this);
        this.type = "Sprite";
        this.material = material !== undefined ? material : new SpriteMaterial();
    }
    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: true,
        raycast: function() {
            var matrixPosition = new Vector3();
            return function raycast(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
                var guessSizeSq = this.scale.x * this.scale.y / 4;
                if (distanceSq > guessSizeSq) {
                    return;
                }
                intersects.push({
                    distance: Math.sqrt(distanceSq),
                    point: this.position,
                    face: null,
                    object: this
                });
            };
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this);
        }
    });
    function LensFlare(texture, size, distance, blending, color) {
        Object3D.call(this);
        this.lensFlares = [];
        this.positionScreen = new Vector3();
        this.customUpdateCallback = undefined;
        if (texture !== undefined) {
            this.add(texture, size, distance, blending, color);
        }
    }
    LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LensFlare,
        isLensFlare: true,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source);
            this.positionScreen.copy(source.positionScreen);
            this.customUpdateCallback = source.customUpdateCallback;
            for (var i = 0, l = source.lensFlares.length; i < l; i++) {
                this.lensFlares.push(source.lensFlares[i]);
            }
            return this;
        },
        add: function(texture, size, distance, blending, color, opacity) {
            if (size === undefined) size = -1;
            if (distance === undefined) distance = 0;
            if (opacity === undefined) opacity = 1;
            if (color === undefined) color = new Color(16777215);
            if (blending === undefined) blending = NormalBlending;
            distance = Math.min(distance, Math.max(0, distance));
            this.lensFlares.push({
                texture: texture,
                size: size,
                distance: distance,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: opacity,
                color: color,
                blending: blending
            });
        },
        updateLensFlares: function() {
            var f, fl = this.lensFlares.length;
            var flare;
            var vecX = -this.positionScreen.x * 2;
            var vecY = -this.positionScreen.y * 2;
            for (f = 0; f < fl; f++) {
                flare = this.lensFlares[f];
                flare.x = this.positionScreen.x + vecX * flare.distance;
                flare.y = this.positionScreen.y + vecY * flare.distance;
                flare.wantedRotation = flare.x * Math.PI * .25;
                flare.rotation += (flare.wantedRotation - flare.rotation) * .25;
            }
        }
    });
    function StereoCamera() {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = .064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
    }
    Object.assign(StereoCamera.prototype, {
        update: function() {
            var instance, focus, fov, aspect, near, far, zoom;
            var eyeRight = new Matrix4();
            var eyeLeft = new Matrix4();
            return function update(camera) {
                var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom;
                if (needsUpdate) {
                    instance = this;
                    focus = camera.focus;
                    fov = camera.fov;
                    aspect = camera.aspect * this.aspect;
                    near = camera.near;
                    far = camera.far;
                    zoom = camera.zoom;
                    var projectionMatrix = camera.projectionMatrix.clone();
                    var eyeSep = this.eyeSep / 2;
                    var eyeSepOnProjection = eyeSep * near / focus;
                    var ymax = near * Math.tan(_Math.DEG2RAD * fov * .5) / zoom;
                    var xmin, xmax;
                    eyeLeft.elements[12] = -eyeSep;
                    eyeRight.elements[12] = eyeSep;
                    xmin = -ymax * aspect + eyeSepOnProjection;
                    xmax = ymax * aspect + eyeSepOnProjection;
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                    this.cameraL.projectionMatrix.copy(projectionMatrix);
                    xmin = -ymax * aspect - eyeSepOnProjection;
                    xmax = ymax * aspect - eyeSepOnProjection;
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            };
        }()
    });
    function CubeCamera(near, far, cubeResolution) {
        Object3D.call(this);
        this.type = "CubeCamera";
        var fov = 90, aspect = 1;
        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
        var options = {
            format: RGBFormat,
            magFilter: LinearFilter,
            minFilter: LinearFilter
        };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
        this.updateCubeMap = function(renderer, scene, forceClear) {
            if (this.parent === null) this.updateMatrixWorld();
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderTarget.activeCubeFace = 0;
            renderer.render(scene, cameraPX, renderTarget, forceClear);
            renderTarget.activeCubeFace = 1;
            renderer.render(scene, cameraNX, renderTarget, forceClear);
            renderTarget.activeCubeFace = 2;
            renderer.render(scene, cameraPY, renderTarget, forceClear);
            renderTarget.activeCubeFace = 3;
            renderer.render(scene, cameraNY, renderTarget, forceClear);
            renderTarget.activeCubeFace = 4;
            renderer.render(scene, cameraPZ, renderTarget, forceClear);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderTarget.activeCubeFace = 5;
            renderer.render(scene, cameraNZ, renderTarget, forceClear);
            renderer.setRenderTarget(null);
        };
    }
    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;
    function Light(color, intensity) {
        Object3D.call(this);
        this.type = "Light";
        this.color = new Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.receiveShadow = undefined;
    }
    Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: true,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined) data.object.distance = this.distance;
            if (this.angle !== undefined) data.object.angle = this.angle;
            if (this.decay !== undefined) data.object.decay = this.decay;
            if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
            if (this.target !== undefined) data.object.target = this.target.uuid;
            if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
            return data;
        }
    });
    function LightShadow(camera) {
        this.camera = camera;
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.matrix = new Matrix4();
    }
    Object.assign(LightShadow.prototype, {
        copy: function(source) {
            this.camera = source.camera.clone();
            this.bias = source.bias;
            this.radius = source.radius;
            this.mapSize.copy(source.mapSize);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        toJSON: function() {
            var object = {};
            if (this.bias !== 0) object.bias = this.bias;
            if (this.radius !== 1) object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;
            return object;
        }
    });
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = "AmbientLight";
        this.castShadow = undefined;
    }
    AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: true
    });
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity);
        this.type = "HemisphereLight";
        this.castShadow = undefined;
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.groundColor.copy(source.groundColor);
            return this;
        }
    });
    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity);
        this.type = "RectAreaLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.width = width !== undefined ? width : 10;
        this.height = height !== undefined ? height : 10;
    }
    RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: RectAreaLight,
        isRectAreaLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.width = source.width;
            this.height = source.height;
            return this;
        },
        toJSON: function(meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            data.object.width = this.width;
            data.object.height = this.height;
            return data;
        }
    });
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity);
        this.type = "PointLight";
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * 4 * Math.PI;
            },
            set: function(power) {
                this.intensity = power / (4 * Math.PI);
            }
        });
        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, .5, 500));
    }
    PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, .5, 500));
    }
    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow
    });
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = "DirectionalLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
    }
    DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, .5, 500));
    }
    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: true,
        update: function(light) {
            var fov = _Math.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || 500;
            var camera = this.camera;
            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
        }
    });
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity);
        this.type = "SpotLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / Math.PI;
            }
        });
        this.distance = distance !== undefined ? distance : 0;
        this.angle = angle !== undefined ? angle : Math.PI / 3;
        this.penumbra = penumbra !== undefined ? penumbra : 0;
        this.decay = decay !== undefined ? decay : 1;
        this.shadow = new SpotLightShadow();
    }
    SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    var Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
            if (this.enabled === false) return;
            this.files[key] = file;
        },
        get: function(key) {
            if (this.enabled === false) return;
            return this.files[key];
        },
        remove: function(key) {
            delete this.files[key];
        },
        clear: function() {
            this.files = {};
        }
    };
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this;
        var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) {
                    scope.onStart(url, itemsLoaded, itemsTotal);
                }
            }
            isLoading = true;
        };
        this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) {
                scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) {
                    scope.onLoad();
                }
            }
        };
        this.itemError = function(url) {
            if (scope.onError !== undefined) {
                scope.onError(url);
            }
        };
    }
    var DefaultLoadingManager = new LoadingManager();
    function FileLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(FileLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            if (url === undefined) url = "";
            if (this.path !== undefined) url = this.path + url;
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match(dataUriRegex);
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data);
                if (isBase64) data = window.atob(data);
                try {
                    var response;
                    var responseType = (this.responseType || "").toLowerCase();
                    switch (responseType) {
                      case "arraybuffer":
                      case "blob":
                        response = new ArrayBuffer(data.length);
                        var view = new Uint8Array(response);
                        for (var i = 0; i < data.length; i++) {
                            view[i] = data.charCodeAt(i);
                        }
                        if (responseType === "blob") {
                            response = new Blob([ response ], {
                                type: mimeType
                            });
                        }
                        break;

                      case "document":
                        var parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;

                      case "json":
                        response = JSON.parse(data);
                        break;

                      default:
                        response = data;
                        break;
                    }
                    window.setTimeout(function() {
                        if (onLoad) onLoad(response);
                        scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    window.setTimeout(function() {
                        if (onError) onError(error);
                        scope.manager.itemError(url);
                    }, 0);
                }
            } else {
                var request = new XMLHttpRequest();
                request.open("GET", url, true);
                request.addEventListener("load", function(event) {
                    var response = event.target.response;
                    Cache.add(url, response);
                    if (this.status === 200) {
                        if (onLoad) onLoad(response);
                        scope.manager.itemEnd(url);
                    } else if (this.status === 0) {
                        console.warn("SZX3D.FileLoader: HTTP Status 0 received.");
                        if (onLoad) onLoad(response);
                        scope.manager.itemEnd(url);
                    } else {
                        if (onError) onError(event);
                        scope.manager.itemError(url);
                    }
                }, false);
                if (onProgress !== undefined) {
                    request.addEventListener("progress", function(event) {
                        onProgress(event);
                    }, false);
                }
                request.addEventListener("error", function(event) {
                    if (onError) onError(event);
                    scope.manager.itemError(url);
                }, false);
                if (this.responseType !== undefined) request.responseType = this.responseType;
                if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
                if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : "text/plain");
                request.send(null);
            }
            scope.manager.itemStart(url);
            return request;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        },
        setResponseType: function(value) {
            this.responseType = value;
            return this;
        },
        setWithCredentials: function(value) {
            this.withCredentials = value;
            return this;
        },
        setMimeType: function(value) {
            this.mimeType = value;
            return this;
        }
    });
    function AudioLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(AudioLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var loader = new FileLoader(this.manager);
            loader.setResponseType("arraybuffer");
            loader.load(url, function(buffer) {
                var context = AudioContext.getContext();
                context.decodeAudioData(buffer, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    });
    function MaterialLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.textures = {};
    }
    Object.assign(MaterialLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        setTextures: function(value) {
            this.textures = value;
        },
        parse: function(json) {
            var textures = this.textures;
            function getTexture(name) {
                if (textures[name] === undefined) {
                    console.warn("SZX3D.MaterialLoader: Undefined texture", name);
                }
                return textures[name];
            }
            var material = new Materials[json.type]();
            if (json.uuid !== undefined) material.uuid = json.uuid;
            if (json.name !== undefined) material.name = json.name;
            if (json.color !== undefined) material.color.setHex(json.color);
            if (json.roughness !== undefined) material.roughness = json.roughness;
            if (json.metalness !== undefined) material.metalness = json.metalness;
            if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
            if (json.specular !== undefined) material.specular.setHex(json.specular);
            if (json.shininess !== undefined) material.shininess = json.shininess;
            if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
            if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
            if (json.uniforms !== undefined) material.uniforms = json.uniforms;
            if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
            if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
            if (json.fog !== undefined) material.fog = json.fog;
            if (json.shading !== undefined) material.shading = json.shading;
            if (json.blending !== undefined) material.blending = json.blending;
            if (json.side !== undefined) material.side = json.side;
            if (json.opacity !== undefined) material.opacity = json.opacity;
            if (json.transparent !== undefined) material.transparent = json.transparent;
            if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined) material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
            if (json.wireframe !== undefined) material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.skinning !== undefined) material.skinning = json.skinning;
            if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
            if (json.size !== undefined) material.size = json.size;
            if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
            if (json.map !== undefined) material.map = getTexture(json.map);
            if (json.alphaMap !== undefined) {
                material.alphaMap = getTexture(json.alphaMap);
                material.transparent = true;
            }
            if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
            if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                    normalScale = [ normalScale, normalScale ];
                }
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
            if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
            if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
            if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
            if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
            if (json.materials !== undefined) {
                for (var i = 0, l = json.materials.length; i < l; i++) {
                    material.materials.push(this.parse(json.materials[i]));
                }
            }
            return material;
        }
    });
    function ImageLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(ImageLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            if (url === undefined) url = "";
            if (this.path !== undefined) url = this.path + url;
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            image.addEventListener("load", function() {
                Cache.add(url, this);
                if (onLoad) onLoad(this);
                scope.manager.itemEnd(url);
            }, false);
            image.addEventListener("error", function(event) {
                if (onError) onError(event);
                scope.manager.itemError(url);
            }, false);
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
            scope.manager.itemStart(url);
            image.src = url;
            return image;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });
    function TextureLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(TextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var texture = new Texture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function(image) {
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.image = image;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                    onLoad(texture);
                }
            }, onProgress, onError);
            return texture;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });
    function Loader() {
        this.onLoadStart = function() {};
        this.onLoadProgress = function() {};
        this.onLoadComplete = function() {};
    }
    Loader.prototype = {
        constructor: Loader,
        crossOrigin: undefined,
        extractUrlBase: function(url) {
            var parts = url.split("/");
            if (parts.length === 1) return "./";
            parts.pop();
            return parts.join("/") + "/";
        },
        initMaterials: function(materials, texturePath, crossOrigin) {
            var array = [];
            for (var i = 0; i < materials.length; ++i) {
                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            }
            return array;
        },
        createMaterial: function() {
            var BlendingMode = {
                NoBlending: NoBlending,
                NormalBlending: NormalBlending,
                AdditiveBlending: AdditiveBlending,
                SubtractiveBlending: SubtractiveBlending,
                MultiplyBlending: MultiplyBlending,
                CustomBlending: CustomBlending
            };
            var color, textureLoader, materialLoader;
            return function createMaterial(m, texturePath, crossOrigin) {
                if (color === undefined) color = new Color();
                if (textureLoader === undefined) textureLoader = new TextureLoader();
                if (materialLoader === undefined) materialLoader = new MaterialLoader();
                var textures = {};
                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                    var fullPath = texturePath + path;
                    var loader = Loader.Handlers.get(fullPath);
                    var texture;
                    if (loader !== null) {
                        texture = loader.load(fullPath);
                    } else {
                        textureLoader.setCrossOrigin(crossOrigin);
                        texture = textureLoader.load(fullPath);
                    }
                    if (repeat !== undefined) {
                        texture.repeat.fromArray(repeat);
                        if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
                        if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
                    }
                    if (offset !== undefined) {
                        texture.offset.fromArray(offset);
                    }
                    if (wrap !== undefined) {
                        if (wrap[0] === "repeat") texture.wrapS = RepeatWrapping;
                        if (wrap[0] === "mirror") texture.wrapS = MirroredRepeatWrapping;
                        if (wrap[1] === "repeat") texture.wrapT = RepeatWrapping;
                        if (wrap[1] === "mirror") texture.wrapT = MirroredRepeatWrapping;
                    }
                    if (anisotropy !== undefined) {
                        texture.anisotropy = anisotropy;
                    }
                    var uuid = _Math.generateUUID();
                    textures[uuid] = texture;
                    return uuid;
                }
                var json = {
                    uuid: _Math.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var name in m) {
                    var value = m[name];
                    switch (name) {
                      case "DbgColor":
                      case "DbgIndex":
                      case "opticalDensity":
                      case "illumination":
                        break;

                      case "DbgName":
                        json.name = value;
                        break;

                      case "blending":
                        json.blending = BlendingMode[value];
                        break;

                      case "colorAmbient":
                      case "mapAmbient":
                        console.warn("SZX3D.Loader.createMaterial:", name, "is no longer supported.");
                        break;

                      case "colorDiffuse":
                        json.color = color.fromArray(value).getHex();
                        break;

                      case "colorSpecular":
                        json.specular = color.fromArray(value).getHex();
                        break;

                      case "colorEmissive":
                        json.emissive = color.fromArray(value).getHex();
                        break;

                      case "specularCoef":
                        json.shininess = value;
                        break;

                      case "shading":
                        if (value.toLowerCase() === "basic") json.type = "MeshBasicMaterial";
                        if (value.toLowerCase() === "phong") json.type = "MeshPhongMaterial";
                        if (value.toLowerCase() === "standard") json.type = "MeshStandardMaterial";
                        break;

                      case "mapDiffuse":
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;

                      case "mapDiffuseRepeat":
                      case "mapDiffuseOffset":
                      case "mapDiffuseWrap":
                      case "mapDiffuseAnisotropy":
                        break;

                      case "mapEmissive":
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;

                      case "mapEmissiveRepeat":
                      case "mapEmissiveOffset":
                      case "mapEmissiveWrap":
                      case "mapEmissiveAnisotropy":
                        break;

                      case "mapLight":
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;

                      case "mapLightRepeat":
                      case "mapLightOffset":
                      case "mapLightWrap":
                      case "mapLightAnisotropy":
                        break;

                      case "mapAO":
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;

                      case "mapAORepeat":
                      case "mapAOOffset":
                      case "mapAOWrap":
                      case "mapAOAnisotropy":
                        break;

                      case "mapBump":
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;

                      case "mapBumpScale":
                        json.bumpScale = value;
                        break;

                      case "mapBumpRepeat":
                      case "mapBumpOffset":
                      case "mapBumpWrap":
                      case "mapBumpAnisotropy":
                        break;

                      case "mapNormal":
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;

                      case "mapNormalFactor":
                        json.normalScale = [ value, value ];
                        break;

                      case "mapNormalRepeat":
                      case "mapNormalOffset":
                      case "mapNormalWrap":
                      case "mapNormalAnisotropy":
                        break;

                      case "mapSpecular":
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;

                      case "mapSpecularRepeat":
                      case "mapSpecularOffset":
                      case "mapSpecularWrap":
                      case "mapSpecularAnisotropy":
                        break;

                      case "mapMetalness":
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;

                      case "mapMetalnessRepeat":
                      case "mapMetalnessOffset":
                      case "mapMetalnessWrap":
                      case "mapMetalnessAnisotropy":
                        break;

                      case "mapRoughness":
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;

                      case "mapRoughnessRepeat":
                      case "mapRoughnessOffset":
                      case "mapRoughnessWrap":
                      case "mapRoughnessAnisotropy":
                        break;

                      case "mapAlpha":
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;

                      case "mapAlphaRepeat":
                      case "mapAlphaOffset":
                      case "mapAlphaWrap":
                      case "mapAlphaAnisotropy":
                        break;

                      case "flipSided":
                        json.side = BackSide;
                        break;

                      case "doubleSided":
                        json.side = DoubleSide;
                        break;

                      case "transparency":
                        console.warn("SZX3D.Loader.createMaterial: transparency has been renamed to opacity");
                        json.opacity = value;
                        break;

                      case "depthTest":
                      case "depthWrite":
                      case "colorWrite":
                      case "opacity":
                      case "reflectivity":
                      case "transparent":
                      case "visible":
                      case "wireframe":
                        json[name] = value;
                        break;

                      case "vertexColors":
                        if (value === true) json.vertexColors = VertexColors;
                        if (value === "face") json.vertexColors = FaceColors;
                        break;

                      default:
                        console.error("SZX3D.Loader.createMaterial: Unsupported", name, value);
                        break;
                    }
                }
                if (json.type === "MeshBasicMaterial") delete json.emissive;
                if (json.type !== "MeshPhongMaterial") delete json.specular;
                if (json.opacity < 1) json.transparent = true;
                materialLoader.setTextures(textures);
                return materialLoader.parse(json);
            };
        }()
    };
    Loader.Handlers = {
        handlers: [],
        add: function(regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function(file) {
            var handlers = this.handlers;
            for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.test(file)) {
                    return loader;
                }
            }
            return null;
        }
    };
    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * .5;
        var v1 = (p3 - p1) * .5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    function Curve() {}
    Curve.prototype = {
        constructor: Curve,
        getPoint: function(t) {
            console.warn("SZX3D.Curve: Warning, getPoint() not implemented!");
            return null;
        },
        getPointAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        },
        getPoints: function(divisions) {
            if (isNaN(divisions)) divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
            }
            return points;
        },
        getSpacedPoints: function(divisions) {
            if (isNaN(divisions)) divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
            }
            return points;
        },
        getLength: function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        getLengths: function(divisions) {
            if (isNaN(divisions)) divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200;
            if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
                return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            var cache = [];
            var current, last = this.getPoint(0);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache;
        },
        updateArcLengths: function() {
            this.needsUpdate = true;
            this.getLengths();
        },
        getUtoTmapping: function(u, distance) {
            var arcLengths = this.getLengths();
            var i = 0, il = arcLengths.length;
            var targetArcLength;
            if (distance) {
                targetArcLength = distance;
            } else {
                targetArcLength = u * arcLengths[il - 1];
            }
            var low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                } else if (comparison > 0) {
                    high = i - 1;
                } else {
                    high = i;
                    break;
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                var t = i / (il - 1);
                return t;
            }
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            var t = (i + segmentFraction) / (il - 1);
            return t;
        },
        getTangent: function(t) {
            var delta = 1e-4;
            var t1 = t - delta;
            var t2 = t + delta;
            if (t1 < 0) t1 = 0;
            if (t2 > 1) t2 = 1;
            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);
            var vec = pt2.clone().sub(pt1);
            return vec.normalize();
        },
        getTangentAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },
        computeFrenetFrames: function(segments, closed) {
            var normal = new Vector3();
            var tangents = [];
            var normals = [];
            var binormals = [];
            var vec = new Vector3();
            var mat = new Matrix4();
            var i, u, theta;
            for (i = 0; i <= segments; i++) {
                u = i / segments;
                tangents[i] = this.getTangentAt(u);
                tangents[i].normalize();
            }
            normals[0] = new Vector3();
            binormals[0] = new Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs(tangents[0].x);
            var ty = Math.abs(tangents[0].y);
            var tz = Math.abs(tangents[0].z);
            if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
            }
            if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
            }
            if (tz <= min) {
                normal.set(0, 0, 1);
            }
            vec.crossVectors(tangents[0], normal).normalize();
            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]);
            for (i = 1; i <= segments; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
            if (closed === true) {
                theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                    theta = -theta;
                }
                for (i = 1; i <= segments; i++) {
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        }
    };
    function LineCurve(v1, v2) {
        this.v1 = v1;
        this.v2 = v2;
    }
    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;
    LineCurve.prototype.isLineCurve = true;
    LineCurve.prototype.getPoint = function(t) {
        if (t === 1) {
            return this.v2.clone();
        }
        var point = this.v2.clone().sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
        return point;
    };
    LineCurve.prototype.getPointAt = function(u) {
        return this.getPoint(u);
    };
    LineCurve.prototype.getTangent = function(t) {
        var tangent = this.v2.clone().sub(this.v1);
        return tangent.normalize();
    };
    function CurvePath() {
        this.curves = [];
        this.autoClose = false;
    }
    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function(curve) {
            this.curves.push(curve);
        },
        closePath: function() {
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
                this.curves.push(new LineCurve(endPoint, startPoint));
            }
        },
        getPoint: function(t) {
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;
            while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        },
        getLength: function() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        updateArcLengths: function() {
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getLengths();
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
            }
            var lengths = [], sums = 0;
            for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        },
        getSpacedPoints: function(divisions) {
            if (isNaN(divisions)) divisions = 40;
            var points = [];
            for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
            }
            if (this.autoClose) {
                points.push(points[0]);
            }
            return points;
        },
        getPoints: function(divisions) {
            divisions = divisions || 12;
            var points = [], last;
            for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                    var point = pts[j];
                    if (last && last.equals(point)) continue;
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
            }
            return points;
        },
        createPointsGeometry: function(divisions) {
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },
        createSpacedPointsGeometry: function(divisions) {
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },
        createGeometry: function(points) {
            var geometry = new Geometry();
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        }
    });
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation || 0;
    }
    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;
    EllipseCurve.prototype.isEllipseCurve = true;
    EllipseCurve.prototype.getPoint = function(t) {
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0) deltaAngle += twoPi;
        while (deltaAngle > twoPi) deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
                deltaAngle = 0;
            } else {
                deltaAngle = twoPi;
            }
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
                deltaAngle = -twoPi;
            } else {
                deltaAngle = deltaAngle - twoPi;
            }
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            var cos = Math.cos(this.aRotation);
            var sin = Math.sin(this.aRotation);
            var tx = x - this.aX;
            var ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return new Vector2(x, y);
    };
    function SplineCurve(points) {
        this.points = points === undefined ? [] : points;
    }
    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;
    SplineCurve.prototype.isSplineCurve = true;
    SplineCurve.prototype.getPoint = function(t) {
        var points = this.points;
        var point = (points.length - 1) * t;
        var intPoint = Math.floor(point);
        var weight = point - intPoint;
        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var point1 = points[intPoint];
        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        return new Vector2(CatmullRom(weight, point0.x, point1.x, point2.x, point3.x), CatmullRom(weight, point0.y, point1.y, point2.y, point3.y));
    };
    function CubicBezierCurve(v0, v1, v2, v3) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    CubicBezierCurve.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        return new Vector2(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    };
    function QuadraticBezierCurve(v0, v1, v2) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    QuadraticBezierCurve.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        return new Vector2(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    };
    var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
        fromPoints: function(vectors) {
            this.moveTo(vectors[0].x, vectors[0].y);
            for (var i = 1, l = vectors.length; i < l; i++) {
                this.lineTo(vectors[i].x, vectors[i].y);
            }
        },
        moveTo: function(x, y) {
            this.currentPoint.set(x, y);
        },
        lineTo: function(x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        },
        splineThru: function(pts) {
            var npts = [ this.currentPoint.clone() ].concat(pts);
            var curve = new SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
        },
        arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },
        absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        }
    });
    function Path(points) {
        CurvePath.call(this);
        this.currentPoint = new Vector2();
        if (points) {
            this.fromPoints(points);
        }
    }
    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;
    function Shape() {
        Path.apply(this, arguments);
        this.holes = [];
    }
    Shape.prototype = Object.assign(Object.create(PathPrototype), {
        constructor: Shape,
        getPointsHoles: function(divisions) {
            var holesPts = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
            }
            return holesPts;
        },
        extractAllPoints: function(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        extractPoints: function(divisions) {
            return this.extractAllPoints(divisions);
        }
    });
    function ShapePath() {
        this.subPaths = [];
        this.currentPath = null;
    }
    ShapePath.prototype = {
        moveTo: function(x, y) {
            this.currentPath = new Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
        },
        lineTo: function(x, y) {
            this.currentPath.lineTo(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },
        splineThru: function(pts) {
            this.currentPath.splineThru(pts);
        },
        toShapes: function(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for (var i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i];
                    var tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q];
                            edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];
                            edgeDy = -edgeDy;
                        }
                        if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x) return true;
                        } else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0) return true;
                            if (perpEdge < 0) continue;
                            inside = !inside;
                        }
                    } else {
                        if (inPt.y !== edgeLowPt.y) continue;
                        if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
                    }
                }
                return inside;
            }
            var isClockWise = ShapeUtils.isClockWise;
            var subPaths = this.subPaths;
            if (subPaths.length === 0) return [];
            if (noHoles === true) return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                    newShapes[mainIdx] = {
                        s: new Shape(),
                        p: tmpPoints
                    };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst) mainIdx++;
                    newShapeHoles[mainIdx] = [];
                } else {
                    newShapeHoles[mainIdx].push({
                        h: tmpPath,
                        p: tmpPoints[0]
                    });
                }
            }
            if (!newShapes[0]) return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    betterShapeHoles[sIdx] = [];
                }
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    var sho = newShapeHoles[sIdx];
                    for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                        var ho = sho[hIdx];
                        var hole_unassigned = true;
                        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                if (sIdx !== s2Idx) toChange.push({
                                    froms: sIdx,
                                    tos: s2Idx,
                                    hole: hIdx
                                });
                                if (hole_unassigned) {
                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                } else {
                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {
                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                if (toChange.length > 0) {
                    if (!ambiguous) newShapeHoles = betterShapeHoles;
                }
            }
            var tmpHoles;
            for (var i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }
            return shapes;
        }
    };
    function Font(data) {
        this.data = data;
    }
    Object.assign(Font.prototype, {
        isFont: true,
        generateShapes: function(text, size, divisions) {
            function createPaths(text) {
                var chars = String(text).split("");
                var scale = size / data.resolution;
                var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
                var offsetX = 0, offsetY = 0;
                var paths = [];
                for (var i = 0; i < chars.length; i++) {
                    var char = chars[i];
                    if (char === "\n") {
                        offsetX = 0;
                        offsetY -= line_height;
                    } else {
                        var ret = createPath(char, scale, offsetX, offsetY);
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
                return paths;
            }
            function createPath(c, scale, offsetX, offsetY) {
                var glyph = data.glyphs[c] || data.glyphs["?"];
                if (!glyph) return;
                var path = new ShapePath();
                var pts = [];
                var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
                if (glyph.o) {
                    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
                    for (var i = 0, l = outline.length; i < l; ) {
                        var action = outline[i++];
                        switch (action) {
                          case "m":
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;

                          case "l":
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;

                          case "q":
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            laste = pts[pts.length - 1];
                            if (laste) {
                                cpx0 = laste.x;
                                cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    QuadraticBezier(t, cpx0, cpx1, cpx);
                                    QuadraticBezier(t, cpy0, cpy1, cpy);
                                }
                            }
                            break;

                          case "b":
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            laste = pts[pts.length - 1];
                            if (laste) {
                                cpx0 = laste.x;
                                cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    CubicBezier(t, cpx0, cpx1, cpx2, cpx);
                                    CubicBezier(t, cpy0, cpy1, cpy2, cpy);
                                }
                            }
                            break;
                        }
                    }
                }
                return {
                    offsetX: glyph.ha * scale,
                    path: path
                };
            }
            if (size === undefined) size = 100;
            if (divisions === undefined) divisions = 4;
            var data = this.data;
            var paths = createPaths(text);
            var shapes = [];
            for (var p = 0, pl = paths.length; p < pl; p++) {
                Array.prototype.push.apply(shapes, paths[p].toShapes());
            }
            return shapes;
        }
    });
    function FontLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(FontLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(this.manager);
            loader.load(url, function(text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn("SZX3D.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad) onLoad(font);
            }, onProgress, onError);
        },
        parse: function(json) {
            return new Font(json);
        }
    });
    function JSONLoader(manager) {
        if (typeof manager === "boolean") {
            console.warn("SZX3D.JSONLoader: showStatus parameter has been removed from constructor.");
            manager = undefined;
        }
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.withCredentials = false;
    }
    Object.assign(JSONLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var texturePath = this.texturePath && typeof this.texturePath === "string" ? this.texturePath : Loader.prototype.extractUrlBase(url);
            var loader = new FileLoader(this.manager);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function(text) {
                var json = JSON.parse(text);
                var metadata = json.metadata;
                if (metadata !== undefined) {
                    var type = metadata.type;
                    if (type !== undefined) {
                        if (type.toLowerCase() === "object") {
                            console.error("SZX3D.JSONLoader: " + url + " should be loaded with SZX3D.ObjectLoader instead.");
                            return;
                        }
                        if (type.toLowerCase() === "scene") {
                            console.error("SZX3D.JSONLoader: " + url + " should be loaded with SZX3D.SceneLoader instead.");
                            return;
                        }
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        parse: function(json, texturePath) {
            var geometry = new Geometry(), scale = json.scale !== undefined ? 1 / json.scale : 1;
            parseModel(scale);
            parseSkin();
            parseMorphing(scale);
            parseAnimations();
            geometry.computeFaceNormals();
            geometry.computeBoundingSphere();
            function parseModel(scale) {
                function isBitSet(value, position) {
                    return value & 1 << position;
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
                if (json.uvs !== undefined) {
                    for (i = 0; i < json.uvs.length; i++) {
                        if (json.uvs[i].length) nUvLayers++;
                    }
                    for (i = 0; i < nUvLayers; i++) {
                        geometry.faceVertexUvs[i] = [];
                    }
                }
                offset = 0;
                zLength = vertices.length;
                while (offset < zLength) {
                    vertex = new Vector3();
                    vertex.x = vertices[offset++] * scale;
                    vertex.y = vertices[offset++] * scale;
                    vertex.z = vertices[offset++] * scale;
                    geometry.vertices.push(vertex);
                }
                offset = 0;
                zLength = faces.length;
                while (offset < zLength) {
                    type = faces[offset++];
                    isQuad = isBitSet(type, 0);
                    hasMaterial = isBitSet(type, 1);
                    hasFaceVertexUv = isBitSet(type, 3);
                    hasFaceNormal = isBitSet(type, 4);
                    hasFaceVertexNormal = isBitSet(type, 5);
                    hasFaceColor = isBitSet(type, 6);
                    hasFaceVertexColor = isBitSet(type, 7);
                    if (isQuad) {
                        faceA = new Face3();
                        faceA.a = faces[offset];
                        faceA.b = faces[offset + 1];
                        faceA.c = faces[offset + 3];
                        faceB = new Face3();
                        faceB.a = faces[offset + 1];
                        faceB.b = faces[offset + 2];
                        faceB.c = faces[offset + 3];
                        offset += 4;
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                geometry.faceVertexUvs[i][fi + 1] = [];
                                for (j = 0; j < 4; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new Vector2(u, v);
                                    if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                                    if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            faceB.normal.copy(faceA.normal);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 4; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                if (i !== 2) faceA.vertexNormals.push(normal);
                                if (i !== 0) faceB.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            faceA.color.setHex(hex);
                            faceB.color.setHex(hex);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 4; i++) {
                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];
                                if (i !== 2) faceA.vertexColors.push(new Color(hex));
                                if (i !== 0) faceB.vertexColors.push(new Color(hex));
                            }
                        }
                        geometry.faces.push(faceA);
                        geometry.faces.push(faceB);
                    } else {
                        face = new Face3();
                        face.a = faces[offset++];
                        face.b = faces[offset++];
                        face.c = faces[offset++];
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            face.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                for (j = 0; j < 3; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new Vector2(u, v);
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 3; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                face.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            face.color.setHex(colors[colorIndex]);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 3; i++) {
                                colorIndex = faces[offset++];
                                face.vertexColors.push(new Color(colors[colorIndex]));
                            }
                        }
                        geometry.faces.push(face);
                    }
                }
            }
            function parseSkin() {
                var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;
                if (json.skinWeights) {
                    for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                        var x = json.skinWeights[i];
                        var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
                        var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
                        var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                        geometry.skinWeights.push(new Vector4(x, y, z, w));
                    }
                }
                if (json.skinIndices) {
                    for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                        var a = json.skinIndices[i];
                        var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
                        var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
                        var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                        geometry.skinIndices.push(new Vector4(a, b, c, d));
                    }
                }
                geometry.bones = json.bones;
                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                    console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
                }
            }
            function parseMorphing(scale) {
                if (json.morphTargets !== undefined) {
                    for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                        geometry.morphTargets[i] = {};
                        geometry.morphTargets[i].name = json.morphTargets[i].name;
                        geometry.morphTargets[i].vertices = [];
                        var dstVertices = geometry.morphTargets[i].vertices;
                        var srcVertices = json.morphTargets[i].vertices;
                        for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                            var vertex = new Vector3();
                            vertex.x = srcVertices[v] * scale;
                            vertex.y = srcVertices[v + 1] * scale;
                            vertex.z = srcVertices[v + 2] * scale;
                            dstVertices.push(vertex);
                        }
                    }
                }
                if (json.morphColors !== undefined && json.morphColors.length > 0) {
                    console.warn('SZX3D.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var faces = geometry.faces;
                    var morphColors = json.morphColors[0].colors;
                    for (var i = 0, l = faces.length; i < l; i++) {
                        faces[i].color.fromArray(morphColors, i * 3);
                    }
                }
            }
            function parseAnimations() {
                var outputAnimations = [];
                var animations = [];
                if (json.animation !== undefined) {
                    animations.push(json.animation);
                }
                if (json.animations !== undefined) {
                    if (json.animations.length) {
                        animations = animations.concat(json.animations);
                    } else {
                        animations.push(json.animations);
                    }
                }
                for (var i = 0; i < animations.length; i++) {
                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    if (clip) outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                if (outputAnimations.length > 0) geometry.animations = outputAnimations;
            }
            if (json.materials === undefined || json.materials.length === 0) {
                return {
                    geometry: geometry
                };
            } else {
                var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                return {
                    geometry: geometry,
                    materials: materials
                };
            }
        }
    });
    function BufferGeometryLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(BufferGeometryLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        parse: function(json) {
            var geometry = new BufferGeometry();
            var index = json.data.index;
            var TYPED_ARRAYS = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            if (index !== undefined) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) {
                for (var i = 0, n = groups.length; i !== n; ++i) {
                    var group = groups[i];
                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }
            var boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                var center = new Vector3();
                if (boundingSphere.center !== undefined) {
                    center.fromArray(boundingSphere.center);
                }
                geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    });
    function CubeTextureLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }
    Object.assign(CubeTextureLoader.prototype, {
        load: function(urls, onLoad, onProgress, onError) {
            var texture = new CubeTexture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            var loaded = 0;
            function loadTexture(i) {
                loader.load(urls[i], function(image) {
                    texture.images[i] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, undefined, onError);
            }
            for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
            }
            return texture;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });
    function DataTextureLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this._parser = null;
    }
    Object.assign(DataTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var texture = new DataTexture();
            var loader = new FileLoader(this.manager);
            loader.setResponseType("arraybuffer");
            loader.load(url, function(buffer) {
                var texData = scope._parser(buffer);
                if (!texData) return;
                if (undefined !== texData.image) {
                    texture.image = texData.image;
                } else if (undefined !== texData.data) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
                texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
                texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
                if (undefined !== texData.format) {
                    texture.format = texData.format;
                }
                if (undefined !== texData.type) {
                    texture.type = texData.type;
                }
                if (undefined !== texData.mipmaps) {
                    texture.mipmaps = texData.mipmaps;
                }
                if (1 === texData.mipmapCount) {
                    texture.minFilter = LinearFilter;
                }
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture, texData);
            }, onProgress, onError);
            return texture;
        }
    });
    function CompressedTextureLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this._parser = null;
    }
    Object.assign(CompressedTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var images = [];
            var texture = new CompressedTexture();
            texture.image = images;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType("arraybuffer");
            function loadTexture(i) {
                loader.load(url[i], function(buffer) {
                    var texDatas = scope._parser(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) {
                var loaded = 0;
                for (var i = 0, il = url.length; i < il; ++i) {
                    loadTexture(i);
                }
            } else {
                loader.load(url, function(buffer) {
                    var texDatas = scope._parser(buffer, true);
                    if (texDatas.isCubemap) {
                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                        for (var f = 0; f < faces; f++) {
                            images[f] = {
                                mipmaps: []
                            };
                            for (var i = 0; i < texDatas.mipmapCount; i++) {
                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                    } else {
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }, onProgress, onError);
            }
            return texture;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });
    function ObjectLoader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.texturePath = "";
    }
    Object.assign(ObjectLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            if (this.texturePath === "") {
                this.texturePath = url.substring(0, url.lastIndexOf("/") + 1);
            }
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function(text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    if (onError !== undefined) onError(error);
                    console.error("SZX3D:ObjectLoader: Can't parse " + url + ".", error.message);
                    return;
                }
                var metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === "geometry") {
                    console.error("SZX3D.ObjectLoader: Can't load " + url + ". Use SZX3D.JSONLoader instead.");
                    return;
                }
                scope.parse(json, onLoad);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
        },
        parse: function(json, onLoad) {
            var geometries = this.parseGeometries(json.geometries);
            var images = this.parseImages(json.images, function() {
                if (onLoad !== undefined) onLoad(object);
            });
            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);
            var object = this.parseObject(json.object, geometries, materials);
            if (json.animations) {
                object.animations = this.parseAnimations(json.animations);
            }
            if (json.images === undefined || json.images.length === 0) {
                if (onLoad !== undefined) onLoad(object);
            }
            return object;
        },
        parseGeometries: function(json) {
            var geometries = {};
            if (json !== undefined) {
                var geometryLoader = new JSONLoader();
                var bufferGeometryLoader = new BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                    var geometry;
                    var data = json[i];
                    switch (data.type) {
                      case "PlaneGeometry":
                      case "PlaneBufferGeometry":
                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                        break;

                      case "BoxGeometry":
                      case "BoxBufferGeometry":
                      case "CubeGeometry":
                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                        break;

                      case "CircleGeometry":
                      case "CircleBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                        break;

                      case "CylinderGeometry":
                      case "CylinderBufferGeometry":
                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;

                      case "ConeGeometry":
                      case "ConeBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;

                      case "SphereGeometry":
                      case "SphereBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                        break;

                      case "DodecahedronGeometry":
                      case "IcosahedronGeometry":
                      case "OctahedronGeometry":
                      case "TetrahedronGeometry":
                        geometry = new Geometries[data.type](data.radius, data.detail);
                        break;

                      case "RingGeometry":
                      case "RingBufferGeometry":
                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                        break;

                      case "TorusGeometry":
                      case "TorusBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                        break;

                      case "TorusKnotGeometry":
                      case "TorusKnotBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                        break;

                      case "LatheGeometry":
                      case "LatheBufferGeometry":
                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                        break;

                      case "BufferGeometry":
                        geometry = bufferGeometryLoader.parse(data);
                        break;

                      case "Geometry":
                        geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                        break;

                      default:
                        console.warn('SZX3D.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                        continue;
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined) geometry.name = data.name;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        },
        parseMaterials: function(json, textures) {
            var materials = {};
            if (json !== undefined) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var material = loader.parse(json[i]);
                    materials[material.uuid] = material;
                }
            }
            return materials;
        },
        parseAnimations: function(json) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        },
        parseImages: function(json, onLoad) {
            var scope = this;
            var images = {};
            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function() {
                    scope.manager.itemEnd(url);
                }, undefined, function() {
                    scope.manager.itemError(url);
                });
            }
            if (json !== undefined && json.length > 0) {
                var manager = new LoadingManager(onLoad);
                var loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i];
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
            return images;
        },
        parseTextures: function(json, images) {
            var TextureMapping = {
                UVMapping: UVMapping,
                CubeReflectionMapping: CubeReflectionMapping,
                CubeRefractionMapping: CubeRefractionMapping,
                EquirectangularReflectionMapping: EquirectangularReflectionMapping,
                EquirectangularRefractionMapping: EquirectangularRefractionMapping,
                SphericalReflectionMapping: SphericalReflectionMapping,
                CubeUVReflectionMapping: CubeUVReflectionMapping,
                CubeUVRefractionMapping: CubeUVRefractionMapping
            };
            var TextureWrapping = {
                RepeatWrapping: RepeatWrapping,
                ClampToEdgeWrapping: ClampToEdgeWrapping,
                MirroredRepeatWrapping: MirroredRepeatWrapping
            };
            var TextureFilter = {
                NearestFilter: NearestFilter,
                NearestMipMapNearestFilter: NearestMipMapNearestFilter,
                NearestMipMapLinearFilter: NearestMipMapLinearFilter,
                LinearFilter: LinearFilter,
                LinearMipMapNearestFilter: LinearMipMapNearestFilter,
                LinearMipMapLinearFilter: LinearMipMapLinearFilter
            };
            function parseConstant(value, type) {
                if (typeof value === "number") return value;
                console.warn("SZX3D.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
                return type[value];
            }
            var textures = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.image === undefined) {
                        console.warn('SZX3D.ObjectLoader: No "image" specified for', data.uuid);
                    }
                    if (images[data.image] === undefined) {
                        console.warn("SZX3D.ObjectLoader: Undefined image", data.image);
                    }
                    var texture = new Texture(images[data.image]);
                    texture.needsUpdate = true;
                    texture.uuid = data.uuid;
                    if (data.name !== undefined) texture.name = data.name;
                    if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TextureMapping);
                    if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                    if (data.wrap !== undefined) {
                        texture.wrapS = parseConstant(data.wrap[0], TextureWrapping);
                        texture.wrapT = parseConstant(data.wrap[1], TextureWrapping);
                    }
                    if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TextureFilter);
                    if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TextureFilter);
                    if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                    if (data.flipY !== undefined) texture.flipY = data.flipY;
                    textures[data.uuid] = texture;
                }
            }
            return textures;
        },
        parseObject: function() {
            var matrix = new Matrix4();
            var targetObj = {};
            return function parseObject(data, geometries, materials) {
                var object;
                function getGeometry(name) {
                    if (geometries[name] === undefined) {
                        console.warn("SZX3D.ObjectLoader: Undefined geometry", name);
                    }
                    return geometries[name];
                }
                function getMaterial(name) {
                    if (name === undefined) return undefined;
                    if (materials[name] === undefined) {
                        console.warn("SZX3D.ObjectLoader: Undefined material", name);
                    }
                    return materials[name];
                }
                switch (data.type) {
                  case "Scene":
                    object = new Scene();
                    if (data.background !== undefined) {
                        if (Number.isInteger(data.background)) {
                            object.background = new Color(data.background);
                        }
                    }
                    if (data.fog !== undefined) {
                        if (data.fog.type === "Fog") {
                            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                        } else if (data.fog.type === "FogExp2") {
                            object.fog = new FogExp2(data.fog.color, data.fog.density);
                        }
                    }
                    break;

                  case "PerspectiveCamera":
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== undefined) object.focus = data.focus;
                    if (data.zoom !== undefined) object.zoom = data.zoom;
                    if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                    if (data.view !== undefined) object.view = Object.assign({}, data.view);
                    break;

                  case "OrthographicCamera":
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    break;

                  case "AmbientLight":
                    object = new AmbientLight(data.color, data.intensity);
                    break;

                  case "DirectionalLight":
                    object = new DirectionalLight(data.color, data.intensity);
                    break;

                  case "PointLight":
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;

                  case "SpotLight":
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;

                  case "HemisphereLight":
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;

                  case "RectAreaLight":
                    object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;

                  case "Mesh":
                    var geometry = getGeometry(data.geometry);
                    var material = getMaterial(data.material);
                    if (geometry.bones && geometry.bones.length > 0) {
                        object = new SkinnedMesh(geometry, material);
                    } else {
                        object = new Mesh(geometry, material);
                    }
                    break;

                  case "LOD":
                    object = new LOD();
                    break;

                  case "Line":
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;

                  case "LineSegments":
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "PointCloud":
                  case "Points":
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "Sprite":
                    object = new Sprite(getMaterial(data.material));
                    break;

                  case "Group":
                    object = new Group();
                    break;

                  case "SkinnedMesh":
                    console.warn("SZX3D.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.");

                  default:
                    object = new Object3D();
                }
                object.uuid = data.uuid;
                if (data.name !== undefined) object.name = data.name;
                if (data.matrix !== undefined) {
                    matrix.fromArray(data.matrix);
                    matrix.decompose(object.position, object.quaternion, object.scale);
                } else {
                    if (data.position !== undefined) object.position.fromArray(data.position);
                    if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                    if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                    if (data.scale !== undefined) object.scale.fromArray(data.scale);
                }
                if (data.castShadow !== undefined) object.castShadow = data.castShadow;
                if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
                if (data.shadow) {
                    if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                    if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                    if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                    if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
                }
                if (data.visible !== undefined) object.visible = data.visible;
                if (data.userData !== undefined) object.userData = data.userData;
                if (data.children !== undefined) {
                    for (var child in data.children) {
                        object.add(this.parseObject(data.children[child], geometries, materials));
                    }
                }
                if (data.type === "LOD") {
                    var levels = data.levels;
                    for (var l = 0; l < levels.length; l++) {
                        var level = levels[l];
                        var child = object.getObjectByProperty("uuid", level.object);
                        if (child !== undefined) {
                            object.addLevel(child, level.distance);
                        }
                    }
                }
                if (data.target !== undefined) targetObj[data.target] = object;
                if (targetObj[data.uuid] !== undefined) targetObj[data.uuid].target = object;
                return object;
            };
        }()
    });
    function AxisHelper(size) {
        size = size || 1;
        var vertices = [ 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size ];
        var colors = [ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ];
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    AxisHelper.prototype = Object.create(LineSegments.prototype);
    AxisHelper.prototype.constructor = AxisHelper;
    var lineGeometry;
    var coneGeometry;
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        Object3D.call(this);
        if (color === undefined) color = 16776960;
        if (length === undefined) length = 1;
        if (headLength === undefined) headLength = .2 * length;
        if (headWidth === undefined) headWidth = .2 * headLength;
        if (lineGeometry === undefined) {
            lineGeometry = new BufferGeometry();
            lineGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 1, 0 ], 3));
            coneGeometry = new CylinderBufferGeometry(0, .5, 1, 5, 1);
            coneGeometry.translate(0, -.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(lineGeometry, new LineBasicMaterial({
            color: color
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
            color: color
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    ArrowHelper.prototype = Object.create(Object3D.prototype);
    ArrowHelper.prototype.constructor = ArrowHelper;
    ArrowHelper.prototype.setDirection = function() {
        var axis = new Vector3();
        var radians;
        return function setDirection(dir) {
            if (dir.y > .99999) {
                this.quaternion.set(0, 0, 0, 1);
            } else if (dir.y < -.99999) {
                this.quaternion.set(1, 0, 0, 0);
            } else {
                axis.set(dir.z, 0, -dir.x).normalize();
                radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(axis, radians);
            }
        };
    }();
    ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
        if (headLength === undefined) headLength = .2 * length;
        if (headWidth === undefined) headWidth = .2 * headLength;
        this.line.scale.set(1, Math.max(0, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    };
    ArrowHelper.prototype.setColor = function(color) {
        this.line.material.color.copy(color);
        this.cone.material.color.copy(color);
    };
    function BoxHelper(object, color) {
        if (color === undefined) color = 16776960;
        var indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);
        var positions = new Float32Array(8 * 3);
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute("position", new BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        if (object !== undefined) {
            this.update(object);
        }
    }
    BoxHelper.prototype = Object.create(LineSegments.prototype);
    BoxHelper.prototype.constructor = BoxHelper;
    BoxHelper.prototype.update = function() {
        var box = new Box3();
        return function update(object) {
            if (object && object.isBox3) {
                box.copy(object);
            } else {
                box.setFromObject(object);
            }
            if (box.isEmpty()) return;
            var min = box.min;
            var max = box.max;
            var position = this.geometry.attributes.position;
            var array = position.array;
            array[0] = max.x;
            array[1] = max.y;
            array[2] = max.z;
            array[3] = min.x;
            array[4] = max.y;
            array[5] = max.z;
            array[6] = min.x;
            array[7] = min.y;
            array[8] = max.z;
            array[9] = max.x;
            array[10] = min.y;
            array[11] = max.z;
            array[12] = max.x;
            array[13] = max.y;
            array[14] = min.z;
            array[15] = min.x;
            array[16] = max.y;
            array[17] = min.z;
            array[18] = min.x;
            array[19] = min.y;
            array[20] = min.z;
            array[21] = max.x;
            array[22] = min.y;
            array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        };
    }();
    function CameraHelper(camera) {
        var geometry = new BufferGeometry();
        var material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: FaceColors
        });
        var vertices = [];
        var colors = [];
        var pointMap = {};
        var colorFrustum = new Color(16755200);
        var colorCone = new Color(16711680);
        var colorUp = new Color(43775);
        var colorTarget = new Color(16777215);
        var colorCross = new Color(3355443);
        addLine("n1", "n2", colorFrustum);
        addLine("n2", "n4", colorFrustum);
        addLine("n4", "n3", colorFrustum);
        addLine("n3", "n1", colorFrustum);
        addLine("f1", "f2", colorFrustum);
        addLine("f2", "f4", colorFrustum);
        addLine("f4", "f3", colorFrustum);
        addLine("f3", "f1", colorFrustum);
        addLine("n1", "f1", colorFrustum);
        addLine("n2", "f2", colorFrustum);
        addLine("n3", "f3", colorFrustum);
        addLine("n4", "f4", colorFrustum);
        addLine("p", "n1", colorCone);
        addLine("p", "n2", colorCone);
        addLine("p", "n3", colorCone);
        addLine("p", "n4", colorCone);
        addLine("u1", "u2", colorUp);
        addLine("u2", "u3", colorUp);
        addLine("u3", "u1", colorUp);
        addLine("c", "t", colorTarget);
        addLine("p", "c", colorCross);
        addLine("cn1", "cn2", colorCross);
        addLine("cn3", "cn4", colorCross);
        addLine("cf1", "cf2", colorCross);
        addLine("cf3", "cf4", colorCross);
        function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === undefined) {
                pointMap[id] = [];
            }
            pointMap[id].push(vertices.length / 3 - 1);
        }
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        LineSegments.call(this, geometry, material);
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    CameraHelper.prototype = Object.create(LineSegments.prototype);
    CameraHelper.prototype.constructor = CameraHelper;
    CameraHelper.prototype.update = function() {
        var geometry, pointMap;
        var vector = new Vector3();
        var camera = new Camera();
        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (points !== undefined) {
                var position = geometry.getAttribute("position");
                for (var i = 0, l = points.length; i < l; i++) {
                    position.setXYZ(points[i], vector.x, vector.y, vector.z);
                }
            }
        }
        return function update() {
            geometry = this.geometry;
            pointMap = this.pointMap;
            var w = 1, h = 1;
            camera.projectionMatrix.copy(this.camera.projectionMatrix);
            setPoint("c", 0, 0, -1);
            setPoint("t", 0, 0, 1);
            setPoint("n1", -w, -h, -1);
            setPoint("n2", w, -h, -1);
            setPoint("n3", -w, h, -1);
            setPoint("n4", w, h, -1);
            setPoint("f1", -w, -h, 1);
            setPoint("f2", w, -h, 1);
            setPoint("f3", -w, h, 1);
            setPoint("f4", w, h, 1);
            setPoint("u1", w * .7, h * 1.1, -1);
            setPoint("u2", -w * .7, h * 1.1, -1);
            setPoint("u3", 0, h * 2, -1);
            setPoint("cf1", -w, 0, 1);
            setPoint("cf2", w, 0, 1);
            setPoint("cf3", 0, -h, 1);
            setPoint("cf4", 0, h, 1);
            setPoint("cn1", -w, 0, -1);
            setPoint("cn2", w, 0, -1);
            setPoint("cn3", 0, -h, -1);
            setPoint("cn4", 0, h, -1);
            geometry.getAttribute("position").needsUpdate = true;
        };
    }();
    function FaceNormalsHelper(object, size, hex, linewidth) {
        this.object = object;
        this.size = size !== undefined ? size : 1;
        var color = hex !== undefined ? hex : 16776960;
        var width = linewidth !== undefined ? linewidth : 1;
        var nNormals = 0;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            nNormals = objGeometry.faces.length;
        } else {
            console.warn("SZX3D.FaceNormalsHelper: only SZX3D.Geometry is supported. Use SZX3D.VertexNormalsHelper, instead.");
        }
        var geometry = new BufferGeometry();
        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
        geometry.addAttribute("position", positions);
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
    FaceNormalsHelper.prototype.update = function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        return function update() {
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
            position.needsUpdate = true;
            return this;
        };
    }();
    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
        radius = radius || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions = divisions || 64;
        color1 = new Color(color1 !== undefined ? color1 : 4473924);
        color2 = new Color(color2 !== undefined ? color2 : 8947848);
        var vertices = [];
        var colors = [];
        var x, z;
        var v, i, j, r, color;
        for (i = 0; i <= radials; i++) {
            v = i / radials * (Math.PI * 2);
            x = Math.sin(v) * radius;
            z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            color = i & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }
        for (i = 0; i <= circles; i++) {
            color = i & 1 ? color1 : color2;
            r = radius - radius / circles * i;
            for (j = 0; j < divisions; j++) {
                v = j / divisions * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
                v = (j + 1) / divisions * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    PolarGridHelper.prototype = Object.create(LineSegments.prototype);
    PolarGridHelper.prototype.constructor = PolarGridHelper;
    function GridHelper(size, divisions, color1, color2) {
        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color(color1 !== undefined ? color1 : 4473924);
        color2 = new Color(color2 !== undefined ? color2 : 8947848);
        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;
        var vertices = [], colors = [];
        for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    GridHelper.prototype = Object.create(LineSegments.prototype);
    GridHelper.prototype.constructor = GridHelper;
    function AmbientLightHelper(light, sphereSize) {
        this.light = light;
        this.light.updateMatrixWorld();
        var geometry = new SphereBufferGeometry(sphereSize, 6, 3);
        var material = new MeshBasicMaterial({
            wireframe: true,
            fog: false
        });
        material.color.copy(this.light.color);
        Mesh.call(this, geometry, material);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    AmbientLightHelper.prototype = Object.create(Mesh.prototype);
    AmbientLightHelper.prototype.constructor = AmbientLightHelper;
    AmbientLightHelper.prototype.dispose = function() {
        this.geometry.dispose();
        this.material.dispose();
    };
    AmbientLightHelper.prototype.update = function() {
        this.material.color.copy(this.light.color);
    };
    function HemisphereLightHelper(light, size) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(Math.PI * .5);
        var material = new MeshBasicMaterial({
            vertexColors: VertexColors,
            wireframe: true
        });
        var position = geometry.getAttribute("position");
        var colors = new Float32Array(position.count * 3);
        geometry.addAttribute("color", new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, material));
        this.update();
    }
    HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
    HemisphereLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    };
    HemisphereLightHelper.prototype.update = function() {
        var vector = new Vector3();
        var color1 = new Color();
        var color2 = new Color();
        return function update() {
            var mesh = this.children[0];
            var colors = mesh.geometry.getAttribute("color");
            color1.copy(this.light.color).multiplyScalar(this.light.intensity);
            color2.copy(this.light.groundColor).multiplyScalar(this.light.intensity);
            for (var i = 0, l = colors.count; i < l; i++) {
                var color = i < l / 2 ? color1 : color2;
                colors.setXYZ(i, color.r, color.g, color.b);
            }
            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
            colors.needsUpdate = true;
        };
    }();
    function PointLightHelper(light, sphereSize) {
        this.light = light;
        this.light.updateMatrixWorld();
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial({
            wireframe: true,
            fog: false
        });
        material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        Mesh.call(this, geometry, material);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    PointLightHelper.prototype = Object.create(Mesh.prototype);
    PointLightHelper.prototype.constructor = PointLightHelper;
    PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose();
        this.material.dispose();
    };
    PointLightHelper.prototype.update = function() {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
    function RectAreaLightHelper(light) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        var geometry = new BufferGeometry();
        geometry.setIndex(new Uint16BufferAttribute([ 0, 1, 1, 2, 2, 3, 3, 0, 0, 2, 1, 3 ], 1));
        geometry.addAttribute("position", new Float32BufferAttribute(12, 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.add(new LineSegments(geometry, material));
        geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3));
        this.add(new LineSegments(geometry, material));
        this.update();
    }
    RectAreaLightHelper.prototype = Object.create(Object3D.prototype);
    RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
    RectAreaLightHelper.prototype.dispose = function() {
        var lightPlane = this.children[0];
        var targetLine = this.children[1];
        lightPlane.geometry.dispose();
        lightPlane.material.dispose();
        targetLine.geometry.dispose();
        targetLine.material.dispose();
    };
    RectAreaLightHelper.prototype.update = function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var v3 = new Vector3();
        return function update() {
            var lightPlane = this.children[0];
            var targetLine = this.children[1];
            var position = lightPlane.geometry.attributes.position;
            var array = position.array;
            var width_half = this.light.width / 2;
            var height_half = this.light.height / 2;
            array[0] = -width_half;
            array[1] = height_half;
            array[2] = 0;
            array[3] = width_half;
            array[4] = height_half;
            array[5] = 0;
            array[6] = width_half;
            array[7] = -height_half;
            array[8] = 0;
            array[9] = -width_half;
            array[10] = -height_half;
            array[11] = 0;
            position.needsUpdate = true;
            lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            if (this.light.target !== undefined && this.light.target instanceof Object3D) {
                v1.setFromMatrixPosition(this.light.matrixWorld);
                v2.setFromMatrixPosition(this.light.target.matrixWorld);
                v3.subVectors(v2, v1);
                lightPlane.lookAt(v3);
                targetLine.lookAt(v3);
                targetLine.scale.z = v3.length();
            } else {}
        };
    }();
    function DirectionalLightHelper(light, size) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        if (size === undefined) size = 1;
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute([ -size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0 ], 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.add(new Line(geometry, material));
        geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3));
        this.add(new Line(geometry, material));
        this.update();
    }
    DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
    DirectionalLightHelper.prototype.dispose = function() {
        var lightPlane = this.children[0];
        var targetLine = this.children[1];
        lightPlane.geometry.dispose();
        lightPlane.material.dispose();
        targetLine.geometry.dispose();
        targetLine.material.dispose();
    };
    DirectionalLightHelper.prototype.update = function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var v3 = new Vector3();
        return function update() {
            v1.setFromMatrixPosition(this.light.matrixWorld);
            v2.setFromMatrixPosition(this.light.target.matrixWorld);
            v3.subVectors(v2, v1);
            var lightPlane = this.children[0];
            var targetLine = this.children[1];
            lightPlane.lookAt(v3);
            lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            targetLine.lookAt(v3);
            targetLine.scale.z = v3.length();
        };
    }();
    function SpotLightHelper(light) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        var geometry = new BufferGeometry();
        var positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1, 1, 0, 1, -1, 0, 1, 0, 1, 1, 0, -1, 1 ];
        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
            var p1 = i / l * Math.PI * 2;
            var p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3));
        this.targetLine = new LineSegments(geometry, material);
        this.add(this.targetLine);
        this.update();
    }
    SpotLightHelper.prototype = Object.create(Object3D.prototype);
    SpotLightHelper.prototype.constructor = SpotLightHelper;
    SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    };
    SpotLightHelper.prototype.update = function() {
        var vector = new Vector3();
        var vector2 = new Vector3();
        var vector3 = new Vector3();
        return function update() {
            var coneLength = this.light.distance ? this.light.distance : 1e3;
            var coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            vector.setFromMatrixPosition(this.light.matrixWorld);
            vector2.setFromMatrixPosition(this.light.target.matrixWorld);
            vector3.subVectors(vector2, vector);
            this.cone.lookAt(vector2.sub(vector));
            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            this.targetLine.lookAt(vector3);
            this.targetLine.scale.z = vector3.length();
        };
    }();
    function LightTargetHelper(light, size) {
        this.light = light;
        this.target = function() {
            if (light.target === undefined) {
                var target = new Object3D();
                target.position.setFromMatrixPosition(light.matrixWorld);
                return target;
            } else {
                return light.target;
            }
        }();
        this.target.updateMatrixWorld();
        var color = new Color();
        if (light.intensity === undefined) {
            color.copy(light.color);
        } else {
            color.copy(light.color).multiplyScalar(light.intensity);
        }
        if (typeof size !== "number" || size === 0) size = 1;
        size = size / 2;
        var indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]);
        var positions = new Float32Array([ size, size, size, -size, size, size, -size, -size, size, size, -size, size, size, size, -size, -size, size, -size, -size, -size, -size, size, -size, -size ]);
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute("position", new BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        this.matrix = this.target.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    }
    LightTargetHelper.prototype = Object.create(LineSegments.prototype);
    LightTargetHelper.prototype.constructor = LightTargetHelper;
    LightTargetHelper.prototype.dispose = function() {
        this.geometry.dispose();
        this.material.dispose();
    };
    LightTargetHelper.prototype.update = function() {
        if (this.light.intensity === undefined) {
            this.material.color.copy(this.light.color);
        } else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        }
    };
    function SkeletonHelper(object) {
        this.bones = this.getBoneList(object);
        var geometry = new BufferGeometry();
        var vertices = [];
        var colors = [];
        var color1 = new Color(0, 0, 1);
        var color2 = new Color(0, 1, 0);
        for (var i = 0; i < this.bones.length; i++) {
            var bone = this.bones[i];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        LineSegments.call(this, geometry, material);
        this.root = object;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    }
    SkeletonHelper.prototype = Object.create(LineSegments.prototype);
    SkeletonHelper.prototype.constructor = SkeletonHelper;
    SkeletonHelper.prototype.getBoneList = function(object) {
        var boneList = [];
        if (object && object.isBone) {
            boneList.push(object);
        }
        for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, this.getBoneList(object.children[i]));
        }
        return boneList;
    };
    SkeletonHelper.prototype.update = function() {
        var vector = new Vector3();
        var boneMatrix = new Matrix4();
        var matrixWorldInv = new Matrix4();
        return function update() {
            var geometry = this.geometry;
            var position = geometry.getAttribute("position");
            matrixWorldInv.getInverse(this.root.matrixWorld);
            for (var i = 0, j = 0; i < this.bones.length; i++) {
                var bone = this.bones[i];
                if (bone.parent && bone.parent.isBone) {
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j, vector.x, vector.y, vector.z);
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j + 1, vector.x, vector.y, vector.z);
                    j += 2;
                }
            }
            geometry.getAttribute("position").needsUpdate = true;
        };
    }();
    function VertexNormalsHelper(object, size, hex, linewidth) {
        this.object = object;
        this.size = size !== undefined ? size : 1;
        var color = hex !== undefined ? hex : 16711680;
        var width = linewidth !== undefined ? linewidth : 1;
        var nNormals = 0;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            nNormals = objGeometry.faces.length * 3;
        } else if (objGeometry && objGeometry.isBufferGeometry) {
            nNormals = objGeometry.attributes.normal.count;
        }
        var geometry = new BufferGeometry();
        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
        geometry.addAttribute("position", positions);
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
    VertexNormalsHelper.prototype.update = function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        return function update() {
            var keys = [ "a", "b", "c" ];
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
                var vertices = objGeometry.vertices;
                var faces = objGeometry.faces;
                var idx = 0;
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                        var vertex = vertices[face[keys[j]]];
                        var normal = face.vertexNormals[j];
                        v1.copy(vertex).applyMatrix4(matrixWorld);
                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                        position.setXYZ(idx, v1.x, v1.y, v1.z);
                        idx = idx + 1;
                        position.setXYZ(idx, v2.x, v2.y, v2.z);
                        idx = idx + 1;
                    }
                }
            } else if (objGeometry && objGeometry.isBufferGeometry) {
                var objPos = objGeometry.attributes.position;
                var objNorm = objGeometry.attributes.normal;
                var idx = 0;
                for (var j = 0, jl = objPos.count; j < jl; j++) {
                    v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                    v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                    v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
            position.needsUpdate = true;
            return this;
        };
    }();
    var SceneUtils = {
        createMultiMaterialObject: function(geometry, materials) {
            var group = new Group();
            for (var i = 0, l = materials.length; i < l; i++) {
                group.add(new Mesh(geometry, materials[i]));
            }
            return group;
        },
        detach: function(child, parent, scene) {
            child.applyMatrix(parent.matrixWorld);
            parent.remove(child);
            scene.add(child);
        },
        attach: function(child, scene, parent) {
            var matrixWorldInverse = new Matrix4();
            matrixWorldInverse.getInverse(parent.matrixWorld);
            child.applyMatrix(matrixWorldInverse);
            scene.remove(child);
            parent.add(child);
        }
    };
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    }
    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;
    function LineCurve3(v1, v2) {
        this.v1 = v1;
        this.v2 = v2;
    }
    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;
    LineCurve3.prototype.getPoint = function(t) {
        if (t === 1) {
            return this.v2.clone();
        }
        var vector = new Vector3();
        vector.subVectors(this.v2, this.v1);
        vector.multiplyScalar(t);
        vector.add(this.v1);
        return vector;
    };
    function QuadraticBezierCurve3(v0, v1, v2) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    QuadraticBezierCurve3.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        return new Vector3(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    };
    function CubicBezierCurve3(v0, v1, v2, v3) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    CubicBezierCurve3.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        return new Vector3(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    };
    function CubicPoly() {
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function(x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function(t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    }
    var tmp = new Vector3();
    var px = new CubicPoly();
    var py = new CubicPoly();
    var pz = new CubicPoly();
    function CatmullRomCurve3(p) {
        this.points = p || [];
        this.closed = false;
    }
    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    CatmullRomCurve3.prototype.getPoint = function(t) {
        var points = this.points;
        var l = points.length;
        if (l < 2) console.log("duh, you need at least 2 points");
        var point = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(point);
        var weight = point - intPoint;
        if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
        } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        var p0, p1, p2, p3;
        if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
        } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        p1 = points[intPoint % l];
        p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
        } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.type === undefined || this.type === "centripetal" || this.type === "chordal") {
            var pow = this.type === "chordal" ? .5 : .25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4) dt1 = 1;
            if (dt0 < 1e-4) dt0 = dt1;
            if (dt2 < 1e-4) dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.type === "catmullrom") {
            var tension = this.tension !== undefined ? this.tension : .5;
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }
        return new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
    };
    function ImmediateRenderObject(material) {
        Object3D.call(this);
        this.material = material;
        this.render = function(renderCallback) {};
    }
    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;
    function MorphBlendMesh(geometry, material) {
        Mesh.call(this, geometry, material);
        this.animationsMap = {};
        this.animationsList = [];
        var numFrames = this.geometry.morphTargets.length;
        var name = "__default";
        var startFrame = 0;
        var endFrame = numFrames - 1;
        var fps = numFrames / 1;
        this.createAnimation(name, startFrame, endFrame, fps);
        this.setAnimationWeight(name, 1);
    }
    MorphBlendMesh.prototype = Object.create(Mesh.prototype);
    MorphBlendMesh.prototype.constructor = MorphBlendMesh;
    MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
        var animation = {
            start: start,
            end: end,
            length: end - start + 1,
            fps: fps,
            duration: (end - start) / fps,
            lastFrame: 0,
            currentFrame: 0,
            active: false,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: false,
            mirroredLoop: false
        };
        this.animationsMap[name] = animation;
        this.animationsList.push(animation);
    };
    MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
        var pattern = /([a-z]+)_?(\d+)/i;
        var firstAnimation, frameRanges = {};
        var geometry = this.geometry;
        for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {
            var morph = geometry.morphTargets[i];
            var chunks = morph.name.match(pattern);
            if (chunks && chunks.length > 1) {
                var name = chunks[1];
                if (!frameRanges[name]) frameRanges[name] = {
                    start: Infinity,
                    end: -Infinity
                };
                var range = frameRanges[name];
                if (i < range.start) range.start = i;
                if (i > range.end) range.end = i;
                if (!firstAnimation) firstAnimation = name;
            }
        }
        for (var name in frameRanges) {
            var range = frameRanges[name];
            this.createAnimation(name, range.start, range.end, fps);
        }
        this.firstAnimation = firstAnimation;
    };
    MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.direction = 1;
            animation.directionBackwards = false;
        }
    };
    MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.direction = -1;
            animation.directionBackwards = true;
        }
    };
    MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.fps = fps;
            animation.duration = (animation.end - animation.start) / animation.fps;
        }
    };
    MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.duration = duration;
            animation.fps = (animation.end - animation.start) / animation.duration;
        }
    };
    MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.weight = weight;
        }
    };
    MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.time = time;
        }
    };
    MorphBlendMesh.prototype.getAnimationTime = function(name) {
        var time = 0;
        var animation = this.animationsMap[name];
        if (animation) {
            time = animation.time;
        }
        return time;
    };
    MorphBlendMesh.prototype.getAnimationDuration = function(name) {
        var duration = -1;
        var animation = this.animationsMap[name];
        if (animation) {
            duration = animation.duration;
        }
        return duration;
    };
    MorphBlendMesh.prototype.playAnimation = function(name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.time = 0;
            animation.active = true;
        } else {
            console.warn("SZX3D.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
        }
    };
    MorphBlendMesh.prototype.stopAnimation = function(name) {
        var animation = this.animationsMap[name];
        if (animation) {
            animation.active = false;
        }
    };
    MorphBlendMesh.prototype.update = function(delta) {
        for (var i = 0, il = this.animationsList.length; i < il; i++) {
            var animation = this.animationsList[i];
            if (!animation.active) continue;
            var frameTime = animation.duration / animation.length;
            animation.time += animation.direction * delta;
            if (animation.mirroredLoop) {
                if (animation.time > animation.duration || animation.time < 0) {
                    animation.direction *= -1;
                    if (animation.time > animation.duration) {
                        animation.time = animation.duration;
                        animation.directionBackwards = true;
                    }
                    if (animation.time < 0) {
                        animation.time = 0;
                        animation.directionBackwards = false;
                    }
                }
            } else {
                animation.time = animation.time % animation.duration;
                if (animation.time < 0) animation.time += animation.duration;
            }
            var keyframe = animation.start + _Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
            var weight = animation.weight;
            if (keyframe !== animation.currentFrame) {
                this.morphTargetInfluences[animation.lastFrame] = 0;
                this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
                this.morphTargetInfluences[keyframe] = 0;
                animation.lastFrame = animation.currentFrame;
                animation.currentFrame = keyframe;
            }
            var mix = animation.time % frameTime / frameTime;
            if (animation.directionBackwards) mix = 1 - mix;
            if (animation.currentFrame !== animation.lastFrame) {
                this.morphTargetInfluences[animation.currentFrame] = mix * weight;
                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
            } else {
                this.morphTargetInfluences[animation.currentFrame] = weight;
            }
        }
    };
    function RenderableObject() {
        this.id = 0;
        this.object = null;
        this.z = 0;
        this.renderOrder = 0;
    }
    function RenderableVertex() {
        this.position = new Vector3();
        this.positionWorld = new Vector3();
        this.positionScreen = new Vector4();
        this.visible = true;
    }
    RenderableVertex.prototype.copy = function(vertex) {
        this.position.copy(vertex.position);
        this.positionWorld.copy(vertex.positionWorld);
        this.positionScreen.copy(vertex.positionScreen);
        this.visible = vertex.visible;
    };
    function RenderableLine() {
        this.id = 0;
        this.v1 = new RenderableVertex();
        this.v2 = new RenderableVertex();
        this.vertexColors = [ new Color(), new Color() ];
        this.material = null;
        this.z = 0;
        this.renderOrder = 0;
    }
    function RenderableFace() {
        this.id = 0;
        this.v1 = new RenderableVertex();
        this.v2 = new RenderableVertex();
        this.v3 = new RenderableVertex();
        this.normalModel = new Vector3();
        this.vertexNormalsModel = [ new Vector3(), new Vector3(), new Vector3() ];
        this.vertexNormalsLength = 0;
        this.color = new Color();
        this.material = null;
        this.uvs = [ new Vector2(), new Vector2(), new Vector2() ];
        this.z = 0;
        this.renderOrder = 0;
    }
    function RenderableSprite() {
        this.id = 0;
        this.object = null;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.rotation = 0;
        this.scale = new Vector2();
        this.material = null;
        this.renderOrder = 0;
    }
    function Projector() {
        var _object, _objectCount, _objectPool = [], _objectPoolLength = 0, _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0, _face, _faceCount, _facePool = [], _facePoolLength = 0, _line, _lineCount, _linePool = [], _linePoolLength = 0, _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0, _renderData = {
            objects: [],
            lights: [],
            elements: []
        }, _vector3 = new Vector3(), _vector4 = new Vector4(), _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)), _boundingBox = new Box3(), _points3 = new Array(3), _points4 = new Array(4), _viewMatrix = new Matrix4(), _viewProjectionMatrix = new Matrix4(), _modelMatrix, _modelViewProjectionMatrix = new Matrix4(), _normalMatrix = new Matrix3(), _frustum = new Frustum(), _clippedVertex1PositionScreen = new Vector4(), _clippedVertex2PositionScreen = new Vector4();
        this.projectVector = function(vector, camera) {
            console.warn("SZX3D.Projector: .projectVector() is now vector.project().");
            vector.project(camera);
        };
        this.unprojectVector = function(vector, camera) {
            console.warn("SZX3D.Projector: .unprojectVector() is now vector.unproject().");
            vector.unproject(camera);
        };
        this.pickingRay = function(vector, camera) {
            console.error("SZX3D.Projector: .pickingRay() is now raycaster.setFromCamera().");
        };
        var RenderList = function() {
            var normals = [];
            var uvs = [];
            var object = null;
            var material = null;
            var normalMatrix = new Matrix3();
            function setObject(value) {
                object = value;
                material = object.material;
                normalMatrix.getNormalMatrix(object.matrixWorld);
                normals.length = 0;
                uvs.length = 0;
            }
            function projectVertex(vertex) {
                var position = vertex.position;
                var positionWorld = vertex.positionWorld;
                var positionScreen = vertex.positionScreen;
                positionWorld.copy(position).applyMatrix4(_modelMatrix);
                positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);
                var invW = 1 / positionScreen.w;
                positionScreen.x *= invW;
                positionScreen.y *= invW;
                positionScreen.z *= invW;
                vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;
            }
            function pushVertex(x, y, z) {
                _vertex = getNextVertexInPool();
                _vertex.position.set(x, y, z);
                projectVertex(_vertex);
            }
            function pushNormal(x, y, z) {
                normals.push(x, y, z);
            }
            function pushUv(x, y) {
                uvs.push(x, y);
            }
            function checkTriangleVisibility(v1, v2, v3) {
                if (v1.visible === true || v2.visible === true || v3.visible === true) return true;
                _points3[0] = v1.positionScreen;
                _points3[1] = v2.positionScreen;
                _points3[2] = v3.positionScreen;
                return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));
            }
            function checkBackfaceCulling(v1, v2, v3) {
                return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;
            }
            function pushLine(a, b, _modelViewProjectionMatrix) {
                var v1 = _vertexPool[a];
                var v2 = _vertexPool[b];
                v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);
                v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);
                if (clipLine(v1.positionScreen, v2.positionScreen) === true) {
                    v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);
                    v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);
                    _line = getNextLineInPool();
                    _line.id = object.id;
                    _line.v1.copy(v1);
                    _line.v2.copy(v2);
                    _line.z = (v1.positionScreen.z + v2.positionScreen.z) / 2;
                    _line.renderOrder = object.renderOrder;
                    _line.material = object.material;
                    _renderData.elements.push(_line);
                }
            }
            function pushTriangle(a, b, c) {
                var v1 = _vertexPool[a];
                var v2 = _vertexPool[b];
                var v3 = _vertexPool[c];
                if (checkTriangleVisibility(v1, v2, v3) === false) return;
                if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {
                    _face = getNextFaceInPool();
                    _face.id = object.id;
                    _face.v1.copy(v1);
                    _face.v2.copy(v2);
                    _face.v3.copy(v3);
                    _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
                    _face.renderOrder = object.renderOrder;
                    _face.normalModel.fromArray(normals, a * 3);
                    _face.normalModel.applyMatrix3(normalMatrix).normalize();
                    for (var i = 0; i < 3; i++) {
                        var normal = _face.vertexNormalsModel[i];
                        normal.fromArray(normals, arguments[i] * 3);
                        normal.applyMatrix3(normalMatrix).normalize();
                        var uv = _face.uvs[i];
                        uv.fromArray(uvs, arguments[i] * 2);
                    }
                    _face.vertexNormalsLength = 3;
                    _face.material = object.material;
                    _renderData.elements.push(_face);
                }
            }
            return {
                setObject: setObject,
                projectVertex: projectVertex,
                checkTriangleVisibility: checkTriangleVisibility,
                checkBackfaceCulling: checkBackfaceCulling,
                pushVertex: pushVertex,
                pushNormal: pushNormal,
                pushUv: pushUv,
                pushLine: pushLine,
                pushTriangle: pushTriangle
            };
        };
        var renderList = new RenderList();
        this.projectScene = function(scene, camera, sortObjects, sortElements) {
            _faceCount = 0;
            _lineCount = 0;
            _spriteCount = 0;
            _renderData.elements.length = 0;
            if (scene.autoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null) camera.updateMatrixWorld();
            _viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
            _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
            _frustum.setFromMatrix(_viewProjectionMatrix);
            _objectCount = 0;
            _renderData.objects.length = 0;
            _renderData.lights.length = 0;
            function addObject(object) {
                _object = getNextObjectInPool();
                _object.id = object.id;
                _object.object = object;
                _vector3.setFromMatrixPosition(object.matrixWorld);
                _vector3.applyMatrix4(_viewProjectionMatrix);
                _object.z = _vector3.z;
                _object.renderOrder = object.renderOrder;
                _renderData.objects.push(_object);
            }
            scene.traverseVisible(function(object) {
                if (object instanceof Light) {
                    _renderData.lights.push(object);
                } else if (object instanceof Mesh || object instanceof Line) {
                    if (object.material.visible === false) return;
                    if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;
                    addObject(object);
                } else if (object instanceof Sprite) {
                    if (object.material.visible === false) return;
                    if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;
                    addObject(object);
                }
            });
            if (sortObjects === true) {
                _renderData.objects.sort(painterSort);
            }
            for (var o = 0, ol = _renderData.objects.length; o < ol; o++) {
                var object = _renderData.objects[o].object;
                var geometry = object.geometry;
                renderList.setObject(object);
                _modelMatrix = object.matrixWorld;
                _vertexCount = 0;
                if (object instanceof Mesh) {
                    if (geometry instanceof BufferGeometry) {
                        var attributes = geometry.attributes;
                        var groups = geometry.groups;
                        if (attributes.position === undefined) continue;
                        var positions = attributes.position.array;
                        for (var i = 0, l = positions.length; i < l; i += 3) {
                            renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);
                        }
                        if (attributes.normal !== undefined) {
                            var normals = attributes.normal.array;
                            for (var i = 0, l = normals.length; i < l; i += 3) {
                                renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);
                            }
                        }
                        if (attributes.uv !== undefined) {
                            var uvs = attributes.uv.array;
                            for (var i = 0, l = uvs.length; i < l; i += 2) {
                                renderList.pushUv(uvs[i], uvs[i + 1]);
                            }
                        }
                        if (geometry.index !== null) {
                            var indices = geometry.index.array;
                            if (groups.length > 0) {
                                for (var g = 0; g < groups.length; g++) {
                                    var group = groups[g];
                                    for (var i = group.start, l = group.start + group.count; i < l; i += 3) {
                                        renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2]);
                                    }
                                }
                            } else {
                                for (var i = 0, l = indices.length; i < l; i += 3) {
                                    renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2]);
                                }
                            }
                        } else {
                            for (var i = 0, l = positions.length / 3; i < l; i += 3) {
                                renderList.pushTriangle(i, i + 1, i + 2);
                            }
                        }
                    } else if (geometry instanceof Geometry) {
                        var vertices = geometry.vertices;
                        var faces = geometry.faces;
                        var faceVertexUvs = geometry.faceVertexUvs[0];
                        _normalMatrix.getNormalMatrix(_modelMatrix);
                        var material = object.material;
                        var isFaceMaterial = material instanceof MultiMaterial;
                        var objectMaterials = isFaceMaterial === true ? object.material : null;
                        for (var v = 0, vl = vertices.length; v < vl; v++) {
                            var vertex = vertices[v];
                            _vector3.copy(vertex);
                            if (material.morphTargets === true) {
                                var morphTargets = geometry.morphTargets;
                                var morphInfluences = object.morphTargetInfluences;
                                for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                    var influence = morphInfluences[t];
                                    if (influence === 0) continue;
                                    var target = morphTargets[t];
                                    var targetVertex = target.vertices[v];
                                    _vector3.x += (targetVertex.x - vertex.x) * influence;
                                    _vector3.y += (targetVertex.y - vertex.y) * influence;
                                    _vector3.z += (targetVertex.z - vertex.z) * influence;
                                }
                            }
                            renderList.pushVertex(_vector3.x, _vector3.y, _vector3.z);
                        }
                        for (var f = 0, fl = faces.length; f < fl; f++) {
                            var face = faces[f];
                            material = isFaceMaterial === true ? objectMaterials.materials[face.materialIndex] : object.material;
                            if (material === undefined) continue;
                            var side = material.side;
                            var v1 = _vertexPool[face.a];
                            var v2 = _vertexPool[face.b];
                            var v3 = _vertexPool[face.c];
                            if (renderList.checkTriangleVisibility(v1, v2, v3) === false) continue;
                            var visible = renderList.checkBackfaceCulling(v1, v2, v3);
                            if (side !== DoubleSide) {
                                if (side === FrontSide && visible === false) continue;
                                if (side === BackSide && visible === true) continue;
                            }
                            _face = getNextFaceInPool();
                            _face.id = object.id;
                            _face.v1.copy(v1);
                            _face.v2.copy(v2);
                            _face.v3.copy(v3);
                            _face.normalModel.copy(face.normal);
                            if (visible === false && (side === BackSide || side === DoubleSide)) {
                                _face.normalModel.negate();
                            }
                            _face.normalModel.applyMatrix3(_normalMatrix).normalize();
                            var faceVertexNormals = face.vertexNormals;
                            for (var n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {
                                var normalModel = _face.vertexNormalsModel[n];
                                normalModel.copy(faceVertexNormals[n]);
                                if (visible === false && (side === BackSide || side === DoubleSide)) {
                                    normalModel.negate();
                                }
                                normalModel.applyMatrix3(_normalMatrix).normalize();
                            }
                            _face.vertexNormalsLength = faceVertexNormals.length;
                            var vertexUvs = faceVertexUvs[f];
                            if (vertexUvs !== undefined) {
                                for (var u = 0; u < 3; u++) {
                                    _face.uvs[u].copy(vertexUvs[u]);
                                }
                            }
                            _face.color = face.color;
                            _face.material = material;
                            _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
                            _face.renderOrder = object.renderOrder;
                            _renderData.elements.push(_face);
                        }
                    }
                } else if (object instanceof Line) {
                    _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);
                    if (geometry instanceof BufferGeometry) {
                        var attributes = geometry.attributes;
                        if (attributes.position !== undefined) {
                            var positions = attributes.position.array;
                            for (var i = 0, l = positions.length; i < l; i += 3) {
                                renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);
                            }
                            if (geometry.index !== null) {
                                var indices = geometry.index.array;
                                for (var i = 0, l = indices.length; i < l; i += 2) {
                                    renderList.pushLine(indices[i], indices[i + 1], _modelViewProjectionMatrix);
                                }
                            } else {
                                var step = object instanceof LineSegments ? 2 : 1;
                                for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                                    renderList.pushLine(i, i + 1, _modelViewProjectionMatrix);
                                }
                            }
                        }
                    } else if (geometry instanceof Geometry) {
                        var vertices = object.geometry.vertices;
                        if (vertices.length === 0) continue;
                        v1 = getNextVertexInPool();
                        v1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);
                        var step = object instanceof LineSegments ? 2 : 1;
                        for (var v = 1, vl = vertices.length; v < vl; v++) {
                            v1 = getNextVertexInPool();
                            v1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);
                            if ((v + 1) % step > 0) continue;
                            v2 = _vertexPool[_vertexCount - 2];
                            _clippedVertex1PositionScreen.copy(v1.positionScreen);
                            _clippedVertex2PositionScreen.copy(v2.positionScreen);
                            if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {
                                _clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);
                                _clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);
                                _line = getNextLineInPool();
                                _line.id = object.id;
                                _line.v1.positionScreen.copy(_clippedVertex1PositionScreen);
                                _line.v2.positionScreen.copy(_clippedVertex2PositionScreen);
                                _line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);
                                _line.renderOrder = object.renderOrder;
                                _line.material = object.material;
                                if (object.material.vertexColors === VertexColors) {
                                    _line.vertexColors[0].copy(object.geometry.colors[v]);
                                    _line.vertexColors[1].copy(object.geometry.colors[v - 1]);
                                }
                                _renderData.elements.push(_line);
                            }
                        }
                    }
                } else if (object instanceof Sprite) {
                    _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);
                    _vector4.applyMatrix4(_viewProjectionMatrix);
                    var invW = 1 / _vector4.w;
                    _vector4.z *= invW;
                    if (_vector4.z >= -1 && _vector4.z <= 1) {
                        _sprite = getNextSpriteInPool();
                        _sprite.id = object.id;
                        _sprite.x = _vector4.x * invW;
                        _sprite.y = _vector4.y * invW;
                        _sprite.z = _vector4.z;
                        _sprite.renderOrder = object.renderOrder;
                        _sprite.object = object;
                        _sprite.rotation = object.rotation;
                        _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));
                        _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));
                        _sprite.material = object.material;
                        _renderData.elements.push(_sprite);
                    }
                }
            }
            if (sortElements === true) {
                _renderData.elements.sort(painterSort);
            }
            return _renderData;
        };
        function getNextObjectInPool() {
            if (_objectCount === _objectPoolLength) {
                var object = new RenderableObject();
                _objectPool.push(object);
                _objectPoolLength++;
                _objectCount++;
                return object;
            }
            return _objectPool[_objectCount++];
        }
        function getNextVertexInPool() {
            if (_vertexCount === _vertexPoolLength) {
                var vertex = new RenderableVertex();
                _vertexPool.push(vertex);
                _vertexPoolLength++;
                _vertexCount++;
                return vertex;
            }
            return _vertexPool[_vertexCount++];
        }
        function getNextFaceInPool() {
            if (_faceCount === _facePoolLength) {
                var face = new RenderableFace();
                _facePool.push(face);
                _facePoolLength++;
                _faceCount++;
                return face;
            }
            return _facePool[_faceCount++];
        }
        function getNextLineInPool() {
            if (_lineCount === _linePoolLength) {
                var line = new RenderableLine();
                _linePool.push(line);
                _linePoolLength++;
                _lineCount++;
                return line;
            }
            return _linePool[_lineCount++];
        }
        function getNextSpriteInPool() {
            if (_spriteCount === _spritePoolLength) {
                var sprite = new RenderableSprite();
                _spritePool.push(sprite);
                _spritePoolLength++;
                _spriteCount++;
                return sprite;
            }
            return _spritePool[_spriteCount++];
        }
        function painterSort(a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {
                return b.z - a.z;
            } else if (a.id !== b.id) {
                return a.id - b.id;
            } else {
                return 0;
            }
        }
        function clipLine(s1, s2) {
            var alpha1 = 0, alpha2 = 1, bc1near = s1.z + s1.w, bc2near = s2.z + s2.w, bc1far = -s1.z + s1.w, bc2far = -s2.z + s2.w;
            if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
                return true;
            } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {
                return false;
            } else {
                if (bc1near < 0) {
                    alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
                } else if (bc2near < 0) {
                    alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
                }
                if (bc1far < 0) {
                    alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
                } else if (bc2far < 0) {
                    alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
                }
                if (alpha2 < alpha1) {
                    return false;
                } else {
                    s1.lerp(s2, alpha1);
                    s2.lerp(s1, 1 - alpha2);
                    return true;
                }
            }
        }
    }
    function SpriteCanvasMaterial(parameters) {
        Material.call(this);
        this.type = "SpriteCanvasMaterial";
        this.color = new Color(16777215);
        this.program = function(context, color) {};
        this.setValues(parameters);
    }
    SpriteCanvasMaterial.prototype = Object.create(Material.prototype);
    SpriteCanvasMaterial.prototype.constructor = SpriteCanvasMaterial;
    SpriteCanvasMaterial.prototype.clone = function() {
        var material = new SpriteCanvasMaterial();
        material.copy(this);
        material.color.copy(this.color);
        material.program = this.program;
        return material;
    };
    function CanvasRenderer(parameters) {
        console.log("SZX3D.CanvasRenderer", REVISION);
        parameters = parameters || {};
        var _this = this, _renderData, _elements, _lights, _projector = new Projector(), _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement("canvas"), _canvasWidth = _canvas.width, _canvasHeight = _canvas.height, _canvasWidthHalf = Math.floor(_canvasWidth / 2), _canvasHeightHalf = Math.floor(_canvasHeight / 2), _viewportX = 0, _viewportY = 0, _viewportWidth = _canvasWidth, _viewportHeight = _canvasHeight, _pixelRatio = 1, _context = _canvas.getContext("2d", {
            alpha: parameters.alpha === true
        }), _clearColor = new Color(0), _clearAlpha = parameters.alpha === true ? 0 : 1, _contextGlobalAlpha = 1, _contextGlobalCompositeOperation = 0, _contextStrokeStyle = null, _contextFillStyle = null, _contextLineWidth = null, _contextLineCap = null, _contextLineJoin = null, _contextLineDash = [], _camera, _v1, _v2, _v3, _v4, _v5 = new RenderableVertex(), _v6 = new RenderableVertex(), _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y, _v5x, _v5y, _v6x, _v6y, _color = new Color(), _color1 = new Color(), _color2 = new Color(), _color3 = new Color(), _color4 = new Color(), _diffuseColor = new Color(), _emissiveColor = new Color(), _lightColor = new Color(), _patterns = {}, _image, _uvs, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, _clipBox = new Box2(), _clearBox = new Box2(), _elemBox = new Box2(), _ambientLight = new Color(), _directionalLights = new Color(), _pointLights = new Color(), _vector3 = new Vector3(), _centroid = new Vector3(), _normal = new Vector3(), _normalViewMatrix = new Matrix3();
        if (_context.setLineDash === undefined) {
            _context.setLineDash = function() {};
        }
        this.domElement = _canvas;
        this.autoClear = true;
        this.sortObjects = true;
        this.sortElements = true;
        this.info = {
            render: {
                vertices: 0,
                faces: 0
            }
        };
        this.supportsVertexTextures = function() {};
        this.setFaceCulling = function() {};
        this.getContext = function() {
            return _context;
        };
        this.getContextAttributes = function() {
            return _context.getContextAttributes();
        };
        this.getPixelRatio = function() {
            return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
            if (value !== undefined) _pixelRatio = value;
        };
        this.setSize = function(width, height, updateStyle) {
            _canvasWidth = width * _pixelRatio;
            _canvasHeight = height * _pixelRatio;
            _canvas.width = _canvasWidth;
            _canvas.height = _canvasHeight;
            _canvasWidthHalf = Math.floor(_canvasWidth / 2);
            _canvasHeightHalf = Math.floor(_canvasHeight / 2);
            if (updateStyle !== false) {
                _canvas.style.width = width + "px";
                _canvas.style.height = height + "px";
            }
            _clipBox.min.set(-_canvasWidthHalf, -_canvasHeightHalf);
            _clipBox.max.set(_canvasWidthHalf, _canvasHeightHalf);
            _clearBox.min.set(-_canvasWidthHalf, -_canvasHeightHalf);
            _clearBox.max.set(_canvasWidthHalf, _canvasHeightHalf);
            _contextGlobalAlpha = 1;
            _contextGlobalCompositeOperation = 0;
            _contextStrokeStyle = null;
            _contextFillStyle = null;
            _contextLineWidth = null;
            _contextLineCap = null;
            _contextLineJoin = null;
            this.setViewport(0, 0, width, height);
        };
        this.setViewport = function(x, y, width, height) {
            _viewportX = x * _pixelRatio;
            _viewportY = y * _pixelRatio;
            _viewportWidth = width * _pixelRatio;
            _viewportHeight = height * _pixelRatio;
        };
        this.setScissor = function() {};
        this.setScissorTest = function() {};
        this.setClearColor = function(color, alpha) {
            _clearColor.set(color);
            _clearAlpha = alpha !== undefined ? alpha : 1;
            _clearBox.min.set(-_canvasWidthHalf, -_canvasHeightHalf);
            _clearBox.max.set(_canvasWidthHalf, _canvasHeightHalf);
        };
        this.setClearColorHex = function(hex, alpha) {
            console.warn("SZX3D.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.");
            this.setClearColor(hex, alpha);
        };
        this.getClearColor = function() {
            return _clearColor;
        };
        this.getClearAlpha = function() {
            return _clearAlpha;
        };
        this.getMaxAnisotropy = function() {
            return 0;
        };
        this.clear = function() {
            if (_clearBox.isEmpty() === false) {
                _clearBox.intersect(_clipBox);
                _clearBox.expandByScalar(2);
                _clearBox.min.x = _clearBox.min.x + _canvasWidthHalf;
                _clearBox.min.y = -_clearBox.min.y + _canvasHeightHalf;
                _clearBox.max.x = _clearBox.max.x + _canvasWidthHalf;
                _clearBox.max.y = -_clearBox.max.y + _canvasHeightHalf;
                if (_clearAlpha < 1) {
                    _context.clearRect(_clearBox.min.x | 0, _clearBox.max.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.min.y - _clearBox.max.y | 0);
                }
                if (_clearAlpha > 0) {
                    setBlending(NormalBlending);
                    setOpacity(1);
                    setFillStyle("rgba(" + Math.floor(_clearColor.r * 255) + "," + Math.floor(_clearColor.g * 255) + "," + Math.floor(_clearColor.b * 255) + "," + _clearAlpha + ")");
                    _context.fillRect(_clearBox.min.x | 0, _clearBox.max.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.min.y - _clearBox.max.y | 0);
                }
                _clearBox.makeEmpty();
            }
        };
        this.clearColor = function() {};
        this.clearDepth = function() {};
        this.clearStencil = function() {};
        this.render = function(scene, camera) {
            if (camera instanceof Camera === false) {
                console.error("SZX3D.CanvasRenderer.render: camera is not an instance of SZX3D.Camera.");
                return;
            }
            var background = scene.background;
            if (background && background.isColor) {
                setFillStyle("rgb(" + Math.floor(background.r * 255) + "," + Math.floor(background.g * 255) + "," + Math.floor(background.b * 255) + ")");
                _context.fillRect(0, 0, _canvasWidth, _canvasHeight);
            } else if (this.autoClear === true) {
                this.clear();
            }
            _this.info.render.vertices = 0;
            _this.info.render.faces = 0;
            _context.setTransform(_viewportWidth / _canvasWidth, 0, 0, -_viewportHeight / _canvasHeight, _viewportX, _canvasHeight - _viewportY);
            _context.translate(_canvasWidthHalf, _canvasHeightHalf);
            _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
            _elements = _renderData.elements;
            _lights = _renderData.lights;
            _camera = camera;
            _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);
            calculateLights();
            for (var e = 0, el = _elements.length; e < el; e++) {
                var element = _elements[e];
                var material = element.material;
                if (material === undefined || material.opacity === 0) continue;
                _elemBox.makeEmpty();
                if (element instanceof RenderableSprite) {
                    _v1 = element;
                    _v1.x *= _canvasWidthHalf;
                    _v1.y *= _canvasHeightHalf;
                    renderSprite(_v1, element, material);
                } else if (element instanceof RenderableLine) {
                    _v1 = element.v1;
                    _v2 = element.v2;
                    _v1.positionScreen.x *= _canvasWidthHalf;
                    _v1.positionScreen.y *= _canvasHeightHalf;
                    _v2.positionScreen.x *= _canvasWidthHalf;
                    _v2.positionScreen.y *= _canvasHeightHalf;
                    _elemBox.setFromPoints([ _v1.positionScreen, _v2.positionScreen ]);
                    if (_clipBox.intersectsBox(_elemBox) === true) {
                        renderLine(_v1, _v2, element, material);
                    }
                } else if (element instanceof RenderableFace) {
                    _v1 = element.v1;
                    _v2 = element.v2;
                    _v3 = element.v3;
                    if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;
                    if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;
                    if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;
                    _v1.positionScreen.x *= _canvasWidthHalf;
                    _v1.positionScreen.y *= _canvasHeightHalf;
                    _v2.positionScreen.x *= _canvasWidthHalf;
                    _v2.positionScreen.y *= _canvasHeightHalf;
                    _v3.positionScreen.x *= _canvasWidthHalf;
                    _v3.positionScreen.y *= _canvasHeightHalf;
                    if (material.overdraw > 0) {
                        expand(_v1.positionScreen, _v2.positionScreen, material.overdraw);
                        expand(_v2.positionScreen, _v3.positionScreen, material.overdraw);
                        expand(_v3.positionScreen, _v1.positionScreen, material.overdraw);
                    }
                    _elemBox.setFromPoints([ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen ]);
                    if (_clipBox.intersectsBox(_elemBox) === true) {
                        renderFace3(_v1, _v2, _v3, 0, 1, 2, element, material);
                    }
                }
                _clearBox.union(_elemBox);
            }
            _context.setTransform(1, 0, 0, 1, 0, 0);
        };
        function calculateLights() {
            _ambientLight.setRGB(0, 0, 0);
            _directionalLights.setRGB(0, 0, 0);
            _pointLights.setRGB(0, 0, 0);
            for (var l = 0, ll = _lights.length; l < ll; l++) {
                var light = _lights[l];
                var lightColor = light.color;
                if (light instanceof AmbientLight) {
                    _ambientLight.add(lightColor);
                } else if (light instanceof DirectionalLight) {
                    _directionalLights.add(lightColor);
                } else if (light instanceof PointLight) {
                    _pointLights.add(lightColor);
                }
            }
        }
        function calculateLight(position, normal, color) {
            for (var l = 0, ll = _lights.length; l < ll; l++) {
                var light = _lights[l];
                _lightColor.copy(light.color);
                if (light instanceof DirectionalLight) {
                    var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();
                    var amount = normal.dot(lightPosition);
                    if (amount <= 0) continue;
                    amount *= light.intensity;
                    color.add(_lightColor.multiplyScalar(amount));
                } else if (light instanceof PointLight) {
                    var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);
                    var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());
                    if (amount <= 0) continue;
                    amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);
                    if (amount == 0) continue;
                    amount *= light.intensity;
                    color.add(_lightColor.multiplyScalar(amount));
                }
            }
        }
        function renderSprite(v1, element, material) {
            setOpacity(material.opacity);
            setBlending(material.blending);
            var scaleX = element.scale.x * _canvasWidthHalf;
            var scaleY = element.scale.y * _canvasHeightHalf;
            var dist = .5 * Math.sqrt(scaleX * scaleX + scaleY * scaleY);
            _elemBox.min.set(v1.x - dist, v1.y - dist);
            _elemBox.max.set(v1.x + dist, v1.y + dist);
            if (material instanceof SpriteMaterial) {
                var texture = material.map;
                if (texture !== null) {
                    var pattern = _patterns[texture.id];
                    if (pattern === undefined || pattern.version !== texture.version) {
                        pattern = textureToPattern(texture);
                        _patterns[texture.id] = pattern;
                    }
                    if (pattern.canvas !== undefined) {
                        setFillStyle(pattern.canvas);
                        var bitmap = texture.image;
                        var ox = bitmap.width * texture.offset.x;
                        var oy = bitmap.height * texture.offset.y;
                        var sx = bitmap.width * texture.repeat.x;
                        var sy = bitmap.height * texture.repeat.y;
                        var cx = scaleX / sx;
                        var cy = scaleY / sy;
                        _context.save();
                        _context.translate(v1.x, v1.y);
                        if (material.rotation !== 0) _context.rotate(material.rotation);
                        _context.translate(-scaleX / 2, -scaleY / 2);
                        _context.scale(cx, cy);
                        _context.translate(-ox, -oy);
                        _context.fillRect(ox, oy, sx, sy);
                        _context.restore();
                    }
                } else {
                    setFillStyle(material.color.getStyle());
                    _context.save();
                    _context.translate(v1.x, v1.y);
                    if (material.rotation !== 0) _context.rotate(material.rotation);
                    _context.scale(scaleX, -scaleY);
                    _context.fillRect(-.5, -.5, 1, 1);
                    _context.restore();
                }
            } else if (material instanceof SpriteCanvasMaterial) {
                setStrokeStyle(material.color.getStyle());
                setFillStyle(material.color.getStyle());
                _context.save();
                _context.translate(v1.x, v1.y);
                if (material.rotation !== 0) _context.rotate(material.rotation);
                _context.scale(scaleX, scaleY);
                material.program(_context);
                _context.restore();
            }
        }
        function renderLine(v1, v2, element, material) {
            setOpacity(material.opacity);
            setBlending(material.blending);
            _context.beginPath();
            _context.moveTo(v1.positionScreen.x, v1.positionScreen.y);
            _context.lineTo(v2.positionScreen.x, v2.positionScreen.y);
            if (material instanceof LineBasicMaterial) {
                setLineWidth(material.linewidth);
                setLineCap(material.linecap);
                setLineJoin(material.linejoin);
                if (material.vertexColors !== VertexColors) {
                    setStrokeStyle(material.color.getStyle());
                } else {
                    var colorStyle1 = element.vertexColors[0].getStyle();
                    var colorStyle2 = element.vertexColors[1].getStyle();
                    if (colorStyle1 === colorStyle2) {
                        setStrokeStyle(colorStyle1);
                    } else {
                        try {
                            var grad = _context.createLinearGradient(v1.positionScreen.x, v1.positionScreen.y, v2.positionScreen.x, v2.positionScreen.y);
                            grad.addColorStop(0, colorStyle1);
                            grad.addColorStop(1, colorStyle2);
                        } catch (exception) {
                            grad = colorStyle1;
                        }
                        setStrokeStyle(grad);
                    }
                }
                _context.stroke();
                _elemBox.expandByScalar(material.linewidth * 2);
            } else if (material instanceof LineDashedMaterial) {
                setLineWidth(material.linewidth);
                setLineCap(material.linecap);
                setLineJoin(material.linejoin);
                setStrokeStyle(material.color.getStyle());
                setLineDash([ material.dashSize, material.gapSize ]);
                _context.stroke();
                _elemBox.expandByScalar(material.linewidth * 2);
                setLineDash([]);
            }
        }
        function renderFace3(v1, v2, v3, uv1, uv2, uv3, element, material) {
            _this.info.render.vertices += 3;
            _this.info.render.faces++;
            setOpacity(material.opacity);
            setBlending(material.blending);
            _v1x = v1.positionScreen.x;
            _v1y = v1.positionScreen.y;
            _v2x = v2.positionScreen.x;
            _v2y = v2.positionScreen.y;
            _v3x = v3.positionScreen.x;
            _v3y = v3.positionScreen.y;
            drawTriangle(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y);
            if ((material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial) && material.map === null) {
                _diffuseColor.copy(material.color);
                _emissiveColor.copy(material.emissive);
                if (material.vertexColors === FaceColors) {
                    _diffuseColor.multiply(element.color);
                }
                _color.copy(_ambientLight);
                _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);
                calculateLight(_centroid, element.normalModel, _color);
                _color.multiply(_diffuseColor).add(_emissiveColor);
                material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
            } else if (material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial) {
                if (material.map !== null) {
                    var mapping = material.map.mapping;
                    if (mapping === UVMapping) {
                        _uvs = element.uvs;
                        patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[uv1].x, _uvs[uv1].y, _uvs[uv2].x, _uvs[uv2].y, _uvs[uv3].x, _uvs[uv3].y, material.map);
                    }
                } else if (material.envMap !== null) {
                    if (material.envMap.mapping === SphericalReflectionMapping) {
                        _normal.copy(element.vertexNormalsModel[uv1]).applyMatrix3(_normalViewMatrix);
                        _uv1x = .5 * _normal.x + .5;
                        _uv1y = .5 * _normal.y + .5;
                        _normal.copy(element.vertexNormalsModel[uv2]).applyMatrix3(_normalViewMatrix);
                        _uv2x = .5 * _normal.x + .5;
                        _uv2y = .5 * _normal.y + .5;
                        _normal.copy(element.vertexNormalsModel[uv3]).applyMatrix3(_normalViewMatrix);
                        _uv3x = .5 * _normal.x + .5;
                        _uv3y = .5 * _normal.y + .5;
                        patternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap);
                    }
                } else {
                    _color.copy(material.color);
                    if (material.vertexColors === FaceColors) {
                        _color.multiply(element.color);
                    }
                    material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
                }
            } else if (material instanceof MeshNormalMaterial) {
                _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix);
                _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(.5).addScalar(.5);
                material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
            } else {
                _color.setRGB(1, 1, 1);
                material.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);
            }
        }
        function drawTriangle(x0, y0, x1, y1, x2, y2) {
            _context.beginPath();
            _context.moveTo(x0, y0);
            _context.lineTo(x1, y1);
            _context.lineTo(x2, y2);
            _context.closePath();
        }
        function strokePath(color, linewidth, linecap, linejoin) {
            setLineWidth(linewidth);
            setLineCap(linecap);
            setLineJoin(linejoin);
            setStrokeStyle(color.getStyle());
            _context.stroke();
            _elemBox.expandByScalar(linewidth * 2);
        }
        function fillPath(color) {
            setFillStyle(color.getStyle());
            _context.fill();
        }
        function textureToPattern(texture) {
            if (texture.version === 0 || texture instanceof CompressedTexture || texture instanceof DataTexture) {
                return {
                    canvas: undefined,
                    version: texture.version
                };
            }
            var image = texture.image;
            if (image.complete === false) {
                return {
                    canvas: undefined,
                    version: 0
                };
            }
            var repeatX = texture.wrapS === RepeatWrapping || texture.wrapS === MirroredRepeatWrapping;
            var repeatY = texture.wrapT === RepeatWrapping || texture.wrapT === MirroredRepeatWrapping;
            var mirrorX = texture.wrapS === MirroredRepeatWrapping;
            var mirrorY = texture.wrapT === MirroredRepeatWrapping;
            var canvas = document.createElement("canvas");
            canvas.width = image.width * (mirrorX ? 2 : 1);
            canvas.height = image.height * (mirrorY ? 2 : 1);
            var context = canvas.getContext("2d");
            context.setTransform(1, 0, 0, -1, 0, image.height);
            context.drawImage(image, 0, 0);
            if (mirrorX === true) {
                context.setTransform(-1, 0, 0, -1, image.width, image.height);
                context.drawImage(image, -image.width, 0);
            }
            if (mirrorY === true) {
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.drawImage(image, 0, image.height);
            }
            if (mirrorX === true && mirrorY === true) {
                context.setTransform(-1, 0, 0, 1, image.width, 0);
                context.drawImage(image, -image.width, image.height);
            }
            var repeat = "no-repeat";
            if (repeatX === true && repeatY === true) {
                repeat = "repeat";
            } else if (repeatX === true) {
                repeat = "repeat-x";
            } else if (repeatY === true) {
                repeat = "repeat-y";
            }
            var pattern = _context.createPattern(canvas, repeat);
            if (texture.onUpdate) texture.onUpdate(texture);
            return {
                canvas: pattern,
                version: texture.version
            };
        }
        function patternPath(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture) {
            var pattern = _patterns[texture.id];
            if (pattern === undefined || pattern.version !== texture.version) {
                pattern = textureToPattern(texture);
                _patterns[texture.id] = pattern;
            }
            if (pattern.canvas !== undefined) {
                setFillStyle(pattern.canvas);
            } else {
                setFillStyle("rgba( 0, 0, 0, 1)");
                _context.fill();
                return;
            }
            var a, b, c, d, e, f, det, idet, offsetX = texture.offset.x / texture.repeat.x, offsetY = texture.offset.y / texture.repeat.y, width = texture.image.width * texture.repeat.x, height = texture.image.height * texture.repeat.y;
            u0 = (u0 + offsetX) * width;
            v0 = (v0 + offsetY) * height;
            u1 = (u1 + offsetX) * width;
            v1 = (v1 + offsetY) * height;
            u2 = (u2 + offsetX) * width;
            v2 = (v2 + offsetY) * height;
            x1 -= x0;
            y1 -= y0;
            x2 -= x0;
            y2 -= y0;
            u1 -= u0;
            v1 -= v0;
            u2 -= u0;
            v2 -= v0;
            det = u1 * v2 - u2 * v1;
            if (det === 0) return;
            idet = 1 / det;
            a = (v2 * x1 - v1 * x2) * idet;
            b = (v2 * y1 - v1 * y2) * idet;
            c = (u1 * x2 - u2 * x1) * idet;
            d = (u1 * y2 - u2 * y1) * idet;
            e = x0 - a * u0 - c * v0;
            f = y0 - b * u0 - d * v0;
            _context.save();
            _context.transform(a, b, c, d, e, f);
            _context.fill();
            _context.restore();
        }
        function clipImage(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image) {
            var a, b, c, d, e, f, det, idet, width = image.width - 1, height = image.height - 1;
            u0 *= width;
            v0 *= height;
            u1 *= width;
            v1 *= height;
            u2 *= width;
            v2 *= height;
            x1 -= x0;
            y1 -= y0;
            x2 -= x0;
            y2 -= y0;
            u1 -= u0;
            v1 -= v0;
            u2 -= u0;
            v2 -= v0;
            det = u1 * v2 - u2 * v1;
            idet = 1 / det;
            a = (v2 * x1 - v1 * x2) * idet;
            b = (v2 * y1 - v1 * y2) * idet;
            c = (u1 * x2 - u2 * x1) * idet;
            d = (u1 * y2 - u2 * y1) * idet;
            e = x0 - a * u0 - c * v0;
            f = y0 - b * u0 - d * v0;
            _context.save();
            _context.transform(a, b, c, d, e, f);
            _context.clip();
            _context.drawImage(image, 0, 0);
            _context.restore();
        }
        function expand(v1, v2, pixels) {
            var x = v2.x - v1.x, y = v2.y - v1.y, det = x * x + y * y, idet;
            if (det === 0) return;
            idet = pixels / Math.sqrt(det);
            x *= idet;
            y *= idet;
            v2.x += x;
            v2.y += y;
            v1.x -= x;
            v1.y -= y;
        }
        function setOpacity(value) {
            if (_contextGlobalAlpha !== value) {
                _context.globalAlpha = value;
                _contextGlobalAlpha = value;
            }
        }
        function setBlending(value) {
            if (_contextGlobalCompositeOperation !== value) {
                if (value === NormalBlending) {
                    _context.globalCompositeOperation = "source-over";
                } else if (value === AdditiveBlending) {
                    _context.globalCompositeOperation = "lighter";
                } else if (value === SubtractiveBlending) {
                    _context.globalCompositeOperation = "darker";
                } else if (value === MultiplyBlending) {
                    _context.globalCompositeOperation = "multiply";
                }
                _contextGlobalCompositeOperation = value;
            }
        }
        function setLineWidth(value) {
            if (_contextLineWidth !== value) {
                _context.lineWidth = value;
                _contextLineWidth = value;
            }
        }
        function setLineCap(value) {
            if (_contextLineCap !== value) {
                _context.lineCap = value;
                _contextLineCap = value;
            }
        }
        function setLineJoin(value) {
            if (_contextLineJoin !== value) {
                _context.lineJoin = value;
                _contextLineJoin = value;
            }
        }
        function setStrokeStyle(value) {
            if (_contextStrokeStyle !== value) {
                _context.strokeStyle = value;
                _contextStrokeStyle = value;
            }
        }
        function setFillStyle(value) {
            if (_contextFillStyle !== value) {
                _context.fillStyle = value;
                _contextFillStyle = value;
            }
        }
        function setLineDash(value) {
            if (_contextLineDash.length !== value.length) {
                _context.setLineDash(value);
                _contextLineDash = value;
            }
        }
    }
    function PlanControls(object, domElement) {
        domElement = domElement !== undefined ? domElement : document;
        this.enabled = true;
        this.center = new Vector3();
        this.panSpeed = .001;
        this.zoomSpeed = .001;
        var scope = this;
        var vector = new Vector3();
        var STATE = {
            NONE: 0,
            ZOOM: 1,
            PAN: 2
        };
        var state = STATE.NONE;
        var normalMatrix = new Matrix3();
        var pointer = new Vector2();
        var pointerOld = new Vector2();
        var spherical = new Spherical();
        var changeEvent = {
            type: "change"
        };
        this.focus = function(target) {
            var box = new Box3().setFromObject(target);
            object.lookAt(scope.center.copy(box.getCenter()));
            scope.dispatchEvent(changeEvent);
        };
        this.pan = function(delta) {
            var distance = object.position.distanceTo(scope.center);
            delta.multiplyScalar(distance * scope.panSpeed);
            delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
            object.position.add(delta);
            scope.center.add(delta);
            scope.dispatchEvent(changeEvent);
        };
        this.zoom = function(delta) {
            var distance = object.position.distanceTo(scope.center);
            delta.multiplyScalar(distance * scope.zoomSpeed);
            if (delta.length() > distance) return;
            delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
            object.position.add(delta);
            scope.dispatchEvent(changeEvent);
        };
        function onMouseDown(event) {
            if (scope.enabled === false) return;
            if (event.button === 0) {
                state = STATE.PAN;
            } else if (event.button === 1) {
                state = STATE.ZOOM;
            } else if (event.button === 2) {
                state = STATE.PAN;
            }
            pointerOld.set(event.clientX, event.clientY);
            domElement.addEventListener("mousemove", onMouseMove, false);
            domElement.addEventListener("mouseup", onMouseUp, false);
            domElement.addEventListener("mouseout", onMouseUp, false);
            domElement.addEventListener("dblclick", onMouseUp, false);
        }
        function onMouseMove(event) {
            if (scope.enabled === false) return;
            pointer.set(event.clientX, event.clientY);
            var movementX = pointer.x - pointerOld.x;
            var movementY = pointer.y - pointerOld.y;
            if (state === STATE.ZOOM) {
                scope.zoom(new Vector3(0, 0, movementY));
            } else if (state === STATE.PAN) {
                scope.pan(new Vector3(-movementX, movementY, 0));
            }
            pointerOld.set(event.clientX, event.clientY);
        }
        function onMouseUp(event) {
            domElement.removeEventListener("mousemove", onMouseMove, false);
            domElement.removeEventListener("mouseup", onMouseUp, false);
            domElement.removeEventListener("mouseout", onMouseUp, false);
            domElement.removeEventListener("dblclick", onMouseUp, false);
            state = STATE.NONE;
        }
        function onMouseWheel(event) {
            event.preventDefault();
            if (scope.enabled === false) return;
            scope.zoom(new Vector3(0, 0, event.deltaY));
        }
        function contextmenu(event) {
            event.preventDefault();
        }
        this.dispose = function() {
            domElement.removeEventListener("contextmenu", contextmenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("mousemove", onMouseMove, false);
            domElement.removeEventListener("mouseup", onMouseUp, false);
            domElement.removeEventListener("mouseout", onMouseUp, false);
            domElement.removeEventListener("dblclick", onMouseUp, false);
            domElement.removeEventListener("touchstart", touchStart, false);
            domElement.removeEventListener("touchmove", touchMove, false);
        };
        domElement.addEventListener("contextmenu", contextmenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        var touch = new Vector3();
        var touches = [ new Vector3(), new Vector3(), new Vector3() ];
        var prevTouches = [ new Vector3(), new Vector3(), new Vector3() ];
        var prevDistance = null;
        function touchStart(event) {
            if (scope.enabled === false) return;
            switch (event.touches.length) {
              case 1:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                break;

              case 2:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
                prevDistance = touches[0].distanceTo(touches[1]);
                break;
            }
            prevTouches[0].copy(touches[0]);
            prevTouches[1].copy(touches[1]);
        }
        function touchMove(event) {
            if (scope.enabled === false) return;
            event.preventDefault();
            event.stopPropagation();
            function getClosest(touch, touches) {
                var closest = touches[0];
                for (var i in touches) {
                    if (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];
                }
                return closest;
            }
            switch (event.touches.length) {
              case 1:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                var offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));
                offset0.x = -offset0.x;
                scope.pan(offset0.clone());
                break;

              case 2:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
                distance = touches[0].distanceTo(touches[1]);
                scope.zoom(new Vector3(0, 0, prevDistance - distance));
                prevDistance = distance;
                var offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));
                var offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));
                offset0.x = -offset0.x;
                offset1.x = -offset1.x;
                scope.pan(offset0.add(offset1).multiplyScalar(.5));
                break;
            }
            prevTouches[0].copy(touches[0]);
            prevTouches[1].copy(touches[1]);
        }
        domElement.addEventListener("touchstart", touchStart, false);
        domElement.addEventListener("touchmove", touchMove, false);
    }
    PlanControls.prototype = Object.create(EventDispatcher.prototype);
    PlanControls.prototype.constructor = PlanControls;
    function EditorControls(object, domElement) {
        domElement = domElement !== undefined ? domElement : document;
        this.enabled = true;
        this.center = new Vector3();
        this.panSpeed = .001;
        this.zoomSpeed = .001;
        this.rotationSpeed = .005;
        var scope = this;
        var vector = new Vector3();
        var STATE = {
            NONE: -1,
            ROTATE: 0,
            ZOOM: 1,
            PAN: 2
        };
        var state = STATE.NONE;
        var normalMatrix = new Matrix3();
        var pointer = new Vector2();
        var pointerOld = new Vector2();
        var spherical = new Spherical();
        var changeEvent = {
            type: "change"
        };
        this.focus = function(target) {
            var box = new Box3().setFromObject(target);
            object.lookAt(scope.center.copy(box.getCenter()));
            scope.dispatchEvent(changeEvent);
        };
        this.pan = function(delta) {
            var distance = object.position.distanceTo(scope.center);
            delta.multiplyScalar(distance * scope.panSpeed);
            delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
            object.position.add(delta);
            scope.center.add(delta);
            scope.dispatchEvent(changeEvent);
        };
        this.zoom = function(delta) {
            var distance = object.position.distanceTo(scope.center);
            delta.multiplyScalar(distance * scope.zoomSpeed);
            if (delta.length() > distance) return;
            delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
            object.position.add(delta);
            scope.dispatchEvent(changeEvent);
        };
        this.rotate = function(delta) {
            vector.copy(object.position).sub(scope.center);
            spherical.setFromVector3(vector);
            spherical.theta += delta.x;
            spherical.phi += delta.y;
            spherical.makeSafe();
            vector.setFromSpherical(spherical);
            object.position.copy(scope.center).add(vector);
            object.lookAt(scope.center);
            scope.dispatchEvent(changeEvent);
        };
        function onMouseDown(event) {
            if (scope.enabled === false) return;
            if (event.button === 0) {
                state = STATE.ROTATE;
            } else if (event.button === 1) {
                state = STATE.ZOOM;
            } else if (event.button === 2) {
                state = STATE.PAN;
            }
            pointerOld.set(event.clientX, event.clientY);
            domElement.addEventListener("mousemove", onMouseMove, false);
            domElement.addEventListener("mouseup", onMouseUp, false);
            domElement.addEventListener("mouseout", onMouseUp, false);
            domElement.addEventListener("dblclick", onMouseUp, false);
        }
        function onMouseMove(event) {
            if (scope.enabled === false) return;
            pointer.set(event.clientX, event.clientY);
            var movementX = pointer.x - pointerOld.x;
            var movementY = pointer.y - pointerOld.y;
            if (state === STATE.ROTATE) {
                scope.rotate(new Vector3(-movementX * scope.rotationSpeed, -movementY * scope.rotationSpeed, 0));
            } else if (state === STATE.ZOOM) {
                scope.zoom(new Vector3(0, 0, movementY));
            } else if (state === STATE.PAN) {
                scope.pan(new Vector3(-movementX, movementY, 0));
            }
            pointerOld.set(event.clientX, event.clientY);
        }
        function onMouseUp(event) {
            domElement.removeEventListener("mousemove", onMouseMove, false);
            domElement.removeEventListener("mouseup", onMouseUp, false);
            domElement.removeEventListener("mouseout", onMouseUp, false);
            domElement.removeEventListener("dblclick", onMouseUp, false);
            state = STATE.NONE;
        }
        function onMouseWheel(event) {
            event.preventDefault();
            if (scope.enabled === false) return;
            scope.zoom(new Vector3(0, 0, event.deltaY));
        }
        function contextmenu(event) {
            event.preventDefault();
        }
        var touch = new Vector3();
        var touches = [ new Vector3(), new Vector3(), new Vector3() ];
        var prevTouches = [ new Vector3(), new Vector3(), new Vector3() ];
        var prevDistance = null;
        function touchStart(event) {
            if (scope.enabled === false) return;
            switch (event.touches.length) {
              case 1:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                break;

              case 2:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
                prevDistance = touches[0].distanceTo(touches[1]);
                break;
            }
            prevTouches[0].copy(touches[0]);
            prevTouches[1].copy(touches[1]);
        }
        function touchMove(event) {
            if (scope.enabled === false) return;
            event.preventDefault();
            event.stopPropagation();
            function getClosest(touch, touches) {
                var closest = touches[0];
                for (var i in touches) {
                    if (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];
                }
                return closest;
            }
            switch (event.touches.length) {
              case 1:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                scope.rotate(touches[0].sub(getClosest(touches[0], prevTouches)).multiplyScalar(-scope.rotationSpeed));
                break;

              case 2:
                touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
                touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
                distance = touches[0].distanceTo(touches[1]);
                scope.zoom(new Vector3(0, 0, prevDistance - distance));
                prevDistance = distance;
                var offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));
                var offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));
                offset0.x = -offset0.x;
                offset1.x = -offset1.x;
                scope.pan(offset0.add(offset1).multiplyScalar(.5));
                break;
            }
            prevTouches[0].copy(touches[0]);
            prevTouches[1].copy(touches[1]);
        }
        this.dispose = function() {
            domElement.removeEventListener("contextmenu", contextmenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("mousemove", onMouseMove, false);
            domElement.removeEventListener("mouseup", onMouseUp, false);
            domElement.removeEventListener("mouseout", onMouseUp, false);
            domElement.removeEventListener("dblclick", onMouseUp, false);
            domElement.removeEventListener("touchstart", touchStart, false);
            domElement.removeEventListener("touchmove", touchMove, false);
        };
        domElement.addEventListener("contextmenu", contextmenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        domElement.addEventListener("touchstart", touchStart, false);
        domElement.addEventListener("touchmove", touchMove, false);
    }
    EditorControls.prototype = Object.create(EventDispatcher.prototype);
    EditorControls.prototype.constructor = EditorControls;
    function GameControls(object, domElement) {
        domElement = domElement !== undefined ? domElement : document;
        this.enabled = true;
        var scope = this;
        var STATE = {
            NONE: -1,
            FORWARDS: 0,
            STANDSTILL: 1,
            BACKWARDS: 2
        };
        var state = STATE.NONE;
        var pointer = new Vector2();
        var changeEvent = {
            type: "change"
        };
        this.update = function(delta) {
            if (scope.enabled === false) return;
            if (state === STATE.NONE) {
                return;
            }
            var movementX = 200 * (pointer.x - domElement.offsetWidth / 2) / domElement.offsetWidth;
            var movementY = 200 * (pointer.y - domElement.offsetHeight / 2) / domElement.offsetHeight;
            if (state === STATE.FORWARDS) {
                object.translateZ((movementY - 100) * delta);
                object.rotateY(-movementX * delta * Math.PI / 360);
            } else if (state === STATE.STANDSTILL) {
                object.translateZ(movementY * delta);
                object.rotateY(-movementX * delta * Math.PI / 360);
            } else if (state === STATE.BACKWARDS) {
                object.translateZ((movementY + 100) * delta);
                object.rotateY(-movementX * delta * Math.PI / 360);
            }
            scope.dispatchEvent(changeEvent);
        };
        function onMouseDown(event) {
            event.preventDefault();
            if (scope.enabled === false) return;
            if (event.button === 0) {
                state = STATE.FORWARDS;
            } else if (event.button === 1) {
                state = STATE.STANDSTILL;
            } else if (event.button === 2) {
                state = STATE.BACKWARDS;
            }
            pointer.set(event.offsetX, event.offsetY);
            domElement.addEventListener("mousemove", onMouseMove, false);
            domElement.addEventListener("mouseup", onMouseUp, false);
            domElement.addEventListener("mouseout", onMouseUp, false);
            domElement.addEventListener("dblclick", onMouseUp, false);
        }
        function onMouseMove(event) {
            event.preventDefault();
            if (scope.enabled === false) return;
            pointer.set(event.offsetX, event.offsetY);
        }
        function onMouseUp(event) {
            event.preventDefault();
            domElement.removeEventListener("mousemove", onMouseMove, false);
            domElement.removeEventListener("mouseup", onMouseUp, false);
            domElement.removeEventListener("mouseout", onMouseUp, false);
            domElement.removeEventListener("dblclick", onMouseUp, false);
            state = STATE.NONE;
        }
        function contextmenu(event) {
            event.preventDefault();
            event.stopPropagation();
        }
        function touchStart(event) {
            event.preventDefault();
            if (scope.enabled === false) return;
            if (event.touches.length === 1) {
                pointer.set(event.touches[0].pageX - domElement.offsetLeft, event.touches[0].pageY - domElement.offsetTop);
                state = STATE.STANDSTILL;
                domElement.addEventListener("touchmove", touchMove, false);
                domElement.addEventListener("touchend", touchEnd, false);
            }
        }
        function touchMove(event) {
            event.preventDefault();
            if (scope.enabled === false) return;
            if (event.touches.length === 1) {
                pointer.set(event.touches[0].pageX - domElement.offsetLeft, event.touches[0].pageY - domElement.offsetTop);
            }
        }
        function touchEnd(event) {
            event.preventDefault();
            domElement.removeEventListener("touchmove", touchMove, false);
            domElement.removeEventListener("touchend", touchEnd, false);
            state = STATE.NONE;
        }
        this.dispose = function() {
            domElement.removeEventListener("contextmenu", contextmenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("mousemove", onMouseMove, false);
            domElement.removeEventListener("mouseup", onMouseUp, false);
            domElement.removeEventListener("mouseout", onMouseUp, false);
            domElement.removeEventListener("dblclick", onMouseUp, false);
            domElement.removeEventListener("touchstart", touchStart, false);
            domElement.removeEventListener("touchmove", touchMove, false);
            domElement.removeEventListener("touchend", touchEnd, false);
            state = STATE.NONE;
        };
        domElement.addEventListener("contextmenu", contextmenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("touchstart", touchStart, false);
    }
    GameControls.prototype = Object.create(EventDispatcher.prototype);
    GameControls.prototype.constructor = GameControls;
    function GizmoMaterial(parameters) {
        MeshBasicMaterial.call(this);
        this.depthTest = false;
        this.depthWrite = false;
        this.side = FrontSide;
        this.transparent = true;
        this.setValues(parameters);
        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;
        this.highlight = function(highlighted) {
            if (highlighted) {
                this.color.setRGB(1, 1, 0);
                this.opacity = 1;
            } else {
                this.color.copy(this.oldColor);
                this.opacity = this.oldOpacity;
            }
        };
    }
    GizmoMaterial.prototype = Object.create(MeshBasicMaterial.prototype);
    GizmoMaterial.prototype.constructor = GizmoMaterial;
    function GizmoLineMaterial(parameters) {
        LineBasicMaterial.call(this);
        this.depthTest = false;
        this.depthWrite = false;
        this.transparent = true;
        this.linewidth = 1;
        this.setValues(parameters);
        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;
        this.highlight = function(highlighted) {
            if (highlighted) {
                this.color.setRGB(1, 1, 0);
                this.opacity = 1;
            } else {
                this.color.copy(this.oldColor);
                this.opacity = this.oldOpacity;
            }
        };
    }
    GizmoLineMaterial.prototype = Object.create(LineBasicMaterial.prototype);
    GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;
    var pickerMaterial = new GizmoMaterial({
        visible: false,
        transparent: false
    });
    function TransformGizmo() {
        var scope = this;
        this.init = function() {
            Object3D.call(this);
            this.handles = new Object3D();
            this.pickers = new Object3D();
            this.planes = new Object3D();
            this.add(this.handles);
            this.add(this.pickers);
            this.add(this.planes);
            var planeGeometry = new PlaneBufferGeometry(50, 50, 2, 2);
            var planeMaterial = new MeshBasicMaterial({
                visible: false,
                side: DoubleSide
            });
            var planes = {
                XY: new Mesh(planeGeometry, planeMaterial),
                YZ: new Mesh(planeGeometry, planeMaterial),
                XZ: new Mesh(planeGeometry, planeMaterial),
                XYZE: new Mesh(planeGeometry, planeMaterial)
            };
            this.activePlane = planes["XYZE"];
            planes["YZ"].rotation.set(0, Math.PI / 2, 0);
            planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);
            for (var i in planes) {
                planes[i].name = i;
                this.planes.add(planes[i]);
                this.planes[i] = planes[i];
            }
            var setupGizmos = function(gizmoMap, parent) {
                for (var name in gizmoMap) {
                    for (i = gizmoMap[name].length; i--; ) {
                        var object = gizmoMap[name][i][0];
                        var position = gizmoMap[name][i][1];
                        var rotation = gizmoMap[name][i][2];
                        object.name = name;
                        if (position) object.position.set(position[0], position[1], position[2]);
                        if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);
                        parent.add(object);
                    }
                }
            };
            setupGizmos(this.handleGizmos, this.handles);
            setupGizmos(this.pickerGizmos, this.pickers);
            this.traverse(function(child) {
                if (child instanceof Mesh) {
                    child.updateMatrix();
                    var tempGeometry = child.geometry.clone();
                    tempGeometry.applyMatrix(child.matrix);
                    child.geometry = tempGeometry;
                    child.position.set(0, 0, 0);
                    child.rotation.set(0, 0, 0);
                    child.scale.set(1, 1, 1);
                }
            });
        };
        this.highlight = function(axis) {
            this.traverse(function(child) {
                if (child.material && child.material.highlight) {
                    if (child.name === axis) {
                        child.material.highlight(true);
                    } else {
                        child.material.highlight(false);
                    }
                }
            });
        };
    }
    TransformGizmo.prototype = Object.create(Object3D.prototype);
    TransformGizmo.prototype.constructor = TransformGizmo;
    TransformGizmo.prototype.update = function(rotation, eye) {
        var vec1 = new Vector3(0, 0, 0);
        var vec2 = new Vector3(0, 1, 0);
        var lookAtMatrix = new Matrix4();
        this.traverse(function(child) {
            if (child.name.search("E") !== -1) {
                child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));
            } else if (child.name.search("X") !== -1 || child.name.search("Y") !== -1 || child.name.search("Z") !== -1) {
                child.quaternion.setFromEuler(rotation);
            }
        });
    };
    function TransformGizmoTranslate() {
        TransformGizmo.call(this);
        var arrowGeometry = new Geometry();
        var mesh = new Mesh(new CylinderGeometry(0, .05, .2, 12, 1, false));
        mesh.position.y = .5;
        mesh.updateMatrix();
        arrowGeometry.merge(mesh.geometry, mesh.matrix);
        var lineXGeometry = new BufferGeometry();
        lineXGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 1, 0, 0 ], 3));
        var lineYGeometry = new BufferGeometry();
        lineYGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 1, 0 ], 3));
        var lineZGeometry = new BufferGeometry();
        lineZGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3));
        this.handleGizmos = {
            X: [ [ new Mesh(arrowGeometry, new GizmoMaterial({
                color: 16711680
            })), [ .5, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ], [ new Line(lineXGeometry, new GizmoLineMaterial({
                color: 16711680
            })) ] ],
            Y: [ [ new Mesh(arrowGeometry, new GizmoMaterial({
                color: 65280
            })), [ 0, .5, 0 ] ], [ new Line(lineYGeometry, new GizmoLineMaterial({
                color: 65280
            })) ] ],
            Z: [ [ new Mesh(arrowGeometry, new GizmoMaterial({
                color: 255
            })), [ 0, 0, .5 ], [ Math.PI / 2, 0, 0 ] ], [ new Line(lineZGeometry, new GizmoLineMaterial({
                color: 255
            })) ] ],
            XYZ: [ [ new Mesh(new OctahedronGeometry(.1, 0), new GizmoMaterial({
                color: 16777215,
                opacity: .25
            })), [ 0, 0, 0 ], [ 0, 0, 0 ] ] ],
            XY: [ [ new Mesh(new PlaneBufferGeometry(.29, .29), new GizmoMaterial({
                color: 16776960,
                opacity: .25
            })), [ .15, .15, 0 ] ] ],
            YZ: [ [ new Mesh(new PlaneBufferGeometry(.29, .29), new GizmoMaterial({
                color: 65535,
                opacity: .25
            })), [ 0, .15, .15 ], [ 0, Math.PI / 2, 0 ] ] ],
            XZ: [ [ new Mesh(new PlaneBufferGeometry(.29, .29), new GizmoMaterial({
                color: 16711935,
                opacity: .25
            })), [ .15, 0, .15 ], [ -Math.PI / 2, 0, 0 ] ] ]
        };
        this.pickerGizmos = {
            X: [ [ new Mesh(new CylinderBufferGeometry(.2, 0, 1, 4, 1, false), pickerMaterial), [ .6, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ] ],
            Y: [ [ new Mesh(new CylinderBufferGeometry(.2, 0, 1, 4, 1, false), pickerMaterial), [ 0, .6, 0 ] ] ],
            Z: [ [ new Mesh(new CylinderBufferGeometry(.2, 0, 1, 4, 1, false), pickerMaterial), [ 0, 0, .6 ], [ Math.PI / 2, 0, 0 ] ] ],
            XYZ: [ [ new Mesh(new OctahedronGeometry(.2, 0), pickerMaterial) ] ],
            XY: [ [ new Mesh(new PlaneBufferGeometry(.4, .4), pickerMaterial), [ .2, .2, 0 ] ] ],
            YZ: [ [ new Mesh(new PlaneBufferGeometry(.4, .4), pickerMaterial), [ 0, .2, .2 ], [ 0, Math.PI / 2, 0 ] ] ],
            XZ: [ [ new Mesh(new PlaneBufferGeometry(.4, .4), pickerMaterial), [ .2, 0, .2 ], [ -Math.PI / 2, 0, 0 ] ] ]
        };
        this.setActivePlane = function(axis, eye) {
            var tempMatrix = new Matrix4();
            eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));
            if (axis === "X") {
                this.activePlane = this.planes["XY"];
                if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
            }
            if (axis === "Y") {
                this.activePlane = this.planes["XY"];
                if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
            }
            if (axis === "Z") {
                this.activePlane = this.planes["XZ"];
                if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
            }
            if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
            if (axis === "XY") this.activePlane = this.planes["XY"];
            if (axis === "YZ") this.activePlane = this.planes["YZ"];
            if (axis === "XZ") this.activePlane = this.planes["XZ"];
        };
        this.init();
    }
    TransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);
    TransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;
    function TransformGizmoRotate() {
        TransformGizmo.call(this);
        var CircleGeometry = function(radius, facing, arc) {
            var geometry = new BufferGeometry();
            var vertices = [];
            arc = arc ? arc : 1;
            for (var i = 0; i <= 64 * arc; ++i) {
                if (facing === "x") vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
                if (facing === "y") vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);
                if (facing === "z") vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);
            }
            geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
            return geometry;
        };
        this.handleGizmos = {
            X: [ [ new Line(new CircleGeometry(1, "x", .5), new GizmoLineMaterial({
                color: 16711680
            })) ] ],
            Y: [ [ new Line(new CircleGeometry(1, "y", .5), new GizmoLineMaterial({
                color: 65280
            })) ] ],
            Z: [ [ new Line(new CircleGeometry(1, "z", .5), new GizmoLineMaterial({
                color: 255
            })) ] ],
            E: [ [ new Line(new CircleGeometry(1.25, "z", 1), new GizmoLineMaterial({
                color: 13421568
            })) ] ],
            XYZE: [ [ new Line(new CircleGeometry(1, "z", 1), new GizmoLineMaterial({
                color: 7895160
            })) ] ]
        };
        this.pickerGizmos = {
            X: [ [ new Mesh(new TorusBufferGeometry(1, .12, 4, 12, Math.PI), pickerMaterial), [ 0, 0, 0 ], [ 0, -Math.PI / 2, -Math.PI / 2 ] ] ],
            Y: [ [ new Mesh(new TorusBufferGeometry(1, .12, 4, 12, Math.PI), pickerMaterial), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ] ] ],
            Z: [ [ new Mesh(new TorusBufferGeometry(1, .12, 4, 12, Math.PI), pickerMaterial), [ 0, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ] ],
            E: [ [ new Mesh(new TorusBufferGeometry(1.25, .12, 2, 24), pickerMaterial) ] ],
            XYZE: [ [ new Mesh() ] ]
        };
        this.setActivePlane = function(axis) {
            if (axis === "E") this.activePlane = this.planes["XYZE"];
            if (axis === "X") this.activePlane = this.planes["YZ"];
            if (axis === "Y") this.activePlane = this.planes["XZ"];
            if (axis === "Z") this.activePlane = this.planes["XY"];
        };
        this.update = function(rotation, eye2) {
            TransformGizmo.prototype.update.apply(this, arguments);
            var group = {
                handles: this["handles"],
                pickers: this["pickers"]
            };
            var tempMatrix = new Matrix4();
            var worldRotation = new Euler(0, 0, 1);
            var tempQuaternion = new Quaternion();
            var unitX = new Vector3(1, 0, 0);
            var unitY = new Vector3(0, 1, 0);
            var unitZ = new Vector3(0, 0, 1);
            var quaternionX = new Quaternion();
            var quaternionY = new Quaternion();
            var quaternionZ = new Quaternion();
            var eye = eye2.clone();
            worldRotation.copy(this.planes["XY"].rotation);
            tempQuaternion.setFromEuler(worldRotation);
            tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
            eye.applyMatrix4(tempMatrix);
            this.traverse(function(child) {
                tempQuaternion.setFromEuler(worldRotation);
                if (child.name === "X") {
                    quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                    child.quaternion.copy(tempQuaternion);
                }
                if (child.name === "Y") {
                    quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
                    child.quaternion.copy(tempQuaternion);
                }
                if (child.name === "Z") {
                    quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
                    child.quaternion.copy(tempQuaternion);
                }
            });
        };
        this.init();
    }
    TransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);
    TransformGizmoRotate.prototype.constructor = TransformGizmoRotate;
    function TransformGizmoScale() {
        TransformGizmo.call(this);
        var arrowGeometry = new Geometry();
        var mesh = new Mesh(new BoxGeometry(.125, .125, .125));
        mesh.position.y = .5;
        mesh.updateMatrix();
        arrowGeometry.merge(mesh.geometry, mesh.matrix);
        var lineXGeometry = new BufferGeometry();
        lineXGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 1, 0, 0 ], 3));
        var lineYGeometry = new BufferGeometry();
        lineYGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 1, 0 ], 3));
        var lineZGeometry = new BufferGeometry();
        lineZGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3));
        this.handleGizmos = {
            X: [ [ new Mesh(arrowGeometry, new GizmoMaterial({
                color: 16711680
            })), [ .5, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ], [ new Line(lineXGeometry, new GizmoLineMaterial({
                color: 16711680
            })) ] ],
            Y: [ [ new Mesh(arrowGeometry, new GizmoMaterial({
                color: 65280
            })), [ 0, .5, 0 ] ], [ new Line(lineYGeometry, new GizmoLineMaterial({
                color: 65280
            })) ] ],
            Z: [ [ new Mesh(arrowGeometry, new GizmoMaterial({
                color: 255
            })), [ 0, 0, .5 ], [ Math.PI / 2, 0, 0 ] ], [ new Line(lineZGeometry, new GizmoLineMaterial({
                color: 255
            })) ] ],
            XYZ: [ [ new Mesh(new BoxBufferGeometry(.125, .125, .125), new GizmoMaterial({
                color: 16777215,
                opacity: .25
            })) ] ]
        };
        this.pickerGizmos = {
            X: [ [ new Mesh(new CylinderBufferGeometry(.2, 0, 1, 4, 1, false), pickerMaterial), [ .6, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ] ],
            Y: [ [ new Mesh(new CylinderBufferGeometry(.2, 0, 1, 4, 1, false), pickerMaterial), [ 0, .6, 0 ] ] ],
            Z: [ [ new Mesh(new CylinderBufferGeometry(.2, 0, 1, 4, 1, false), pickerMaterial), [ 0, 0, .6 ], [ Math.PI / 2, 0, 0 ] ] ],
            XYZ: [ [ new Mesh(new BoxBufferGeometry(.4, .4, .4), pickerMaterial) ] ]
        };
        this.setActivePlane = function(axis, eye) {
            var tempMatrix = new Matrix4();
            eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));
            if (axis === "X") {
                this.activePlane = this.planes["XY"];
                if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
            }
            if (axis === "Y") {
                this.activePlane = this.planes["XY"];
                if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
            }
            if (axis === "Z") {
                this.activePlane = this.planes["XZ"];
                if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
            }
            if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
        };
        this.init();
    }
    TransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);
    TransformGizmoScale.prototype.constructor = TransformGizmoScale;
    function TransformControls(camera, domElement) {
        Object3D.call(this);
        domElement = domElement !== undefined ? domElement : document;
        this.object = undefined;
        this.visible = false;
        this.translationSnap = null;
        this.rotationSnap = null;
        this.space = "world";
        this.size = 1;
        this.axis = null;
        var scope = this;
        var _mode = "translate";
        var _dragging = false;
        var _plane = "XY";
        var _gizmo = {
            translate: new TransformGizmoTranslate(),
            rotate: new TransformGizmoRotate(),
            scale: new TransformGizmoScale()
        };
        for (var type in _gizmo) {
            var gizmoObj = _gizmo[type];
            gizmoObj.visible = type === _mode;
            this.add(gizmoObj);
        }
        var changeEvent = {
            type: "change"
        };
        var mouseDownEvent = {
            type: "mouseDown"
        };
        var mouseUpEvent = {
            type: "mouseUp",
            mode: _mode
        };
        var objectChangeEvent = {
            type: "objectChange"
        };
        var ray = new Raycaster();
        var pointerVector = new Vector2();
        var point = new Vector3();
        var offset = new Vector3();
        var rotation = new Vector3();
        var offsetRotation = new Vector3();
        var scale = 1;
        var lookAtMatrix = new Matrix4();
        var eye = new Vector3();
        var tempMatrix = new Matrix4();
        var tempVector = new Vector3();
        var tempQuaternion = new Quaternion();
        var unitX = new Vector3(1, 0, 0);
        var unitY = new Vector3(0, 1, 0);
        var unitZ = new Vector3(0, 0, 1);
        var quaternionXYZ = new Quaternion();
        var quaternionX = new Quaternion();
        var quaternionY = new Quaternion();
        var quaternionZ = new Quaternion();
        var quaternionE = new Quaternion();
        var oldPosition = new Vector3();
        var oldScale = new Vector3();
        var oldRotationMatrix = new Matrix4();
        var parentRotationMatrix = new Matrix4();
        var parentScale = new Vector3();
        var worldPosition = new Vector3();
        var worldRotation = new Euler();
        var worldRotationMatrix = new Matrix4();
        var camPosition = new Vector3();
        var camRotation = new Euler();
        domElement.addEventListener("mousedown", onPointerDown, false);
        domElement.addEventListener("touchstart", onPointerDown, false);
        domElement.addEventListener("mousemove", onPointerHover, false);
        domElement.addEventListener("touchmove", onPointerHover, false);
        domElement.addEventListener("mousemove", onPointerMove, false);
        domElement.addEventListener("touchmove", onPointerMove, false);
        domElement.addEventListener("mouseup", onPointerUp, false);
        domElement.addEventListener("mouseout", onPointerUp, false);
        domElement.addEventListener("touchend", onPointerUp, false);
        domElement.addEventListener("touchcancel", onPointerUp, false);
        domElement.addEventListener("touchleave", onPointerUp, false);
        this.dispose = function() {
            domElement.removeEventListener("mousedown", onPointerDown);
            domElement.removeEventListener("touchstart", onPointerDown);
            domElement.removeEventListener("mousemove", onPointerHover);
            domElement.removeEventListener("touchmove", onPointerHover);
            domElement.removeEventListener("mousemove", onPointerMove);
            domElement.removeEventListener("touchmove", onPointerMove);
            domElement.removeEventListener("mouseup", onPointerUp);
            domElement.removeEventListener("mouseout", onPointerUp);
            domElement.removeEventListener("touchend", onPointerUp);
            domElement.removeEventListener("touchcancel", onPointerUp);
            domElement.removeEventListener("touchleave", onPointerUp);
        };
        this.attach = function(object) {
            this.object = object;
            this.visible = true;
            this.update();
        };
        this.detach = function() {
            this.object = undefined;
            this.visible = false;
            this.axis = null;
        };
        this.getMode = function() {
            return _mode;
        };
        this.setMode = function(mode) {
            _mode = mode ? mode : _mode;
            if (_mode === "scale") scope.space = "local";
            for (var type in _gizmo) _gizmo[type].visible = type === _mode;
            this.update();
            scope.dispatchEvent(changeEvent);
        };
        this.setTranslationSnap = function(translationSnap) {
            scope.translationSnap = translationSnap;
        };
        this.setRotationSnap = function(rotationSnap) {
            scope.rotationSnap = rotationSnap;
        };
        this.setSize = function(size) {
            scope.size = size;
            this.update();
            scope.dispatchEvent(changeEvent);
        };
        this.setSpace = function(space) {
            scope.space = space;
            this.update();
            scope.dispatchEvent(changeEvent);
        };
        this.update = function() {
            if (scope.object === undefined) return;
            scope.object.updateMatrixWorld();
            worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
            worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));
            camera.updateMatrixWorld();
            camPosition.setFromMatrixPosition(camera.matrixWorld);
            camRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));
            scale = worldPosition.distanceTo(camPosition) / 6 * scope.size;
            this.position.copy(worldPosition);
            this.scale.set(scale, scale, scale);
            if (camera instanceof PerspectiveCamera) {
                eye.copy(camPosition).sub(worldPosition).normalize();
            } else if (camera instanceof OrthographicCamera) {
                eye.copy(camPosition).normalize();
            }
            if (scope.space === "local") {
                _gizmo[_mode].update(worldRotation, eye);
            } else if (scope.space === "world") {
                _gizmo[_mode].update(new Euler(), eye);
            }
            _gizmo[_mode].highlight(scope.axis);
        };
        function onPointerHover(event) {
            if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;
            var pointer = event.changedTouches ? event.changedTouches[0] : event;
            var intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);
            var axis = null;
            if (intersect) {
                axis = intersect.object.name;
                event.preventDefault();
            }
            if (scope.axis !== axis) {
                scope.axis = axis;
                scope.update();
                scope.dispatchEvent(changeEvent);
            }
        }
        function onPointerDown(event) {
            if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;
            var pointer = event.changedTouches ? event.changedTouches[0] : event;
            if (pointer.button === 0 || pointer.button === undefined) {
                var intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);
                if (intersect) {
                    event.preventDefault();
                    event.stopPropagation();
                    scope.dispatchEvent(mouseDownEvent);
                    scope.axis = intersect.object.name;
                    scope.update();
                    eye.copy(camPosition).sub(worldPosition).normalize();
                    _gizmo[_mode].setActivePlane(scope.axis, eye);
                    var planeIntersect = intersectObjects(pointer, [ _gizmo[_mode].activePlane ]);
                    if (planeIntersect) {
                        oldPosition.copy(scope.object.position);
                        oldScale.copy(scope.object.scale);
                        oldRotationMatrix.extractRotation(scope.object.matrix);
                        worldRotationMatrix.extractRotation(scope.object.matrixWorld);
                        parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);
                        parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));
                        offset.copy(planeIntersect.point);
                    }
                }
            }
            _dragging = true;
        }
        function onPointerMove(event) {
            if (scope.object === undefined || scope.axis === null || _dragging === false || event.button !== undefined && event.button !== 0) return;
            var pointer = event.changedTouches ? event.changedTouches[0] : event;
            var planeIntersect = intersectObjects(pointer, [ _gizmo[_mode].activePlane ]);
            if (planeIntersect === false) return;
            event.preventDefault();
            event.stopPropagation();
            point.copy(planeIntersect.point);
            if (_mode === "translate") {
                point.sub(offset);
                point.multiply(parentScale);
                if (scope.space === "local") {
                    point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                    if (scope.axis.search("X") === -1) point.x = 0;
                    if (scope.axis.search("Y") === -1) point.y = 0;
                    if (scope.axis.search("Z") === -1) point.z = 0;
                    point.applyMatrix4(oldRotationMatrix);
                    scope.object.position.copy(oldPosition);
                    scope.object.position.add(point);
                }
                if (scope.space === "world" || scope.axis.search("XYZ") !== -1) {
                    if (scope.axis.search("X") === -1) point.x = 0;
                    if (scope.axis.search("Y") === -1) point.y = 0;
                    if (scope.axis.search("Z") === -1) point.z = 0;
                    point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));
                    scope.object.position.copy(oldPosition);
                    scope.object.position.add(point);
                }
                if (scope.translationSnap !== null) {
                    if (scope.space === "local") {
                        scope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                    }
                    if (scope.axis.search("X") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;
                    if (scope.axis.search("Y") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;
                    if (scope.axis.search("Z") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;
                    if (scope.space === "local") {
                        scope.object.position.applyMatrix4(worldRotationMatrix);
                    }
                }
            } else if (_mode === "scale") {
                point.sub(offset);
                point.multiply(parentScale);
                if (scope.space === "local") {
                    if (scope.axis === "XYZ") {
                        scale = 1 + point.y * Math.min(oldScale.x, oldScale.y, oldScale.z) / 30;
                        scope.object.scale.x = oldScale.x * scale;
                        scope.object.scale.y = oldScale.y * scale;
                        scope.object.scale.z = oldScale.z * scale;
                    } else {
                        point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                        if (scope.axis === "X") scope.object.scale.x = oldScale.x * (1 + point.x * oldScale.x / 30);
                        if (scope.axis === "Y") scope.object.scale.y = oldScale.y * (1 + point.y * oldScale.y / 30);
                        if (scope.axis === "Z") scope.object.scale.z = oldScale.z * (1 + point.z * oldScale.z / 30);
                    }
                }
            } else if (_mode === "rotate") {
                point.sub(worldPosition);
                point.multiply(parentScale);
                tempVector.copy(offset).sub(worldPosition);
                tempVector.multiply(parentScale);
                if (scope.axis === "E") {
                    point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
                    tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
                    rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                    offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));
                    tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
                    quaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);
                    quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);
                    scope.object.quaternion.copy(tempQuaternion);
                } else if (scope.axis === "XYZE") {
                    quaternionE.setFromEuler(point.clone().cross(tempVector).normalize());
                    tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
                    quaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));
                    quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);
                    scope.object.quaternion.copy(tempQuaternion);
                } else if (scope.space === "local") {
                    point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                    tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
                    rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                    offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));
                    quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);
                    if (scope.rotationSnap !== null) {
                        quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
                        quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
                        quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
                    } else {
                        quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
                        quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
                        quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
                    }
                    if (scope.axis === "X") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
                    if (scope.axis === "Y") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
                    if (scope.axis === "Z") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);
                    scope.object.quaternion.copy(quaternionXYZ);
                } else if (scope.space === "world") {
                    rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
                    offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));
                    tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
                    if (scope.rotationSnap !== null) {
                        quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
                        quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
                        quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
                    } else {
                        quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
                        quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
                        quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
                    }
                    quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);
                    if (scope.axis === "X") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
                    if (scope.axis === "Y") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
                    if (scope.axis === "Z") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
                    tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);
                    scope.object.quaternion.copy(tempQuaternion);
                }
            }
            scope.update();
            scope.dispatchEvent(changeEvent);
            scope.dispatchEvent(objectChangeEvent);
        }
        function onPointerUp(event) {
            event.preventDefault();
            if (event.button !== undefined && event.button !== 0) return;
            if (_dragging && scope.axis !== null) {
                mouseUpEvent.mode = _mode;
                scope.dispatchEvent(mouseUpEvent);
            }
            _dragging = false;
            if ("TouchEvent" in window && event instanceof TouchEvent) {
                scope.axis = null;
                scope.update();
                scope.dispatchEvent(changeEvent);
            } else {
                onPointerHover(event);
            }
        }
        function intersectObjects(pointer, objects) {
            var rect = domElement.getBoundingClientRect();
            var x = (pointer.clientX - rect.left) / rect.width;
            var y = (pointer.clientY - rect.top) / rect.height;
            pointerVector.set(x * 2 - 1, -(y * 2) + 1);
            ray.setFromCamera(pointerVector, camera);
            var intersections = ray.intersectObjects(objects, true);
            return intersections[0] ? intersections[0] : false;
        }
    }
    TransformControls.prototype = Object.create(Object3D.prototype);
    TransformControls.prototype.constructor = TransformControls;
    exports.Math = _Math;
    exports.Color = Color;
    exports.Vector2 = Vector2;
    exports.Vector4 = Vector4;
    exports.Matrix4 = Matrix4;
    exports.Vector3 = Vector3;
    exports.Quaternion = Quaternion;
    exports.Matrix3 = Matrix3;
    exports.Euler = Euler;
    exports.Line3 = Line3;
    exports.Box2 = Box2;
    exports.Sphere = Sphere;
    exports.Box3 = Box3;
    exports.Ray = Ray;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Spherical = Spherical;
    exports.Cylindrical = Cylindrical;
    exports.Triangle = Triangle;
    exports.Interpolant = Interpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.Clock = Clock;
    exports.EventDispatcher = EventDispatcher;
    exports.Layers = Layers;
    exports.Raycaster = Raycaster;
    exports.Object3D = Object3D;
    exports.Face3 = Face3;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.GeometryIdCount = GeometryIdCount;
    exports.Geometry = Geometry;
    exports.BufferGeometry = BufferGeometry;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.Uniform = Uniform;
    exports.AnimationAction = AnimationAction;
    exports.AnimationUtils = AnimationUtils;
    exports.KeyframeTrackConstructor = KeyframeTrackConstructor;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationClip = AnimationClip;
    exports.PropertyBinding = PropertyBinding;
    exports.PropertyMixer = PropertyMixer;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.Audio = Audio;
    exports.AudioAnalyser = AudioAnalyser;
    exports.AudioContext = AudioContext;
    exports.PositionalAudio = PositionalAudio;
    exports.AudioListener = AudioListener;
    exports.Scene = Scene;
    exports.Fog = Fog;
    exports.FogExp2 = FogExp2;
    exports.Texture = Texture;
    exports.DepthTexture = DepthTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.CubeTexture = CubeTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.DataTexture = DataTexture;
    exports.VideoTexture = VideoTexture;
    exports.ShaderChunk = ShaderChunk;
    exports.UniformsUtils = UniformsUtils;
    exports.UniformsLib = UniformsLib;
    exports.ShaderLib = ShaderLib;
    exports.WebGLRenderer = WebGLRenderer;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGL2Renderer = WebGL2Renderer;
    exports.Group = Group;
    exports.Points = Points;
    exports.LineSegments = LineSegments;
    exports.Line = Line;
    exports.Mesh = Mesh;
    exports.Bone = Bone;
    exports.Skeleton = Skeleton;
    exports.SkinnedMesh = SkinnedMesh;
    exports.LOD = LOD;
    exports.Sprite = Sprite;
    exports.LensFlare = LensFlare;
    exports.Camera = Camera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.StereoCamera = StereoCamera;
    exports.CubeCamera = CubeCamera;
    exports.Light = Light;
    exports.LightShadow = LightShadow;
    exports.AmbientLight = AmbientLight;
    exports.HemisphereLight = HemisphereLight;
    exports.RectAreaLight = RectAreaLight;
    exports.PointLight = PointLight;
    exports.DirectionalLight = DirectionalLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.SpotLight = SpotLight;
    exports.SpotLightShadow = SpotLightShadow;
    exports.AudioLoader = AudioLoader;
    exports.Cache = Cache;
    exports.Loader = Loader;
    exports.FileLoader = FileLoader;
    exports.FontLoader = FontLoader;
    exports.ImageLoader = ImageLoader;
    exports.JSONLoader = JSONLoader;
    exports.DefaultLoadingManager = DefaultLoadingManager;
    exports.LoadingManager = LoadingManager;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.TextureLoader = TextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.AxisHelper = AxisHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.BoxHelper = BoxHelper;
    exports.CameraHelper = CameraHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.PolarGridHelper = PolarGridHelper;
    exports.GridHelper = GridHelper;
    exports.AmbientLightHelper = AmbientLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.RectAreaLightHelper = RectAreaLightHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.LightTargetHelper = LightTargetHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SceneUtils = SceneUtils;
    exports.ShapeUtils = ShapeUtils;
    exports.Curve = Curve;
    exports.CurvePath = CurvePath;
    exports.Font = Font;
    exports.ShapePath = ShapePath;
    exports.Path = Path;
    exports.Shape = Shape;
    exports.LineCurve = LineCurve;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.SplineCurve = SplineCurve;
    exports.EllipseCurve = EllipseCurve;
    exports.ArcCurve = ArcCurve;
    exports.LineCurve3 = LineCurve3;
    exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
    exports.CubicBezierCurve3 = CubicBezierCurve3;
    exports.CatmullRomCurve3 = CatmullRomCurve3;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.MorphBlendMesh = MorphBlendMesh;
    exports.Projector = Projector;
    exports.SpriteCanvasMaterial = SpriteCanvasMaterial;
    exports.CanvasRenderer = CanvasRenderer;
    exports.PlanControls = PlanControls;
    exports.EditorControls = EditorControls;
    exports.GameControls = GameControls;
    exports.TransformControls = TransformControls;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.arrayMin = arrayMin;
    exports.arrayMax = arrayMax;
    exports.Float64BufferAttribute = Float64BufferAttribute;
    exports.Float32BufferAttribute = Float32BufferAttribute;
    exports.Uint32BufferAttribute = Uint32BufferAttribute;
    exports.Int32BufferAttribute = Int32BufferAttribute;
    exports.Uint16BufferAttribute = Uint16BufferAttribute;
    exports.Int16BufferAttribute = Int16BufferAttribute;
    exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
    exports.Uint8BufferAttribute = Uint8BufferAttribute;
    exports.Int8BufferAttribute = Int8BufferAttribute;
    exports.BufferAttribute = BufferAttribute;
    exports.BoxGeometry = BoxGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ShapeBufferGeometry = ShapeBufferGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TubeBufferGeometry = TubeBufferGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.ParametricBufferGeometry = ParametricBufferGeometry;
    exports.WireframeGeometry = WireframeGeometry;
    exports.Material = Material;
    exports.PointsMaterial = PointsMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshToonMaterial = MeshToonMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShadowMaterial = ShadowMaterial;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
});